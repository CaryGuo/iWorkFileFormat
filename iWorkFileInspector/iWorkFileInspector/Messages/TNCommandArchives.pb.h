// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TNCommandArchives.proto

#ifndef PROTOBUF_TNCommandArchives_2eproto__INCLUDED
#define PROTOBUF_TNCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSCHArchives.pb.h"
#include "TSCHCommandArchives.pb.h"
#include "TSCEArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSAArchives.pb.h"
#include "TSTArchives.pb.h"
#include "TNArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TN {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TNCommandArchives_2eproto();
void protobuf_AssignDesc_TNCommandArchives_2eproto();
void protobuf_ShutdownFile_TNCommandArchives_2eproto();

class SheetCommandSelectionBehaviorArchive;
class CommandFormChooseTargetTableArchive;
class CommandSheetInsertDrawablesArchive;
class CommandSheetRemoveDrawablesArchive;
class CommandSheetMoveDrawableZOrderArchive;
class CommandDocumentInsertSheetArchive;
class CommandDocumentRemoveSheetArchive;
class CommandDocumentReplaceLastSheetArchive;
class CommandDocumentReorderSheetArchive;
class CommandSetSheetNameArchive;
class CommandSetPageOrientationArchive;
class CommandSetShowPageNumbersValueArchive;
class CommandSetRepeatingHeadersValueArchive;
class CommandSetContentScaleArchive;
class CommandSetAutofitValueArchive;
class CommandSetDocumentPrinterOptions;
class CommandEnterPrintPreviewModeArchive;
class CommandExitPrintPreviewModeArchive;
class CommandPasteDrawablesArchive;
class CommandPasteSheetArchive;
class CommandReorderSidebarItemChildrenAchive;
class CommandChartMediatorSetEditingState;
class CommandChartMediatorUpdateForEntityDelete;
class ChartCommandSetSeriesNameArchive;
class ChartCommandSelectionBehaviorArchive;

// ===================================================================

class SheetCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  SheetCommandSelectionBehaviorArchive();
  virtual ~SheetCommandSelectionBehaviorArchive();

  SheetCommandSelectionBehaviorArchive(const SheetCommandSelectionBehaviorArchive& from);

  inline SheetCommandSelectionBehaviorArchive& operator=(const SheetCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SheetCommandSelectionBehaviorArchive& default_instance();

  void Swap(SheetCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  SheetCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SheetCommandSelectionBehaviorArchive& from);
  void MergeFrom(const SheetCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference sheet_selection = 1;
  inline bool has_sheet_selection() const;
  inline void clear_sheet_selection();
  static const int kSheetSelectionFieldNumber = 1;
  inline const ::TSP::Reference& sheet_selection() const;
  inline ::TSP::Reference* mutable_sheet_selection();
  inline ::TSP::Reference* release_sheet_selection();
  inline void set_allocated_sheet_selection(::TSP::Reference* sheet_selection);

  // @@protoc_insertion_point(class_scope:TN.SheetCommandSelectionBehaviorArchive)
 private:
  inline void set_has_sheet_selection();
  inline void clear_has_sheet_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_selection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static SheetCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandFormChooseTargetTableArchive : public ::google::protobuf::Message {
 public:
  CommandFormChooseTargetTableArchive();
  virtual ~CommandFormChooseTargetTableArchive();

  CommandFormChooseTargetTableArchive(const CommandFormChooseTargetTableArchive& from);

  inline CommandFormChooseTargetTableArchive& operator=(const CommandFormChooseTargetTableArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandFormChooseTargetTableArchive& default_instance();

  void Swap(CommandFormChooseTargetTableArchive* other);

  // implements Message ----------------------------------------------

  CommandFormChooseTargetTableArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandFormChooseTargetTableArchive& from);
  void MergeFrom(const CommandFormChooseTargetTableArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSCE.CFUUIDArchive table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline const ::TSCE::CFUUIDArchive& table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_table_id();
  inline ::TSCE::CFUUIDArchive* release_table_id();
  inline void set_allocated_table_id(::TSCE::CFUUIDArchive* table_id);

  // optional .TSCE.CFUUIDArchive previous_table_id = 3;
  inline bool has_previous_table_id() const;
  inline void clear_previous_table_id();
  static const int kPreviousTableIdFieldNumber = 3;
  inline const ::TSCE::CFUUIDArchive& previous_table_id() const;
  inline ::TSCE::CFUUIDArchive* mutable_previous_table_id();
  inline ::TSCE::CFUUIDArchive* release_previous_table_id();
  inline void set_allocated_previous_table_id(::TSCE::CFUUIDArchive* previous_table_id);

  // optional string sheet_name = 4;
  inline bool has_sheet_name() const;
  inline void clear_sheet_name();
  static const int kSheetNameFieldNumber = 4;
  inline const ::std::string& sheet_name() const;
  inline void set_sheet_name(const ::std::string& value);
  inline void set_sheet_name(const char* value);
  inline void set_sheet_name(const char* value, size_t size);
  inline ::std::string* mutable_sheet_name();
  inline ::std::string* release_sheet_name();
  inline void set_allocated_sheet_name(::std::string* sheet_name);

  // optional string previous_sheet_name = 5;
  inline bool has_previous_sheet_name() const;
  inline void clear_previous_sheet_name();
  static const int kPreviousSheetNameFieldNumber = 5;
  inline const ::std::string& previous_sheet_name() const;
  inline void set_previous_sheet_name(const ::std::string& value);
  inline void set_previous_sheet_name(const char* value);
  inline void set_previous_sheet_name(const char* value, size_t size);
  inline ::std::string* mutable_previous_sheet_name();
  inline ::std::string* release_previous_sheet_name();
  inline void set_allocated_previous_sheet_name(::std::string* previous_sheet_name);

  // required .TSP.Reference sheet = 6;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 6;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // @@protoc_insertion_point(class_scope:TN.CommandFormChooseTargetTableArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_previous_table_id();
  inline void clear_has_previous_table_id();
  inline void set_has_sheet_name();
  inline void clear_has_sheet_name();
  inline void set_has_previous_sheet_name();
  inline void clear_has_previous_sheet_name();
  inline void set_has_sheet();
  inline void clear_has_sheet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSCE::CFUUIDArchive* table_id_;
  ::TSCE::CFUUIDArchive* previous_table_id_;
  ::std::string* sheet_name_;
  ::std::string* previous_sheet_name_;
  ::TSP::Reference* sheet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandFormChooseTargetTableArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSheetInsertDrawablesArchive : public ::google::protobuf::Message {
 public:
  CommandSheetInsertDrawablesArchive();
  virtual ~CommandSheetInsertDrawablesArchive();

  CommandSheetInsertDrawablesArchive(const CommandSheetInsertDrawablesArchive& from);

  inline CommandSheetInsertDrawablesArchive& operator=(const CommandSheetInsertDrawablesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSheetInsertDrawablesArchive& default_instance();

  void Swap(CommandSheetInsertDrawablesArchive* other);

  // implements Message ----------------------------------------------

  CommandSheetInsertDrawablesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSheetInsertDrawablesArchive& from);
  void MergeFrom(const CommandSheetInsertDrawablesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference sheet = 1;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 1;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // repeated .TSP.Reference drawables = 2;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 2;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional .TSP.Reference provider_undo = 3;
  inline bool has_provider_undo() const;
  inline void clear_provider_undo();
  static const int kProviderUndoFieldNumber = 3;
  inline const ::TSP::Reference& provider_undo() const;
  inline ::TSP::Reference* mutable_provider_undo();
  inline ::TSP::Reference* release_provider_undo();
  inline void set_allocated_provider_undo(::TSP::Reference* provider_undo);

  // required .TSK.CommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool forDrag = 5;
  inline bool has_fordrag() const;
  inline void clear_fordrag();
  static const int kForDragFieldNumber = 5;
  inline bool fordrag() const;
  inline void set_fordrag(bool value);

  // optional bool forPaste = 7;
  inline bool has_forpaste() const;
  inline void clear_forpaste();
  static const int kForPasteFieldNumber = 7;
  inline bool forpaste() const;
  inline void set_forpaste(bool value);

  // optional int32 atIndex = 6;
  inline bool has_atindex() const;
  inline void clear_atindex();
  static const int kAtIndexFieldNumber = 6;
  inline ::google::protobuf::int32 atindex() const;
  inline void set_atindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TN.CommandSheetInsertDrawablesArchive)
 private:
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_provider_undo();
  inline void clear_has_provider_undo();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_fordrag();
  inline void clear_has_fordrag();
  inline void set_has_forpaste();
  inline void clear_has_forpaste();
  inline void set_has_atindex();
  inline void clear_has_atindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  ::TSP::Reference* provider_undo_;
  ::TSK::CommandArchive* super_;
  bool fordrag_;
  bool forpaste_;
  ::google::protobuf::int32 atindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSheetInsertDrawablesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSheetRemoveDrawablesArchive : public ::google::protobuf::Message {
 public:
  CommandSheetRemoveDrawablesArchive();
  virtual ~CommandSheetRemoveDrawablesArchive();

  CommandSheetRemoveDrawablesArchive(const CommandSheetRemoveDrawablesArchive& from);

  inline CommandSheetRemoveDrawablesArchive& operator=(const CommandSheetRemoveDrawablesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSheetRemoveDrawablesArchive& default_instance();

  void Swap(CommandSheetRemoveDrawablesArchive* other);

  // implements Message ----------------------------------------------

  CommandSheetRemoveDrawablesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSheetRemoveDrawablesArchive& from);
  void MergeFrom(const CommandSheetRemoveDrawablesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // repeated .TSP.Reference sortedDrawables = 3;
  inline int sorteddrawables_size() const;
  inline void clear_sorteddrawables();
  static const int kSortedDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& sorteddrawables(int index) const;
  inline ::TSP::Reference* mutable_sorteddrawables(int index);
  inline ::TSP::Reference* add_sorteddrawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      sorteddrawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_sorteddrawables();

  // required .TSP.IndexSet drawableIndices = 4;
  inline bool has_drawableindices() const;
  inline void clear_drawableindices();
  static const int kDrawableIndicesFieldNumber = 4;
  inline const ::TSP::IndexSet& drawableindices() const;
  inline ::TSP::IndexSet* mutable_drawableindices();
  inline ::TSP::IndexSet* release_drawableindices();
  inline void set_allocated_drawableindices(::TSP::IndexSet* drawableindices);

  // repeated .TSP.Reference old_sheet_sidebar_order = 5;
  inline int old_sheet_sidebar_order_size() const;
  inline void clear_old_sheet_sidebar_order();
  static const int kOldSheetSidebarOrderFieldNumber = 5;
  inline const ::TSP::Reference& old_sheet_sidebar_order(int index) const;
  inline ::TSP::Reference* mutable_old_sheet_sidebar_order(int index);
  inline ::TSP::Reference* add_old_sheet_sidebar_order();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_sheet_sidebar_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_sheet_sidebar_order();

  // optional .TSP.Reference formula_rewrite_command_for_undo = 6;
  inline bool has_formula_rewrite_command_for_undo() const;
  inline void clear_formula_rewrite_command_for_undo();
  static const int kFormulaRewriteCommandForUndoFieldNumber = 6;
  inline const ::TSP::Reference& formula_rewrite_command_for_undo() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command_for_undo();
  inline ::TSP::Reference* release_formula_rewrite_command_for_undo();
  inline void set_allocated_formula_rewrite_command_for_undo(::TSP::Reference* formula_rewrite_command_for_undo);

  // @@protoc_insertion_point(class_scope:TN.CommandSheetRemoveDrawablesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_drawableindices();
  inline void clear_has_drawableindices();
  inline void set_has_formula_rewrite_command_for_undo();
  inline void clear_has_formula_rewrite_command_for_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > sorteddrawables_;
  ::TSP::IndexSet* drawableindices_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_sheet_sidebar_order_;
  ::TSP::Reference* formula_rewrite_command_for_undo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSheetRemoveDrawablesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSheetMoveDrawableZOrderArchive : public ::google::protobuf::Message {
 public:
  CommandSheetMoveDrawableZOrderArchive();
  virtual ~CommandSheetMoveDrawableZOrderArchive();

  CommandSheetMoveDrawableZOrderArchive(const CommandSheetMoveDrawableZOrderArchive& from);

  inline CommandSheetMoveDrawableZOrderArchive& operator=(const CommandSheetMoveDrawableZOrderArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSheetMoveDrawableZOrderArchive& default_instance();

  void Swap(CommandSheetMoveDrawableZOrderArchive* other);

  // implements Message ----------------------------------------------

  CommandSheetMoveDrawableZOrderArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSheetMoveDrawableZOrderArchive& from);
  void MergeFrom(const CommandSheetMoveDrawableZOrderArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // repeated .TSP.Reference drawable_infos = 3;
  inline int drawable_infos_size() const;
  inline void clear_drawable_infos();
  static const int kDrawableInfosFieldNumber = 3;
  inline const ::TSP::Reference& drawable_infos(int index) const;
  inline ::TSP::Reference* mutable_drawable_infos(int index);
  inline ::TSP::Reference* add_drawable_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawable_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawable_infos();

  // required .TSP.IndexSet indexes = 4;
  inline bool has_indexes() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 4;
  inline const ::TSP::IndexSet& indexes() const;
  inline ::TSP::IndexSet* mutable_indexes();
  inline ::TSP::IndexSet* release_indexes();
  inline void set_allocated_indexes(::TSP::IndexSet* indexes);

  // @@protoc_insertion_point(class_scope:TN.CommandSheetMoveDrawableZOrderArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_indexes();
  inline void clear_has_indexes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawable_infos_;
  ::TSP::IndexSet* indexes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSheetMoveDrawableZOrderArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDocumentInsertSheetArchive : public ::google::protobuf::Message {
 public:
  CommandDocumentInsertSheetArchive();
  virtual ~CommandDocumentInsertSheetArchive();

  CommandDocumentInsertSheetArchive(const CommandDocumentInsertSheetArchive& from);

  inline CommandDocumentInsertSheetArchive& operator=(const CommandDocumentInsertSheetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDocumentInsertSheetArchive& default_instance();

  void Swap(CommandDocumentInsertSheetArchive* other);

  // implements Message ----------------------------------------------

  CommandDocumentInsertSheetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDocumentInsertSheetArchive& from);
  void MergeFrom(const CommandDocumentInsertSheetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference document = 1;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 1;
  inline const ::TSP::Reference& document() const;
  inline ::TSP::Reference* mutable_document();
  inline ::TSP::Reference* release_document();
  inline void set_allocated_document(::TSP::Reference* document);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandDocumentInsertSheetArchive)
 private:
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* document_;
  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDocumentInsertSheetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDocumentRemoveSheetArchive : public ::google::protobuf::Message {
 public:
  CommandDocumentRemoveSheetArchive();
  virtual ~CommandDocumentRemoveSheetArchive();

  CommandDocumentRemoveSheetArchive(const CommandDocumentRemoveSheetArchive& from);

  inline CommandDocumentRemoveSheetArchive& operator=(const CommandDocumentRemoveSheetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDocumentRemoveSheetArchive& default_instance();

  void Swap(CommandDocumentRemoveSheetArchive* other);

  // implements Message ----------------------------------------------

  CommandDocumentRemoveSheetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDocumentRemoveSheetArchive& from);
  void MergeFrom(const CommandDocumentRemoveSheetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference document = 1;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 1;
  inline const ::TSP::Reference& document() const;
  inline ::TSP::Reference* mutable_document();
  inline ::TSP::Reference* release_document();
  inline void set_allocated_document(::TSP::Reference* document);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // repeated .TSP.Reference old_sheet_sidebar_order = 4;
  inline int old_sheet_sidebar_order_size() const;
  inline void clear_old_sheet_sidebar_order();
  static const int kOldSheetSidebarOrderFieldNumber = 4;
  inline const ::TSP::Reference& old_sheet_sidebar_order(int index) const;
  inline ::TSP::Reference* mutable_old_sheet_sidebar_order(int index);
  inline ::TSP::Reference* add_old_sheet_sidebar_order();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_sheet_sidebar_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_sheet_sidebar_order();

  // required .TSK.CommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference formula_rewrite_command_for_undo = 6;
  inline bool has_formula_rewrite_command_for_undo() const;
  inline void clear_formula_rewrite_command_for_undo();
  static const int kFormulaRewriteCommandForUndoFieldNumber = 6;
  inline const ::TSP::Reference& formula_rewrite_command_for_undo() const;
  inline ::TSP::Reference* mutable_formula_rewrite_command_for_undo();
  inline ::TSP::Reference* release_formula_rewrite_command_for_undo();
  inline void set_allocated_formula_rewrite_command_for_undo(::TSP::Reference* formula_rewrite_command_for_undo);

  // @@protoc_insertion_point(class_scope:TN.CommandDocumentRemoveSheetArchive)
 private:
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_formula_rewrite_command_for_undo();
  inline void clear_has_formula_rewrite_command_for_undo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* document_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_sheet_sidebar_order_;
  ::TSK::CommandArchive* super_;
  ::TSP::Reference* formula_rewrite_command_for_undo_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDocumentRemoveSheetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDocumentReplaceLastSheetArchive : public ::google::protobuf::Message {
 public:
  CommandDocumentReplaceLastSheetArchive();
  virtual ~CommandDocumentReplaceLastSheetArchive();

  CommandDocumentReplaceLastSheetArchive(const CommandDocumentReplaceLastSheetArchive& from);

  inline CommandDocumentReplaceLastSheetArchive& operator=(const CommandDocumentReplaceLastSheetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDocumentReplaceLastSheetArchive& default_instance();

  void Swap(CommandDocumentReplaceLastSheetArchive* other);

  // implements Message ----------------------------------------------

  CommandDocumentReplaceLastSheetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDocumentReplaceLastSheetArchive& from);
  void MergeFrom(const CommandDocumentReplaceLastSheetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference document = 1;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 1;
  inline const ::TSP::Reference& document() const;
  inline ::TSP::Reference* mutable_document();
  inline ::TSP::Reference* release_document();
  inline void set_allocated_document(::TSP::Reference* document);

  // required .TSP.Reference last_sheet = 2;
  inline bool has_last_sheet() const;
  inline void clear_last_sheet();
  static const int kLastSheetFieldNumber = 2;
  inline const ::TSP::Reference& last_sheet() const;
  inline ::TSP::Reference* mutable_last_sheet();
  inline ::TSP::Reference* release_last_sheet();
  inline void set_allocated_last_sheet(::TSP::Reference* last_sheet);

  // required .TSP.Reference new_sheet = 3;
  inline bool has_new_sheet() const;
  inline void clear_new_sheet();
  static const int kNewSheetFieldNumber = 3;
  inline const ::TSP::Reference& new_sheet() const;
  inline ::TSP::Reference* mutable_new_sheet();
  inline ::TSP::Reference* release_new_sheet();
  inline void set_allocated_new_sheet(::TSP::Reference* new_sheet);

  // required .TSK.CommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TN.CommandDocumentReplaceLastSheetArchive)
 private:
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_last_sheet();
  inline void clear_has_last_sheet();
  inline void set_has_new_sheet();
  inline void clear_has_new_sheet();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* document_;
  ::TSP::Reference* last_sheet_;
  ::TSP::Reference* new_sheet_;
  ::TSK::CommandArchive* super_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDocumentReplaceLastSheetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandDocumentReorderSheetArchive : public ::google::protobuf::Message {
 public:
  CommandDocumentReorderSheetArchive();
  virtual ~CommandDocumentReorderSheetArchive();

  CommandDocumentReorderSheetArchive(const CommandDocumentReorderSheetArchive& from);

  inline CommandDocumentReorderSheetArchive& operator=(const CommandDocumentReorderSheetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandDocumentReorderSheetArchive& default_instance();

  void Swap(CommandDocumentReorderSheetArchive* other);

  // implements Message ----------------------------------------------

  CommandDocumentReorderSheetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandDocumentReorderSheetArchive& from);
  void MergeFrom(const CommandDocumentReorderSheetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference document = 1;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 1;
  inline const ::TSP::Reference& document() const;
  inline ::TSP::Reference* mutable_document();
  inline ::TSP::Reference* release_document();
  inline void set_allocated_document(::TSP::Reference* document);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required uint32 source_index = 3;
  inline bool has_source_index() const;
  inline void clear_source_index();
  static const int kSourceIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 source_index() const;
  inline void set_source_index(::google::protobuf::uint32 value);

  // required uint32 dest_index = 4;
  inline bool has_dest_index() const;
  inline void clear_dest_index();
  static const int kDestIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 dest_index() const;
  inline void set_dest_index(::google::protobuf::uint32 value);

  // required .TSK.CommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandDocumentReorderSheetArchive)
 private:
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_source_index();
  inline void clear_has_source_index();
  inline void set_has_dest_index();
  inline void clear_has_dest_index();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* document_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::uint32 source_index_;
  ::google::protobuf::uint32 dest_index_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandDocumentReorderSheetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetSheetNameArchive : public ::google::protobuf::Message {
 public:
  CommandSetSheetNameArchive();
  virtual ~CommandSetSheetNameArchive();

  CommandSetSheetNameArchive(const CommandSetSheetNameArchive& from);

  inline CommandSetSheetNameArchive& operator=(const CommandSetSheetNameArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetSheetNameArchive& default_instance();

  void Swap(CommandSetSheetNameArchive* other);

  // implements Message ----------------------------------------------

  CommandSetSheetNameArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetSheetNameArchive& from);
  void MergeFrom(const CommandSetSheetNameArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string newname = 1;
  inline bool has_newname() const;
  inline void clear_newname();
  static const int kNewnameFieldNumber = 1;
  inline const ::std::string& newname() const;
  inline void set_newname(const ::std::string& value);
  inline void set_newname(const char* value);
  inline void set_newname(const char* value, size_t size);
  inline ::std::string* mutable_newname();
  inline ::std::string* release_newname();
  inline void set_allocated_newname(::std::string* newname);

  // required string oldname = 2;
  inline bool has_oldname() const;
  inline void clear_oldname();
  static const int kOldnameFieldNumber = 2;
  inline const ::std::string& oldname() const;
  inline void set_oldname(const ::std::string& value);
  inline void set_oldname(const char* value);
  inline void set_oldname(const char* value, size_t size);
  inline ::std::string* mutable_oldname();
  inline ::std::string* release_oldname();
  inline void set_allocated_oldname(::std::string* oldname);

  // required .TSP.Reference sheet = 3;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 3;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetSheetNameArchive)
 private:
  inline void set_has_newname();
  inline void clear_has_newname();
  inline void set_has_oldname();
  inline void clear_has_oldname();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* newname_;
  ::std::string* oldname_;
  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetSheetNameArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetPageOrientationArchive : public ::google::protobuf::Message {
 public:
  CommandSetPageOrientationArchive();
  virtual ~CommandSetPageOrientationArchive();

  CommandSetPageOrientationArchive(const CommandSetPageOrientationArchive& from);

  inline CommandSetPageOrientationArchive& operator=(const CommandSetPageOrientationArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetPageOrientationArchive& default_instance();

  void Swap(CommandSetPageOrientationArchive* other);

  // implements Message ----------------------------------------------

  CommandSetPageOrientationArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetPageOrientationArchive& from);
  void MergeFrom(const CommandSetPageOrientationArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool in_portrait_page_orientation = 1;
  inline bool has_in_portrait_page_orientation() const;
  inline void clear_in_portrait_page_orientation();
  static const int kInPortraitPageOrientationFieldNumber = 1;
  inline bool in_portrait_page_orientation() const;
  inline void set_in_portrait_page_orientation(bool value);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetPageOrientationArchive)
 private:
  inline void set_has_in_portrait_page_orientation();
  inline void clear_has_in_portrait_page_orientation();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;
  bool in_portrait_page_orientation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetPageOrientationArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetShowPageNumbersValueArchive : public ::google::protobuf::Message {
 public:
  CommandSetShowPageNumbersValueArchive();
  virtual ~CommandSetShowPageNumbersValueArchive();

  CommandSetShowPageNumbersValueArchive(const CommandSetShowPageNumbersValueArchive& from);

  inline CommandSetShowPageNumbersValueArchive& operator=(const CommandSetShowPageNumbersValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetShowPageNumbersValueArchive& default_instance();

  void Swap(CommandSetShowPageNumbersValueArchive* other);

  // implements Message ----------------------------------------------

  CommandSetShowPageNumbersValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetShowPageNumbersValueArchive& from);
  void MergeFrom(const CommandSetShowPageNumbersValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool show_page_numbers = 1;
  inline bool has_show_page_numbers() const;
  inline void clear_show_page_numbers();
  static const int kShowPageNumbersFieldNumber = 1;
  inline bool show_page_numbers() const;
  inline void set_show_page_numbers(bool value);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetShowPageNumbersValueArchive)
 private:
  inline void set_has_show_page_numbers();
  inline void clear_has_show_page_numbers();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;
  bool show_page_numbers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetShowPageNumbersValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetRepeatingHeadersValueArchive : public ::google::protobuf::Message {
 public:
  CommandSetRepeatingHeadersValueArchive();
  virtual ~CommandSetRepeatingHeadersValueArchive();

  CommandSetRepeatingHeadersValueArchive(const CommandSetRepeatingHeadersValueArchive& from);

  inline CommandSetRepeatingHeadersValueArchive& operator=(const CommandSetRepeatingHeadersValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetRepeatingHeadersValueArchive& default_instance();

  void Swap(CommandSetRepeatingHeadersValueArchive* other);

  // implements Message ----------------------------------------------

  CommandSetRepeatingHeadersValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetRepeatingHeadersValueArchive& from);
  void MergeFrom(const CommandSetRepeatingHeadersValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool show_repeating_headers = 1;
  inline bool has_show_repeating_headers() const;
  inline void clear_show_repeating_headers();
  static const int kShowRepeatingHeadersFieldNumber = 1;
  inline bool show_repeating_headers() const;
  inline void set_show_repeating_headers(bool value);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetRepeatingHeadersValueArchive)
 private:
  inline void set_has_show_repeating_headers();
  inline void clear_has_show_repeating_headers();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;
  bool show_repeating_headers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetRepeatingHeadersValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetContentScaleArchive : public ::google::protobuf::Message {
 public:
  CommandSetContentScaleArchive();
  virtual ~CommandSetContentScaleArchive();

  CommandSetContentScaleArchive(const CommandSetContentScaleArchive& from);

  inline CommandSetContentScaleArchive& operator=(const CommandSetContentScaleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetContentScaleArchive& default_instance();

  void Swap(CommandSetContentScaleArchive* other);

  // implements Message ----------------------------------------------

  CommandSetContentScaleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetContentScaleArchive& from);
  void MergeFrom(const CommandSetContentScaleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_autofit_on = 1;
  inline bool has_is_autofit_on() const;
  inline void clear_is_autofit_on();
  static const int kIsAutofitOnFieldNumber = 1;
  inline bool is_autofit_on() const;
  inline void set_is_autofit_on(bool value);

  // required float old_content_scale = 2;
  inline bool has_old_content_scale() const;
  inline void clear_old_content_scale();
  static const int kOldContentScaleFieldNumber = 2;
  inline float old_content_scale() const;
  inline void set_old_content_scale(float value);

  // optional float new_content_scale = 3;
  inline bool has_new_content_scale() const;
  inline void clear_new_content_scale();
  static const int kNewContentScaleFieldNumber = 3;
  inline float new_content_scale() const;
  inline void set_new_content_scale(float value);

  // required .TSP.Reference sheet = 4;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 4;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 5;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 5;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetContentScaleArchive)
 private:
  inline void set_has_is_autofit_on();
  inline void clear_has_is_autofit_on();
  inline void set_has_old_content_scale();
  inline void clear_has_old_content_scale();
  inline void set_has_new_content_scale();
  inline void clear_has_new_content_scale();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_autofit_on_;
  float old_content_scale_;
  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;
  float new_content_scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetContentScaleArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetAutofitValueArchive : public ::google::protobuf::Message {
 public:
  CommandSetAutofitValueArchive();
  virtual ~CommandSetAutofitValueArchive();

  CommandSetAutofitValueArchive(const CommandSetAutofitValueArchive& from);

  inline CommandSetAutofitValueArchive& operator=(const CommandSetAutofitValueArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetAutofitValueArchive& default_instance();

  void Swap(CommandSetAutofitValueArchive* other);

  // implements Message ----------------------------------------------

  CommandSetAutofitValueArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetAutofitValueArchive& from);
  void MergeFrom(const CommandSetAutofitValueArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float old_content_scale = 1;
  inline bool has_old_content_scale() const;
  inline void clear_old_content_scale();
  static const int kOldContentScaleFieldNumber = 1;
  inline float old_content_scale() const;
  inline void set_old_content_scale(float value);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // required .TSK.CommandArchive super = 3;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetAutofitValueArchive)
 private:
  inline void set_has_old_content_scale();
  inline void clear_has_old_content_scale();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* sheet_;
  ::TSK::CommandArchive* super_;
  float old_content_scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetAutofitValueArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSetDocumentPrinterOptions : public ::google::protobuf::Message {
 public:
  CommandSetDocumentPrinterOptions();
  virtual ~CommandSetDocumentPrinterOptions();

  CommandSetDocumentPrinterOptions(const CommandSetDocumentPrinterOptions& from);

  inline CommandSetDocumentPrinterOptions& operator=(const CommandSetDocumentPrinterOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSetDocumentPrinterOptions& default_instance();

  void Swap(CommandSetDocumentPrinterOptions* other);

  // implements Message ----------------------------------------------

  CommandSetDocumentPrinterOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSetDocumentPrinterOptions& from);
  void MergeFrom(const CommandSetDocumentPrinterOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string printer_id = 1;
  inline bool has_printer_id() const;
  inline void clear_printer_id();
  static const int kPrinterIdFieldNumber = 1;
  inline const ::std::string& printer_id() const;
  inline void set_printer_id(const ::std::string& value);
  inline void set_printer_id(const char* value);
  inline void set_printer_id(const char* value, size_t size);
  inline ::std::string* mutable_printer_id();
  inline ::std::string* release_printer_id();
  inline void set_allocated_printer_id(::std::string* printer_id);

  // required string paper_id = 2;
  inline bool has_paper_id() const;
  inline void clear_paper_id();
  static const int kPaperIdFieldNumber = 2;
  inline const ::std::string& paper_id() const;
  inline void set_paper_id(const ::std::string& value);
  inline void set_paper_id(const char* value);
  inline void set_paper_id(const char* value, size_t size);
  inline ::std::string* mutable_paper_id();
  inline ::std::string* release_paper_id();
  inline void set_allocated_paper_id(::std::string* paper_id);

  // required .TSP.Size page_size = 3;
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 3;
  inline const ::TSP::Size& page_size() const;
  inline ::TSP::Size* mutable_page_size();
  inline ::TSP::Size* release_page_size();
  inline void set_allocated_page_size(::TSP::Size* page_size);

  // required .TSK.CommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandSetDocumentPrinterOptions)
 private:
  inline void set_has_printer_id();
  inline void clear_has_printer_id();
  inline void set_has_paper_id();
  inline void clear_has_paper_id();
  inline void set_has_page_size();
  inline void clear_has_page_size();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* printer_id_;
  ::std::string* paper_id_;
  ::TSP::Size* page_size_;
  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSetDocumentPrinterOptions* default_instance_;
};
// -------------------------------------------------------------------

class CommandEnterPrintPreviewModeArchive : public ::google::protobuf::Message {
 public:
  CommandEnterPrintPreviewModeArchive();
  virtual ~CommandEnterPrintPreviewModeArchive();

  CommandEnterPrintPreviewModeArchive(const CommandEnterPrintPreviewModeArchive& from);

  inline CommandEnterPrintPreviewModeArchive& operator=(const CommandEnterPrintPreviewModeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandEnterPrintPreviewModeArchive& default_instance();

  void Swap(CommandEnterPrintPreviewModeArchive* other);

  // implements Message ----------------------------------------------

  CommandEnterPrintPreviewModeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandEnterPrintPreviewModeArchive& from);
  void MergeFrom(const CommandEnterPrintPreviewModeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandEnterPrintPreviewModeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandEnterPrintPreviewModeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandExitPrintPreviewModeArchive : public ::google::protobuf::Message {
 public:
  CommandExitPrintPreviewModeArchive();
  virtual ~CommandExitPrintPreviewModeArchive();

  CommandExitPrintPreviewModeArchive(const CommandExitPrintPreviewModeArchive& from);

  inline CommandExitPrintPreviewModeArchive& operator=(const CommandExitPrintPreviewModeArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandExitPrintPreviewModeArchive& default_instance();

  void Swap(CommandExitPrintPreviewModeArchive* other);

  // implements Message ----------------------------------------------

  CommandExitPrintPreviewModeArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandExitPrintPreviewModeArchive& from);
  void MergeFrom(const CommandExitPrintPreviewModeArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TN.CommandExitPrintPreviewModeArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandExitPrintPreviewModeArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandPasteDrawablesArchive : public ::google::protobuf::Message {
 public:
  CommandPasteDrawablesArchive();
  virtual ~CommandPasteDrawablesArchive();

  CommandPasteDrawablesArchive(const CommandPasteDrawablesArchive& from);

  inline CommandPasteDrawablesArchive& operator=(const CommandPasteDrawablesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPasteDrawablesArchive& default_instance();

  void Swap(CommandPasteDrawablesArchive* other);

  // implements Message ----------------------------------------------

  CommandPasteDrawablesArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPasteDrawablesArchive& from);
  void MergeFrom(const CommandPasteDrawablesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // repeated .TSP.Reference drawables = 3;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // @@protoc_insertion_point(class_scope:TN.CommandPasteDrawablesArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sheet();
  inline void clear_has_sheet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandPasteDrawablesArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandPasteSheetArchive : public ::google::protobuf::Message {
 public:
  CommandPasteSheetArchive();
  virtual ~CommandPasteSheetArchive();

  CommandPasteSheetArchive(const CommandPasteSheetArchive& from);

  inline CommandPasteSheetArchive& operator=(const CommandPasteSheetArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandPasteSheetArchive& default_instance();

  void Swap(CommandPasteSheetArchive* other);

  // implements Message ----------------------------------------------

  CommandPasteSheetArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandPasteSheetArchive& from);
  void MergeFrom(const CommandPasteSheetArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference document = 2;
  inline bool has_document() const;
  inline void clear_document();
  static const int kDocumentFieldNumber = 2;
  inline const ::TSP::Reference& document() const;
  inline ::TSP::Reference* mutable_document();
  inline ::TSP::Reference* release_document();
  inline void set_allocated_document(::TSP::Reference* document);

  // required .TSP.Reference sheet = 3;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 3;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // optional .TN.SheetUIStateArchive sheet_uistate = 4;
  inline bool has_sheet_uistate() const;
  inline void clear_sheet_uistate();
  static const int kSheetUistateFieldNumber = 4;
  inline const ::TN::SheetUIStateArchive& sheet_uistate() const;
  inline ::TN::SheetUIStateArchive* mutable_sheet_uistate();
  inline ::TN::SheetUIStateArchive* release_sheet_uistate();
  inline void set_allocated_sheet_uistate(::TN::SheetUIStateArchive* sheet_uistate);

  // required uint32 sheetIndex = 5;
  inline bool has_sheetindex() const;
  inline void clear_sheetindex();
  static const int kSheetIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 sheetindex() const;
  inline void set_sheetindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TN.CommandPasteSheetArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_document();
  inline void clear_has_document();
  inline void set_has_sheet();
  inline void clear_has_sheet();
  inline void set_has_sheet_uistate();
  inline void clear_has_sheet_uistate();
  inline void set_has_sheetindex();
  inline void clear_has_sheetindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* document_;
  ::TSP::Reference* sheet_;
  ::TN::SheetUIStateArchive* sheet_uistate_;
  ::google::protobuf::uint32 sheetindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandPasteSheetArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandReorderSidebarItemChildrenAchive : public ::google::protobuf::Message {
 public:
  CommandReorderSidebarItemChildrenAchive();
  virtual ~CommandReorderSidebarItemChildrenAchive();

  CommandReorderSidebarItemChildrenAchive(const CommandReorderSidebarItemChildrenAchive& from);

  inline CommandReorderSidebarItemChildrenAchive& operator=(const CommandReorderSidebarItemChildrenAchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandReorderSidebarItemChildrenAchive& default_instance();

  void Swap(CommandReorderSidebarItemChildrenAchive* other);

  // implements Message ----------------------------------------------

  CommandReorderSidebarItemChildrenAchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandReorderSidebarItemChildrenAchive& from);
  void MergeFrom(const CommandReorderSidebarItemChildrenAchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // required .TSP.Reference sheet = 2;
  inline bool has_sheet() const;
  inline void clear_sheet();
  static const int kSheetFieldNumber = 2;
  inline const ::TSP::Reference& sheet() const;
  inline ::TSP::Reference* mutable_sheet();
  inline ::TSP::Reference* release_sheet();
  inline void set_allocated_sheet(::TSP::Reference* sheet);

  // repeated .TSP.Reference old_children = 3;
  inline int old_children_size() const;
  inline void clear_old_children();
  static const int kOldChildrenFieldNumber = 3;
  inline const ::TSP::Reference& old_children(int index) const;
  inline ::TSP::Reference* mutable_old_children(int index);
  inline ::TSP::Reference* add_old_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      old_children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_old_children();

  // repeated .TSP.Reference new_children = 4;
  inline int new_children_size() const;
  inline void clear_new_children();
  static const int kNewChildrenFieldNumber = 4;
  inline const ::TSP::Reference& new_children(int index) const;
  inline ::TSP::Reference* mutable_new_children(int index);
  inline ::TSP::Reference* add_new_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      new_children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_new_children();

  // @@protoc_insertion_point(class_scope:TN.CommandReorderSidebarItemChildrenAchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_sheet();
  inline void clear_has_sheet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* sheet_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > old_children_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > new_children_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandReorderSidebarItemChildrenAchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandChartMediatorSetEditingState : public ::google::protobuf::Message {
 public:
  CommandChartMediatorSetEditingState();
  virtual ~CommandChartMediatorSetEditingState();

  CommandChartMediatorSetEditingState(const CommandChartMediatorSetEditingState& from);

  inline CommandChartMediatorSetEditingState& operator=(const CommandChartMediatorSetEditingState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandChartMediatorSetEditingState& default_instance();

  void Swap(CommandChartMediatorSetEditingState* other);

  // implements Message ----------------------------------------------

  CommandChartMediatorSetEditingState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandChartMediatorSetEditingState& from);
  void MergeFrom(const CommandChartMediatorSetEditingState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCH.ChartCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSCH::ChartCommandArchive& super() const;
  inline ::TSCH::ChartCommandArchive* mutable_super();
  inline ::TSCH::ChartCommandArchive* release_super();
  inline void set_allocated_super(::TSCH::ChartCommandArchive* super);

  // optional .TN.ChartMediatorFormulaStorage old_formulas = 3;
  inline bool has_old_formulas() const;
  inline void clear_old_formulas();
  static const int kOldFormulasFieldNumber = 3;
  inline const ::TN::ChartMediatorFormulaStorage& old_formulas() const;
  inline ::TN::ChartMediatorFormulaStorage* mutable_old_formulas();
  inline ::TN::ChartMediatorFormulaStorage* release_old_formulas();
  inline void set_allocated_old_formulas(::TN::ChartMediatorFormulaStorage* old_formulas);

  // optional .TN.ChartMediatorFormulaStorage new_formulas = 4;
  inline bool has_new_formulas() const;
  inline void clear_new_formulas();
  static const int kNewFormulasFieldNumber = 4;
  inline const ::TN::ChartMediatorFormulaStorage& new_formulas() const;
  inline ::TN::ChartMediatorFormulaStorage* mutable_new_formulas();
  inline ::TN::ChartMediatorFormulaStorage* release_new_formulas();
  inline void set_allocated_new_formulas(::TN::ChartMediatorFormulaStorage* new_formulas);

  // optional int32 old_direction = 5;
  inline bool has_old_direction() const;
  inline void clear_old_direction();
  static const int kOldDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 old_direction() const;
  inline void set_old_direction(::google::protobuf::int32 value);

  // optional int32 new_direction = 6;
  inline bool has_new_direction() const;
  inline void clear_new_direction();
  static const int kNewDirectionFieldNumber = 6;
  inline ::google::protobuf::int32 new_direction() const;
  inline void set_new_direction(::google::protobuf::int32 value);

  // optional int32 old_scatter_format = 7;
  inline bool has_old_scatter_format() const;
  inline void clear_old_scatter_format();
  static const int kOldScatterFormatFieldNumber = 7;
  inline ::google::protobuf::int32 old_scatter_format() const;
  inline void set_old_scatter_format(::google::protobuf::int32 value);

  // optional int32 new_scatter_format = 8;
  inline bool has_new_scatter_format() const;
  inline void clear_new_scatter_format();
  static const int kNewScatterFormatFieldNumber = 8;
  inline ::google::protobuf::int32 new_scatter_format() const;
  inline void set_new_scatter_format(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TN.CommandChartMediatorSetEditingState)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_formulas();
  inline void clear_has_old_formulas();
  inline void set_has_new_formulas();
  inline void clear_has_new_formulas();
  inline void set_has_old_direction();
  inline void clear_has_old_direction();
  inline void set_has_new_direction();
  inline void clear_has_new_direction();
  inline void set_has_old_scatter_format();
  inline void clear_has_old_scatter_format();
  inline void set_has_new_scatter_format();
  inline void clear_has_new_scatter_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCH::ChartCommandArchive* super_;
  ::TN::ChartMediatorFormulaStorage* old_formulas_;
  ::TN::ChartMediatorFormulaStorage* new_formulas_;
  ::google::protobuf::int32 old_direction_;
  ::google::protobuf::int32 new_direction_;
  ::google::protobuf::int32 old_scatter_format_;
  ::google::protobuf::int32 new_scatter_format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandChartMediatorSetEditingState* default_instance_;
};
// -------------------------------------------------------------------

class CommandChartMediatorUpdateForEntityDelete : public ::google::protobuf::Message {
 public:
  CommandChartMediatorUpdateForEntityDelete();
  virtual ~CommandChartMediatorUpdateForEntityDelete();

  CommandChartMediatorUpdateForEntityDelete(const CommandChartMediatorUpdateForEntityDelete& from);

  inline CommandChartMediatorUpdateForEntityDelete& operator=(const CommandChartMediatorUpdateForEntityDelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandChartMediatorUpdateForEntityDelete& default_instance();

  void Swap(CommandChartMediatorUpdateForEntityDelete* other);

  // implements Message ----------------------------------------------

  CommandChartMediatorUpdateForEntityDelete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandChartMediatorUpdateForEntityDelete& from);
  void MergeFrom(const CommandChartMediatorUpdateForEntityDelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCH.ChartCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSCH::ChartCommandArchive& super() const;
  inline ::TSCH::ChartCommandArchive* mutable_super();
  inline ::TSCH::ChartCommandArchive* release_super();
  inline void set_allocated_super(::TSCH::ChartCommandArchive* super);

  // optional .TSP.Reference cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::TSP::Reference& cmd() const;
  inline ::TSP::Reference* mutable_cmd();
  inline ::TSP::Reference* release_cmd();
  inline void set_allocated_cmd(::TSP::Reference* cmd);

  // @@protoc_insertion_point(class_scope:TN.CommandChartMediatorUpdateForEntityDelete)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCH::ChartCommandArchive* super_;
  ::TSP::Reference* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandChartMediatorUpdateForEntityDelete* default_instance_;
};
// -------------------------------------------------------------------

class ChartCommandSetSeriesNameArchive : public ::google::protobuf::Message {
 public:
  ChartCommandSetSeriesNameArchive();
  virtual ~ChartCommandSetSeriesNameArchive();

  ChartCommandSetSeriesNameArchive(const ChartCommandSetSeriesNameArchive& from);

  inline ChartCommandSetSeriesNameArchive& operator=(const ChartCommandSetSeriesNameArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartCommandSetSeriesNameArchive& default_instance();

  void Swap(ChartCommandSetSeriesNameArchive* other);

  // implements Message ----------------------------------------------

  ChartCommandSetSeriesNameArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartCommandSetSeriesNameArchive& from);
  void MergeFrom(const ChartCommandSetSeriesNameArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSCH.ChartCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSCH::ChartCommandArchive& super() const;
  inline ::TSCH::ChartCommandArchive* mutable_super();
  inline ::TSCH::ChartCommandArchive* release_super();
  inline void set_allocated_super(::TSCH::ChartCommandArchive* super);

  // required .TSP.Reference mediator = 2;
  inline bool has_mediator() const;
  inline void clear_mediator();
  static const int kMediatorFieldNumber = 2;
  inline const ::TSP::Reference& mediator() const;
  inline ::TSP::Reference* mutable_mediator();
  inline ::TSP::Reference* release_mediator();
  inline void set_allocated_mediator(::TSP::Reference* mediator);

  // required uint32 seriesindex = 3;
  inline bool has_seriesindex() const;
  inline void clear_seriesindex();
  static const int kSeriesindexFieldNumber = 3;
  inline ::google::protobuf::uint32 seriesindex() const;
  inline void set_seriesindex(::google::protobuf::uint32 value);

  // optional .TSCE.FormulaArchive old_formula = 4;
  inline bool has_old_formula() const;
  inline void clear_old_formula();
  static const int kOldFormulaFieldNumber = 4;
  inline const ::TSCE::FormulaArchive& old_formula() const;
  inline ::TSCE::FormulaArchive* mutable_old_formula();
  inline ::TSCE::FormulaArchive* release_old_formula();
  inline void set_allocated_old_formula(::TSCE::FormulaArchive* old_formula);

  // optional .TSCE.FormulaArchive new_formula = 5;
  inline bool has_new_formula() const;
  inline void clear_new_formula();
  static const int kNewFormulaFieldNumber = 5;
  inline const ::TSCE::FormulaArchive& new_formula() const;
  inline ::TSCE::FormulaArchive* mutable_new_formula();
  inline ::TSCE::FormulaArchive* release_new_formula();
  inline void set_allocated_new_formula(::TSCE::FormulaArchive* new_formula);

  // @@protoc_insertion_point(class_scope:TN.ChartCommandSetSeriesNameArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_mediator();
  inline void clear_has_mediator();
  inline void set_has_seriesindex();
  inline void clear_has_seriesindex();
  inline void set_has_old_formula();
  inline void clear_has_old_formula();
  inline void set_has_new_formula();
  inline void clear_has_new_formula();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSCH::ChartCommandArchive* super_;
  ::TSP::Reference* mediator_;
  ::TSCE::FormulaArchive* old_formula_;
  ::TSCE::FormulaArchive* new_formula_;
  ::google::protobuf::uint32 seriesindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChartCommandSetSeriesNameArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  ChartCommandSelectionBehaviorArchive();
  virtual ~ChartCommandSelectionBehaviorArchive();

  ChartCommandSelectionBehaviorArchive(const ChartCommandSelectionBehaviorArchive& from);

  inline ChartCommandSelectionBehaviorArchive& operator=(const ChartCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartCommandSelectionBehaviorArchive& default_instance();

  void Swap(ChartCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  ChartCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartCommandSelectionBehaviorArchive& from);
  void MergeFrom(const ChartCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference drawable_info = 1;
  inline bool has_drawable_info() const;
  inline void clear_drawable_info();
  static const int kDrawableInfoFieldNumber = 1;
  inline const ::TSP::Reference& drawable_info() const;
  inline ::TSP::Reference* mutable_drawable_info();
  inline ::TSP::Reference* release_drawable_info();
  inline void set_allocated_drawable_info(::TSP::Reference* drawable_info);

  // optional .TN.ChartSelectionArchive begin_selection = 2;
  inline bool has_begin_selection() const;
  inline void clear_begin_selection();
  static const int kBeginSelectionFieldNumber = 2;
  inline const ::TN::ChartSelectionArchive& begin_selection() const;
  inline ::TN::ChartSelectionArchive* mutable_begin_selection();
  inline ::TN::ChartSelectionArchive* release_begin_selection();
  inline void set_allocated_begin_selection(::TN::ChartSelectionArchive* begin_selection);

  // optional .TN.ChartSelectionArchive end_selection = 3;
  inline bool has_end_selection() const;
  inline void clear_end_selection();
  static const int kEndSelectionFieldNumber = 3;
  inline const ::TN::ChartSelectionArchive& end_selection() const;
  inline ::TN::ChartSelectionArchive* mutable_end_selection();
  inline ::TN::ChartSelectionArchive* release_end_selection();
  inline void set_allocated_end_selection(::TN::ChartSelectionArchive* end_selection);

  // @@protoc_insertion_point(class_scope:TN.ChartCommandSelectionBehaviorArchive)
 private:
  inline void set_has_drawable_info();
  inline void clear_has_drawable_info();
  inline void set_has_begin_selection();
  inline void clear_has_begin_selection();
  inline void set_has_end_selection();
  inline void clear_has_end_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_info_;
  ::TN::ChartSelectionArchive* begin_selection_;
  ::TN::ChartSelectionArchive* end_selection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TNCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TNCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TNCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChartCommandSelectionBehaviorArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// SheetCommandSelectionBehaviorArchive

// optional .TSP.Reference sheet_selection = 1;
inline bool SheetCommandSelectionBehaviorArchive::has_sheet_selection() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SheetCommandSelectionBehaviorArchive::set_has_sheet_selection() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SheetCommandSelectionBehaviorArchive::clear_has_sheet_selection() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SheetCommandSelectionBehaviorArchive::clear_sheet_selection() {
  if (sheet_selection_ != NULL) sheet_selection_->::TSP::Reference::Clear();
  clear_has_sheet_selection();
}
inline const ::TSP::Reference& SheetCommandSelectionBehaviorArchive::sheet_selection() const {
  return sheet_selection_ != NULL ? *sheet_selection_ : *default_instance_->sheet_selection_;
}
inline ::TSP::Reference* SheetCommandSelectionBehaviorArchive::mutable_sheet_selection() {
  set_has_sheet_selection();
  if (sheet_selection_ == NULL) sheet_selection_ = new ::TSP::Reference;
  return sheet_selection_;
}
inline ::TSP::Reference* SheetCommandSelectionBehaviorArchive::release_sheet_selection() {
  clear_has_sheet_selection();
  ::TSP::Reference* temp = sheet_selection_;
  sheet_selection_ = NULL;
  return temp;
}
inline void SheetCommandSelectionBehaviorArchive::set_allocated_sheet_selection(::TSP::Reference* sheet_selection) {
  delete sheet_selection_;
  sheet_selection_ = sheet_selection;
  if (sheet_selection) {
    set_has_sheet_selection();
  } else {
    clear_has_sheet_selection();
  }
}

// -------------------------------------------------------------------

// CommandFormChooseTargetTableArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandFormChooseTargetTableArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandFormChooseTargetTableArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandFormChooseTargetTableArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandFormChooseTargetTableArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandFormChooseTargetTableArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandFormChooseTargetTableArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSCE.CFUUIDArchive table_id = 2;
inline bool CommandFormChooseTargetTableArchive::has_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandFormChooseTargetTableArchive::clear_table_id() {
  if (table_id_ != NULL) table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandFormChooseTargetTableArchive::table_id() const {
  return table_id_ != NULL ? *table_id_ : *default_instance_->table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandFormChooseTargetTableArchive::mutable_table_id() {
  set_has_table_id();
  if (table_id_ == NULL) table_id_ = new ::TSCE::CFUUIDArchive;
  return table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandFormChooseTargetTableArchive::release_table_id() {
  clear_has_table_id();
  ::TSCE::CFUUIDArchive* temp = table_id_;
  table_id_ = NULL;
  return temp;
}
inline void CommandFormChooseTargetTableArchive::set_allocated_table_id(::TSCE::CFUUIDArchive* table_id) {
  delete table_id_;
  table_id_ = table_id;
  if (table_id) {
    set_has_table_id();
  } else {
    clear_has_table_id();
  }
}

// optional .TSCE.CFUUIDArchive previous_table_id = 3;
inline bool CommandFormChooseTargetTableArchive::has_previous_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_previous_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_previous_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandFormChooseTargetTableArchive::clear_previous_table_id() {
  if (previous_table_id_ != NULL) previous_table_id_->::TSCE::CFUUIDArchive::Clear();
  clear_has_previous_table_id();
}
inline const ::TSCE::CFUUIDArchive& CommandFormChooseTargetTableArchive::previous_table_id() const {
  return previous_table_id_ != NULL ? *previous_table_id_ : *default_instance_->previous_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandFormChooseTargetTableArchive::mutable_previous_table_id() {
  set_has_previous_table_id();
  if (previous_table_id_ == NULL) previous_table_id_ = new ::TSCE::CFUUIDArchive;
  return previous_table_id_;
}
inline ::TSCE::CFUUIDArchive* CommandFormChooseTargetTableArchive::release_previous_table_id() {
  clear_has_previous_table_id();
  ::TSCE::CFUUIDArchive* temp = previous_table_id_;
  previous_table_id_ = NULL;
  return temp;
}
inline void CommandFormChooseTargetTableArchive::set_allocated_previous_table_id(::TSCE::CFUUIDArchive* previous_table_id) {
  delete previous_table_id_;
  previous_table_id_ = previous_table_id;
  if (previous_table_id) {
    set_has_previous_table_id();
  } else {
    clear_has_previous_table_id();
  }
}

// optional string sheet_name = 4;
inline bool CommandFormChooseTargetTableArchive::has_sheet_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_sheet_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_sheet_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandFormChooseTargetTableArchive::clear_sheet_name() {
  if (sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    sheet_name_->clear();
  }
  clear_has_sheet_name();
}
inline const ::std::string& CommandFormChooseTargetTableArchive::sheet_name() const {
  return *sheet_name_;
}
inline void CommandFormChooseTargetTableArchive::set_sheet_name(const ::std::string& value) {
  set_has_sheet_name();
  if (sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    sheet_name_ = new ::std::string;
  }
  sheet_name_->assign(value);
}
inline void CommandFormChooseTargetTableArchive::set_sheet_name(const char* value) {
  set_has_sheet_name();
  if (sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    sheet_name_ = new ::std::string;
  }
  sheet_name_->assign(value);
}
inline void CommandFormChooseTargetTableArchive::set_sheet_name(const char* value, size_t size) {
  set_has_sheet_name();
  if (sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    sheet_name_ = new ::std::string;
  }
  sheet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandFormChooseTargetTableArchive::mutable_sheet_name() {
  set_has_sheet_name();
  if (sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    sheet_name_ = new ::std::string;
  }
  return sheet_name_;
}
inline ::std::string* CommandFormChooseTargetTableArchive::release_sheet_name() {
  clear_has_sheet_name();
  if (sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sheet_name_;
    sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandFormChooseTargetTableArchive::set_allocated_sheet_name(::std::string* sheet_name) {
  if (sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sheet_name_;
  }
  if (sheet_name) {
    set_has_sheet_name();
    sheet_name_ = sheet_name;
  } else {
    clear_has_sheet_name();
    sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string previous_sheet_name = 5;
inline bool CommandFormChooseTargetTableArchive::has_previous_sheet_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_previous_sheet_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_previous_sheet_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandFormChooseTargetTableArchive::clear_previous_sheet_name() {
  if (previous_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    previous_sheet_name_->clear();
  }
  clear_has_previous_sheet_name();
}
inline const ::std::string& CommandFormChooseTargetTableArchive::previous_sheet_name() const {
  return *previous_sheet_name_;
}
inline void CommandFormChooseTargetTableArchive::set_previous_sheet_name(const ::std::string& value) {
  set_has_previous_sheet_name();
  if (previous_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    previous_sheet_name_ = new ::std::string;
  }
  previous_sheet_name_->assign(value);
}
inline void CommandFormChooseTargetTableArchive::set_previous_sheet_name(const char* value) {
  set_has_previous_sheet_name();
  if (previous_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    previous_sheet_name_ = new ::std::string;
  }
  previous_sheet_name_->assign(value);
}
inline void CommandFormChooseTargetTableArchive::set_previous_sheet_name(const char* value, size_t size) {
  set_has_previous_sheet_name();
  if (previous_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    previous_sheet_name_ = new ::std::string;
  }
  previous_sheet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandFormChooseTargetTableArchive::mutable_previous_sheet_name() {
  set_has_previous_sheet_name();
  if (previous_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    previous_sheet_name_ = new ::std::string;
  }
  return previous_sheet_name_;
}
inline ::std::string* CommandFormChooseTargetTableArchive::release_previous_sheet_name() {
  clear_has_previous_sheet_name();
  if (previous_sheet_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previous_sheet_name_;
    previous_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandFormChooseTargetTableArchive::set_allocated_previous_sheet_name(::std::string* previous_sheet_name) {
  if (previous_sheet_name_ != &::google::protobuf::internal::kEmptyString) {
    delete previous_sheet_name_;
  }
  if (previous_sheet_name) {
    set_has_previous_sheet_name();
    previous_sheet_name_ = previous_sheet_name;
  } else {
    clear_has_previous_sheet_name();
    previous_sheet_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Reference sheet = 6;
inline bool CommandFormChooseTargetTableArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandFormChooseTargetTableArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandFormChooseTargetTableArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandFormChooseTargetTableArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandFormChooseTargetTableArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandFormChooseTargetTableArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandFormChooseTargetTableArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandFormChooseTargetTableArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// -------------------------------------------------------------------

// CommandSheetInsertDrawablesArchive

// required .TSP.Reference sheet = 1;
inline bool CommandSheetInsertDrawablesArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSheetInsertDrawablesArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSheetInsertDrawablesArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSheetInsertDrawablesArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// repeated .TSP.Reference drawables = 2;
inline int CommandSheetInsertDrawablesArchive::drawables_size() const {
  return drawables_.size();
}
inline void CommandSheetInsertDrawablesArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& CommandSheetInsertDrawablesArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSheetInsertDrawablesArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSheetInsertDrawablesArchive::mutable_drawables() {
  return &drawables_;
}

// optional .TSP.Reference provider_undo = 3;
inline bool CommandSheetInsertDrawablesArchive::has_provider_undo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_provider_undo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_provider_undo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSheetInsertDrawablesArchive::clear_provider_undo() {
  if (provider_undo_ != NULL) provider_undo_->::TSP::Reference::Clear();
  clear_has_provider_undo();
}
inline const ::TSP::Reference& CommandSheetInsertDrawablesArchive::provider_undo() const {
  return provider_undo_ != NULL ? *provider_undo_ : *default_instance_->provider_undo_;
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::mutable_provider_undo() {
  set_has_provider_undo();
  if (provider_undo_ == NULL) provider_undo_ = new ::TSP::Reference;
  return provider_undo_;
}
inline ::TSP::Reference* CommandSheetInsertDrawablesArchive::release_provider_undo() {
  clear_has_provider_undo();
  ::TSP::Reference* temp = provider_undo_;
  provider_undo_ = NULL;
  return temp;
}
inline void CommandSheetInsertDrawablesArchive::set_allocated_provider_undo(::TSP::Reference* provider_undo) {
  delete provider_undo_;
  provider_undo_ = provider_undo;
  if (provider_undo) {
    set_has_provider_undo();
  } else {
    clear_has_provider_undo();
  }
}

// required .TSK.CommandArchive super = 4;
inline bool CommandSheetInsertDrawablesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSheetInsertDrawablesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSheetInsertDrawablesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSheetInsertDrawablesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSheetInsertDrawablesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSheetInsertDrawablesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool forDrag = 5;
inline bool CommandSheetInsertDrawablesArchive::has_fordrag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_fordrag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_fordrag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSheetInsertDrawablesArchive::clear_fordrag() {
  fordrag_ = false;
  clear_has_fordrag();
}
inline bool CommandSheetInsertDrawablesArchive::fordrag() const {
  return fordrag_;
}
inline void CommandSheetInsertDrawablesArchive::set_fordrag(bool value) {
  set_has_fordrag();
  fordrag_ = value;
}

// optional bool forPaste = 7;
inline bool CommandSheetInsertDrawablesArchive::has_forpaste() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_forpaste() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_forpaste() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSheetInsertDrawablesArchive::clear_forpaste() {
  forpaste_ = false;
  clear_has_forpaste();
}
inline bool CommandSheetInsertDrawablesArchive::forpaste() const {
  return forpaste_;
}
inline void CommandSheetInsertDrawablesArchive::set_forpaste(bool value) {
  set_has_forpaste();
  forpaste_ = value;
}

// optional int32 atIndex = 6;
inline bool CommandSheetInsertDrawablesArchive::has_atindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandSheetInsertDrawablesArchive::set_has_atindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandSheetInsertDrawablesArchive::clear_has_atindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandSheetInsertDrawablesArchive::clear_atindex() {
  atindex_ = 0;
  clear_has_atindex();
}
inline ::google::protobuf::int32 CommandSheetInsertDrawablesArchive::atindex() const {
  return atindex_;
}
inline void CommandSheetInsertDrawablesArchive::set_atindex(::google::protobuf::int32 value) {
  set_has_atindex();
  atindex_ = value;
}

// -------------------------------------------------------------------

// CommandSheetRemoveDrawablesArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSheetRemoveDrawablesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSheetRemoveDrawablesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSheetRemoveDrawablesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSheetRemoveDrawablesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSheetRemoveDrawablesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSheetRemoveDrawablesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandSheetRemoveDrawablesArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSheetRemoveDrawablesArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSheetRemoveDrawablesArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSheetRemoveDrawablesArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// repeated .TSP.Reference sortedDrawables = 3;
inline int CommandSheetRemoveDrawablesArchive::sorteddrawables_size() const {
  return sorteddrawables_.size();
}
inline void CommandSheetRemoveDrawablesArchive::clear_sorteddrawables() {
  sorteddrawables_.Clear();
}
inline const ::TSP::Reference& CommandSheetRemoveDrawablesArchive::sorteddrawables(int index) const {
  return sorteddrawables_.Get(index);
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::mutable_sorteddrawables(int index) {
  return sorteddrawables_.Mutable(index);
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::add_sorteddrawables() {
  return sorteddrawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSheetRemoveDrawablesArchive::sorteddrawables() const {
  return sorteddrawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSheetRemoveDrawablesArchive::mutable_sorteddrawables() {
  return &sorteddrawables_;
}

// required .TSP.IndexSet drawableIndices = 4;
inline bool CommandSheetRemoveDrawablesArchive::has_drawableindices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSheetRemoveDrawablesArchive::set_has_drawableindices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_has_drawableindices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_drawableindices() {
  if (drawableindices_ != NULL) drawableindices_->::TSP::IndexSet::Clear();
  clear_has_drawableindices();
}
inline const ::TSP::IndexSet& CommandSheetRemoveDrawablesArchive::drawableindices() const {
  return drawableindices_ != NULL ? *drawableindices_ : *default_instance_->drawableindices_;
}
inline ::TSP::IndexSet* CommandSheetRemoveDrawablesArchive::mutable_drawableindices() {
  set_has_drawableindices();
  if (drawableindices_ == NULL) drawableindices_ = new ::TSP::IndexSet;
  return drawableindices_;
}
inline ::TSP::IndexSet* CommandSheetRemoveDrawablesArchive::release_drawableindices() {
  clear_has_drawableindices();
  ::TSP::IndexSet* temp = drawableindices_;
  drawableindices_ = NULL;
  return temp;
}
inline void CommandSheetRemoveDrawablesArchive::set_allocated_drawableindices(::TSP::IndexSet* drawableindices) {
  delete drawableindices_;
  drawableindices_ = drawableindices;
  if (drawableindices) {
    set_has_drawableindices();
  } else {
    clear_has_drawableindices();
  }
}

// repeated .TSP.Reference old_sheet_sidebar_order = 5;
inline int CommandSheetRemoveDrawablesArchive::old_sheet_sidebar_order_size() const {
  return old_sheet_sidebar_order_.size();
}
inline void CommandSheetRemoveDrawablesArchive::clear_old_sheet_sidebar_order() {
  old_sheet_sidebar_order_.Clear();
}
inline const ::TSP::Reference& CommandSheetRemoveDrawablesArchive::old_sheet_sidebar_order(int index) const {
  return old_sheet_sidebar_order_.Get(index);
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::mutable_old_sheet_sidebar_order(int index) {
  return old_sheet_sidebar_order_.Mutable(index);
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::add_old_sheet_sidebar_order() {
  return old_sheet_sidebar_order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSheetRemoveDrawablesArchive::old_sheet_sidebar_order() const {
  return old_sheet_sidebar_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSheetRemoveDrawablesArchive::mutable_old_sheet_sidebar_order() {
  return &old_sheet_sidebar_order_;
}

// optional .TSP.Reference formula_rewrite_command_for_undo = 6;
inline bool CommandSheetRemoveDrawablesArchive::has_formula_rewrite_command_for_undo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandSheetRemoveDrawablesArchive::set_has_formula_rewrite_command_for_undo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_has_formula_rewrite_command_for_undo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandSheetRemoveDrawablesArchive::clear_formula_rewrite_command_for_undo() {
  if (formula_rewrite_command_for_undo_ != NULL) formula_rewrite_command_for_undo_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command_for_undo();
}
inline const ::TSP::Reference& CommandSheetRemoveDrawablesArchive::formula_rewrite_command_for_undo() const {
  return formula_rewrite_command_for_undo_ != NULL ? *formula_rewrite_command_for_undo_ : *default_instance_->formula_rewrite_command_for_undo_;
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::mutable_formula_rewrite_command_for_undo() {
  set_has_formula_rewrite_command_for_undo();
  if (formula_rewrite_command_for_undo_ == NULL) formula_rewrite_command_for_undo_ = new ::TSP::Reference;
  return formula_rewrite_command_for_undo_;
}
inline ::TSP::Reference* CommandSheetRemoveDrawablesArchive::release_formula_rewrite_command_for_undo() {
  clear_has_formula_rewrite_command_for_undo();
  ::TSP::Reference* temp = formula_rewrite_command_for_undo_;
  formula_rewrite_command_for_undo_ = NULL;
  return temp;
}
inline void CommandSheetRemoveDrawablesArchive::set_allocated_formula_rewrite_command_for_undo(::TSP::Reference* formula_rewrite_command_for_undo) {
  delete formula_rewrite_command_for_undo_;
  formula_rewrite_command_for_undo_ = formula_rewrite_command_for_undo;
  if (formula_rewrite_command_for_undo) {
    set_has_formula_rewrite_command_for_undo();
  } else {
    clear_has_formula_rewrite_command_for_undo();
  }
}

// -------------------------------------------------------------------

// CommandSheetMoveDrawableZOrderArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandSheetMoveDrawableZOrderArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSheetMoveDrawableZOrderArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSheetMoveDrawableZOrderArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSheetMoveDrawableZOrderArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandSheetMoveDrawableZOrderArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSheetMoveDrawableZOrderArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSheetMoveDrawableZOrderArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSheetMoveDrawableZOrderArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// repeated .TSP.Reference drawable_infos = 3;
inline int CommandSheetMoveDrawableZOrderArchive::drawable_infos_size() const {
  return drawable_infos_.size();
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_drawable_infos() {
  drawable_infos_.Clear();
}
inline const ::TSP::Reference& CommandSheetMoveDrawableZOrderArchive::drawable_infos(int index) const {
  return drawable_infos_.Get(index);
}
inline ::TSP::Reference* CommandSheetMoveDrawableZOrderArchive::mutable_drawable_infos(int index) {
  return drawable_infos_.Mutable(index);
}
inline ::TSP::Reference* CommandSheetMoveDrawableZOrderArchive::add_drawable_infos() {
  return drawable_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandSheetMoveDrawableZOrderArchive::drawable_infos() const {
  return drawable_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandSheetMoveDrawableZOrderArchive::mutable_drawable_infos() {
  return &drawable_infos_;
}

// required .TSP.IndexSet indexes = 4;
inline bool CommandSheetMoveDrawableZOrderArchive::has_indexes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_has_indexes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_has_indexes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSheetMoveDrawableZOrderArchive::clear_indexes() {
  if (indexes_ != NULL) indexes_->::TSP::IndexSet::Clear();
  clear_has_indexes();
}
inline const ::TSP::IndexSet& CommandSheetMoveDrawableZOrderArchive::indexes() const {
  return indexes_ != NULL ? *indexes_ : *default_instance_->indexes_;
}
inline ::TSP::IndexSet* CommandSheetMoveDrawableZOrderArchive::mutable_indexes() {
  set_has_indexes();
  if (indexes_ == NULL) indexes_ = new ::TSP::IndexSet;
  return indexes_;
}
inline ::TSP::IndexSet* CommandSheetMoveDrawableZOrderArchive::release_indexes() {
  clear_has_indexes();
  ::TSP::IndexSet* temp = indexes_;
  indexes_ = NULL;
  return temp;
}
inline void CommandSheetMoveDrawableZOrderArchive::set_allocated_indexes(::TSP::IndexSet* indexes) {
  delete indexes_;
  indexes_ = indexes;
  if (indexes) {
    set_has_indexes();
  } else {
    clear_has_indexes();
  }
}

// -------------------------------------------------------------------

// CommandDocumentInsertSheetArchive

// required .TSP.Reference document = 1;
inline bool CommandDocumentInsertSheetArchive::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDocumentInsertSheetArchive::set_has_document() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDocumentInsertSheetArchive::clear_has_document() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDocumentInsertSheetArchive::clear_document() {
  if (document_ != NULL) document_->::TSP::Reference::Clear();
  clear_has_document();
}
inline const ::TSP::Reference& CommandDocumentInsertSheetArchive::document() const {
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::TSP::Reference* CommandDocumentInsertSheetArchive::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::TSP::Reference;
  return document_;
}
inline ::TSP::Reference* CommandDocumentInsertSheetArchive::release_document() {
  clear_has_document();
  ::TSP::Reference* temp = document_;
  document_ = NULL;
  return temp;
}
inline void CommandDocumentInsertSheetArchive::set_allocated_document(::TSP::Reference* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandDocumentInsertSheetArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDocumentInsertSheetArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDocumentInsertSheetArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDocumentInsertSheetArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandDocumentInsertSheetArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandDocumentInsertSheetArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandDocumentInsertSheetArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandDocumentInsertSheetArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 3;
inline bool CommandDocumentInsertSheetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDocumentInsertSheetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDocumentInsertSheetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDocumentInsertSheetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandDocumentInsertSheetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandDocumentInsertSheetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandDocumentInsertSheetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDocumentInsertSheetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandDocumentRemoveSheetArchive

// required .TSP.Reference document = 1;
inline bool CommandDocumentRemoveSheetArchive::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDocumentRemoveSheetArchive::set_has_document() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDocumentRemoveSheetArchive::clear_has_document() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDocumentRemoveSheetArchive::clear_document() {
  if (document_ != NULL) document_->::TSP::Reference::Clear();
  clear_has_document();
}
inline const ::TSP::Reference& CommandDocumentRemoveSheetArchive::document() const {
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::TSP::Reference;
  return document_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::release_document() {
  clear_has_document();
  ::TSP::Reference* temp = document_;
  document_ = NULL;
  return temp;
}
inline void CommandDocumentRemoveSheetArchive::set_allocated_document(::TSP::Reference* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandDocumentRemoveSheetArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDocumentRemoveSheetArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDocumentRemoveSheetArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDocumentRemoveSheetArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandDocumentRemoveSheetArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandDocumentRemoveSheetArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required uint32 index = 3;
inline bool CommandDocumentRemoveSheetArchive::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDocumentRemoveSheetArchive::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDocumentRemoveSheetArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDocumentRemoveSheetArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandDocumentRemoveSheetArchive::index() const {
  return index_;
}
inline void CommandDocumentRemoveSheetArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated .TSP.Reference old_sheet_sidebar_order = 4;
inline int CommandDocumentRemoveSheetArchive::old_sheet_sidebar_order_size() const {
  return old_sheet_sidebar_order_.size();
}
inline void CommandDocumentRemoveSheetArchive::clear_old_sheet_sidebar_order() {
  old_sheet_sidebar_order_.Clear();
}
inline const ::TSP::Reference& CommandDocumentRemoveSheetArchive::old_sheet_sidebar_order(int index) const {
  return old_sheet_sidebar_order_.Get(index);
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::mutable_old_sheet_sidebar_order(int index) {
  return old_sheet_sidebar_order_.Mutable(index);
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::add_old_sheet_sidebar_order() {
  return old_sheet_sidebar_order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandDocumentRemoveSheetArchive::old_sheet_sidebar_order() const {
  return old_sheet_sidebar_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandDocumentRemoveSheetArchive::mutable_old_sheet_sidebar_order() {
  return &old_sheet_sidebar_order_;
}

// required .TSK.CommandArchive super = 5;
inline bool CommandDocumentRemoveSheetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDocumentRemoveSheetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDocumentRemoveSheetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDocumentRemoveSheetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandDocumentRemoveSheetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandDocumentRemoveSheetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandDocumentRemoveSheetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDocumentRemoveSheetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference formula_rewrite_command_for_undo = 6;
inline bool CommandDocumentRemoveSheetArchive::has_formula_rewrite_command_for_undo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandDocumentRemoveSheetArchive::set_has_formula_rewrite_command_for_undo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandDocumentRemoveSheetArchive::clear_has_formula_rewrite_command_for_undo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandDocumentRemoveSheetArchive::clear_formula_rewrite_command_for_undo() {
  if (formula_rewrite_command_for_undo_ != NULL) formula_rewrite_command_for_undo_->::TSP::Reference::Clear();
  clear_has_formula_rewrite_command_for_undo();
}
inline const ::TSP::Reference& CommandDocumentRemoveSheetArchive::formula_rewrite_command_for_undo() const {
  return formula_rewrite_command_for_undo_ != NULL ? *formula_rewrite_command_for_undo_ : *default_instance_->formula_rewrite_command_for_undo_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::mutable_formula_rewrite_command_for_undo() {
  set_has_formula_rewrite_command_for_undo();
  if (formula_rewrite_command_for_undo_ == NULL) formula_rewrite_command_for_undo_ = new ::TSP::Reference;
  return formula_rewrite_command_for_undo_;
}
inline ::TSP::Reference* CommandDocumentRemoveSheetArchive::release_formula_rewrite_command_for_undo() {
  clear_has_formula_rewrite_command_for_undo();
  ::TSP::Reference* temp = formula_rewrite_command_for_undo_;
  formula_rewrite_command_for_undo_ = NULL;
  return temp;
}
inline void CommandDocumentRemoveSheetArchive::set_allocated_formula_rewrite_command_for_undo(::TSP::Reference* formula_rewrite_command_for_undo) {
  delete formula_rewrite_command_for_undo_;
  formula_rewrite_command_for_undo_ = formula_rewrite_command_for_undo;
  if (formula_rewrite_command_for_undo) {
    set_has_formula_rewrite_command_for_undo();
  } else {
    clear_has_formula_rewrite_command_for_undo();
  }
}

// -------------------------------------------------------------------

// CommandDocumentReplaceLastSheetArchive

// required .TSP.Reference document = 1;
inline bool CommandDocumentReplaceLastSheetArchive::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDocumentReplaceLastSheetArchive::set_has_document() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_has_document() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_document() {
  if (document_ != NULL) document_->::TSP::Reference::Clear();
  clear_has_document();
}
inline const ::TSP::Reference& CommandDocumentReplaceLastSheetArchive::document() const {
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::TSP::Reference;
  return document_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::release_document() {
  clear_has_document();
  ::TSP::Reference* temp = document_;
  document_ = NULL;
  return temp;
}
inline void CommandDocumentReplaceLastSheetArchive::set_allocated_document(::TSP::Reference* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
}

// required .TSP.Reference last_sheet = 2;
inline bool CommandDocumentReplaceLastSheetArchive::has_last_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDocumentReplaceLastSheetArchive::set_has_last_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_has_last_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_last_sheet() {
  if (last_sheet_ != NULL) last_sheet_->::TSP::Reference::Clear();
  clear_has_last_sheet();
}
inline const ::TSP::Reference& CommandDocumentReplaceLastSheetArchive::last_sheet() const {
  return last_sheet_ != NULL ? *last_sheet_ : *default_instance_->last_sheet_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::mutable_last_sheet() {
  set_has_last_sheet();
  if (last_sheet_ == NULL) last_sheet_ = new ::TSP::Reference;
  return last_sheet_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::release_last_sheet() {
  clear_has_last_sheet();
  ::TSP::Reference* temp = last_sheet_;
  last_sheet_ = NULL;
  return temp;
}
inline void CommandDocumentReplaceLastSheetArchive::set_allocated_last_sheet(::TSP::Reference* last_sheet) {
  delete last_sheet_;
  last_sheet_ = last_sheet;
  if (last_sheet) {
    set_has_last_sheet();
  } else {
    clear_has_last_sheet();
  }
}

// required .TSP.Reference new_sheet = 3;
inline bool CommandDocumentReplaceLastSheetArchive::has_new_sheet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDocumentReplaceLastSheetArchive::set_has_new_sheet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_has_new_sheet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_new_sheet() {
  if (new_sheet_ != NULL) new_sheet_->::TSP::Reference::Clear();
  clear_has_new_sheet();
}
inline const ::TSP::Reference& CommandDocumentReplaceLastSheetArchive::new_sheet() const {
  return new_sheet_ != NULL ? *new_sheet_ : *default_instance_->new_sheet_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::mutable_new_sheet() {
  set_has_new_sheet();
  if (new_sheet_ == NULL) new_sheet_ = new ::TSP::Reference;
  return new_sheet_;
}
inline ::TSP::Reference* CommandDocumentReplaceLastSheetArchive::release_new_sheet() {
  clear_has_new_sheet();
  ::TSP::Reference* temp = new_sheet_;
  new_sheet_ = NULL;
  return temp;
}
inline void CommandDocumentReplaceLastSheetArchive::set_allocated_new_sheet(::TSP::Reference* new_sheet) {
  delete new_sheet_;
  new_sheet_ = new_sheet;
  if (new_sheet) {
    set_has_new_sheet();
  } else {
    clear_has_new_sheet();
  }
}

// required .TSK.CommandArchive super = 4;
inline bool CommandDocumentReplaceLastSheetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandDocumentReplaceLastSheetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandDocumentReplaceLastSheetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandDocumentReplaceLastSheetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandDocumentReplaceLastSheetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDocumentReplaceLastSheetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 index = 5;
inline bool CommandDocumentReplaceLastSheetArchive::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDocumentReplaceLastSheetArchive::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDocumentReplaceLastSheetArchive::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CommandDocumentReplaceLastSheetArchive::index() const {
  return index_;
}
inline void CommandDocumentReplaceLastSheetArchive::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// CommandDocumentReorderSheetArchive

// required .TSP.Reference document = 1;
inline bool CommandDocumentReorderSheetArchive::has_document() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandDocumentReorderSheetArchive::set_has_document() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandDocumentReorderSheetArchive::clear_has_document() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandDocumentReorderSheetArchive::clear_document() {
  if (document_ != NULL) document_->::TSP::Reference::Clear();
  clear_has_document();
}
inline const ::TSP::Reference& CommandDocumentReorderSheetArchive::document() const {
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::TSP::Reference* CommandDocumentReorderSheetArchive::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::TSP::Reference;
  return document_;
}
inline ::TSP::Reference* CommandDocumentReorderSheetArchive::release_document() {
  clear_has_document();
  ::TSP::Reference* temp = document_;
  document_ = NULL;
  return temp;
}
inline void CommandDocumentReorderSheetArchive::set_allocated_document(::TSP::Reference* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandDocumentReorderSheetArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandDocumentReorderSheetArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandDocumentReorderSheetArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandDocumentReorderSheetArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandDocumentReorderSheetArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandDocumentReorderSheetArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandDocumentReorderSheetArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandDocumentReorderSheetArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required uint32 source_index = 3;
inline bool CommandDocumentReorderSheetArchive::has_source_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandDocumentReorderSheetArchive::set_has_source_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandDocumentReorderSheetArchive::clear_has_source_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandDocumentReorderSheetArchive::clear_source_index() {
  source_index_ = 0u;
  clear_has_source_index();
}
inline ::google::protobuf::uint32 CommandDocumentReorderSheetArchive::source_index() const {
  return source_index_;
}
inline void CommandDocumentReorderSheetArchive::set_source_index(::google::protobuf::uint32 value) {
  set_has_source_index();
  source_index_ = value;
}

// required uint32 dest_index = 4;
inline bool CommandDocumentReorderSheetArchive::has_dest_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandDocumentReorderSheetArchive::set_has_dest_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandDocumentReorderSheetArchive::clear_has_dest_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandDocumentReorderSheetArchive::clear_dest_index() {
  dest_index_ = 0u;
  clear_has_dest_index();
}
inline ::google::protobuf::uint32 CommandDocumentReorderSheetArchive::dest_index() const {
  return dest_index_;
}
inline void CommandDocumentReorderSheetArchive::set_dest_index(::google::protobuf::uint32 value) {
  set_has_dest_index();
  dest_index_ = value;
}

// required .TSK.CommandArchive super = 5;
inline bool CommandDocumentReorderSheetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandDocumentReorderSheetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandDocumentReorderSheetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandDocumentReorderSheetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandDocumentReorderSheetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandDocumentReorderSheetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandDocumentReorderSheetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandDocumentReorderSheetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetSheetNameArchive

// required string newname = 1;
inline bool CommandSetSheetNameArchive::has_newname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetSheetNameArchive::set_has_newname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetSheetNameArchive::clear_has_newname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetSheetNameArchive::clear_newname() {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    newname_->clear();
  }
  clear_has_newname();
}
inline const ::std::string& CommandSetSheetNameArchive::newname() const {
  return *newname_;
}
inline void CommandSetSheetNameArchive::set_newname(const ::std::string& value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CommandSetSheetNameArchive::set_newname(const char* value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CommandSetSheetNameArchive::set_newname(const char* value, size_t size) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetSheetNameArchive::mutable_newname() {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  return newname_;
}
inline ::std::string* CommandSetSheetNameArchive::release_newname() {
  clear_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newname_;
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetSheetNameArchive::set_allocated_newname(::std::string* newname) {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    delete newname_;
  }
  if (newname) {
    set_has_newname();
    newname_ = newname;
  } else {
    clear_has_newname();
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string oldname = 2;
inline bool CommandSetSheetNameArchive::has_oldname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetSheetNameArchive::set_has_oldname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetSheetNameArchive::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetSheetNameArchive::clear_oldname() {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    oldname_->clear();
  }
  clear_has_oldname();
}
inline const ::std::string& CommandSetSheetNameArchive::oldname() const {
  return *oldname_;
}
inline void CommandSetSheetNameArchive::set_oldname(const ::std::string& value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void CommandSetSheetNameArchive::set_oldname(const char* value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void CommandSetSheetNameArchive::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetSheetNameArchive::mutable_oldname() {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  return oldname_;
}
inline ::std::string* CommandSetSheetNameArchive::release_oldname() {
  clear_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldname_;
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetSheetNameArchive::set_allocated_oldname(::std::string* oldname) {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    delete oldname_;
  }
  if (oldname) {
    set_has_oldname();
    oldname_ = oldname;
  } else {
    clear_has_oldname();
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Reference sheet = 3;
inline bool CommandSetSheetNameArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetSheetNameArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetSheetNameArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetSheetNameArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetSheetNameArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetSheetNameArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetSheetNameArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetSheetNameArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 4;
inline bool CommandSetSheetNameArchive::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetSheetNameArchive::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetSheetNameArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetSheetNameArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetSheetNameArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetSheetNameArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetSheetNameArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetSheetNameArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetPageOrientationArchive

// required bool in_portrait_page_orientation = 1;
inline bool CommandSetPageOrientationArchive::has_in_portrait_page_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetPageOrientationArchive::set_has_in_portrait_page_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetPageOrientationArchive::clear_has_in_portrait_page_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetPageOrientationArchive::clear_in_portrait_page_orientation() {
  in_portrait_page_orientation_ = false;
  clear_has_in_portrait_page_orientation();
}
inline bool CommandSetPageOrientationArchive::in_portrait_page_orientation() const {
  return in_portrait_page_orientation_;
}
inline void CommandSetPageOrientationArchive::set_in_portrait_page_orientation(bool value) {
  set_has_in_portrait_page_orientation();
  in_portrait_page_orientation_ = value;
}

// required .TSP.Reference sheet = 2;
inline bool CommandSetPageOrientationArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetPageOrientationArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetPageOrientationArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetPageOrientationArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetPageOrientationArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetPageOrientationArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetPageOrientationArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetPageOrientationArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 3;
inline bool CommandSetPageOrientationArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetPageOrientationArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetPageOrientationArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetPageOrientationArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetPageOrientationArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetPageOrientationArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetPageOrientationArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetPageOrientationArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetShowPageNumbersValueArchive

// required bool show_page_numbers = 1;
inline bool CommandSetShowPageNumbersValueArchive::has_show_page_numbers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetShowPageNumbersValueArchive::set_has_show_page_numbers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_has_show_page_numbers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_show_page_numbers() {
  show_page_numbers_ = false;
  clear_has_show_page_numbers();
}
inline bool CommandSetShowPageNumbersValueArchive::show_page_numbers() const {
  return show_page_numbers_;
}
inline void CommandSetShowPageNumbersValueArchive::set_show_page_numbers(bool value) {
  set_has_show_page_numbers();
  show_page_numbers_ = value;
}

// required .TSP.Reference sheet = 2;
inline bool CommandSetShowPageNumbersValueArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetShowPageNumbersValueArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetShowPageNumbersValueArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetShowPageNumbersValueArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetShowPageNumbersValueArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetShowPageNumbersValueArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 3;
inline bool CommandSetShowPageNumbersValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetShowPageNumbersValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetShowPageNumbersValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetShowPageNumbersValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetShowPageNumbersValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetShowPageNumbersValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetShowPageNumbersValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetRepeatingHeadersValueArchive

// required bool show_repeating_headers = 1;
inline bool CommandSetRepeatingHeadersValueArchive::has_show_repeating_headers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetRepeatingHeadersValueArchive::set_has_show_repeating_headers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_has_show_repeating_headers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_show_repeating_headers() {
  show_repeating_headers_ = false;
  clear_has_show_repeating_headers();
}
inline bool CommandSetRepeatingHeadersValueArchive::show_repeating_headers() const {
  return show_repeating_headers_;
}
inline void CommandSetRepeatingHeadersValueArchive::set_show_repeating_headers(bool value) {
  set_has_show_repeating_headers();
  show_repeating_headers_ = value;
}

// required .TSP.Reference sheet = 2;
inline bool CommandSetRepeatingHeadersValueArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetRepeatingHeadersValueArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetRepeatingHeadersValueArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetRepeatingHeadersValueArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetRepeatingHeadersValueArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetRepeatingHeadersValueArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 3;
inline bool CommandSetRepeatingHeadersValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetRepeatingHeadersValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetRepeatingHeadersValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetRepeatingHeadersValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetRepeatingHeadersValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetRepeatingHeadersValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetRepeatingHeadersValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetContentScaleArchive

// required bool is_autofit_on = 1;
inline bool CommandSetContentScaleArchive::has_is_autofit_on() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetContentScaleArchive::set_has_is_autofit_on() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetContentScaleArchive::clear_has_is_autofit_on() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetContentScaleArchive::clear_is_autofit_on() {
  is_autofit_on_ = false;
  clear_has_is_autofit_on();
}
inline bool CommandSetContentScaleArchive::is_autofit_on() const {
  return is_autofit_on_;
}
inline void CommandSetContentScaleArchive::set_is_autofit_on(bool value) {
  set_has_is_autofit_on();
  is_autofit_on_ = value;
}

// required float old_content_scale = 2;
inline bool CommandSetContentScaleArchive::has_old_content_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetContentScaleArchive::set_has_old_content_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetContentScaleArchive::clear_has_old_content_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetContentScaleArchive::clear_old_content_scale() {
  old_content_scale_ = 0;
  clear_has_old_content_scale();
}
inline float CommandSetContentScaleArchive::old_content_scale() const {
  return old_content_scale_;
}
inline void CommandSetContentScaleArchive::set_old_content_scale(float value) {
  set_has_old_content_scale();
  old_content_scale_ = value;
}

// optional float new_content_scale = 3;
inline bool CommandSetContentScaleArchive::has_new_content_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetContentScaleArchive::set_has_new_content_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetContentScaleArchive::clear_has_new_content_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetContentScaleArchive::clear_new_content_scale() {
  new_content_scale_ = 0;
  clear_has_new_content_scale();
}
inline float CommandSetContentScaleArchive::new_content_scale() const {
  return new_content_scale_;
}
inline void CommandSetContentScaleArchive::set_new_content_scale(float value) {
  set_has_new_content_scale();
  new_content_scale_ = value;
}

// required .TSP.Reference sheet = 4;
inline bool CommandSetContentScaleArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetContentScaleArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetContentScaleArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetContentScaleArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetContentScaleArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetContentScaleArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetContentScaleArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetContentScaleArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 5;
inline bool CommandSetContentScaleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandSetContentScaleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandSetContentScaleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandSetContentScaleArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetContentScaleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetContentScaleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetContentScaleArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetContentScaleArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetAutofitValueArchive

// required float old_content_scale = 1;
inline bool CommandSetAutofitValueArchive::has_old_content_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetAutofitValueArchive::set_has_old_content_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetAutofitValueArchive::clear_has_old_content_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetAutofitValueArchive::clear_old_content_scale() {
  old_content_scale_ = 0;
  clear_has_old_content_scale();
}
inline float CommandSetAutofitValueArchive::old_content_scale() const {
  return old_content_scale_;
}
inline void CommandSetAutofitValueArchive::set_old_content_scale(float value) {
  set_has_old_content_scale();
  old_content_scale_ = value;
}

// required .TSP.Reference sheet = 2;
inline bool CommandSetAutofitValueArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetAutofitValueArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetAutofitValueArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetAutofitValueArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandSetAutofitValueArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandSetAutofitValueArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandSetAutofitValueArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandSetAutofitValueArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// required .TSK.CommandArchive super = 3;
inline bool CommandSetAutofitValueArchive::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetAutofitValueArchive::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetAutofitValueArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetAutofitValueArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetAutofitValueArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetAutofitValueArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetAutofitValueArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetAutofitValueArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSetDocumentPrinterOptions

// required string printer_id = 1;
inline bool CommandSetDocumentPrinterOptions::has_printer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSetDocumentPrinterOptions::set_has_printer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSetDocumentPrinterOptions::clear_has_printer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSetDocumentPrinterOptions::clear_printer_id() {
  if (printer_id_ != &::google::protobuf::internal::kEmptyString) {
    printer_id_->clear();
  }
  clear_has_printer_id();
}
inline const ::std::string& CommandSetDocumentPrinterOptions::printer_id() const {
  return *printer_id_;
}
inline void CommandSetDocumentPrinterOptions::set_printer_id(const ::std::string& value) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(value);
}
inline void CommandSetDocumentPrinterOptions::set_printer_id(const char* value) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(value);
}
inline void CommandSetDocumentPrinterOptions::set_printer_id(const char* value, size_t size) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetDocumentPrinterOptions::mutable_printer_id() {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  return printer_id_;
}
inline ::std::string* CommandSetDocumentPrinterOptions::release_printer_id() {
  clear_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = printer_id_;
    printer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetDocumentPrinterOptions::set_allocated_printer_id(::std::string* printer_id) {
  if (printer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete printer_id_;
  }
  if (printer_id) {
    set_has_printer_id();
    printer_id_ = printer_id;
  } else {
    clear_has_printer_id();
    printer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string paper_id = 2;
inline bool CommandSetDocumentPrinterOptions::has_paper_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSetDocumentPrinterOptions::set_has_paper_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSetDocumentPrinterOptions::clear_has_paper_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSetDocumentPrinterOptions::clear_paper_id() {
  if (paper_id_ != &::google::protobuf::internal::kEmptyString) {
    paper_id_->clear();
  }
  clear_has_paper_id();
}
inline const ::std::string& CommandSetDocumentPrinterOptions::paper_id() const {
  return *paper_id_;
}
inline void CommandSetDocumentPrinterOptions::set_paper_id(const ::std::string& value) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(value);
}
inline void CommandSetDocumentPrinterOptions::set_paper_id(const char* value) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(value);
}
inline void CommandSetDocumentPrinterOptions::set_paper_id(const char* value, size_t size) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommandSetDocumentPrinterOptions::mutable_paper_id() {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  return paper_id_;
}
inline ::std::string* CommandSetDocumentPrinterOptions::release_paper_id() {
  clear_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paper_id_;
    paper_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommandSetDocumentPrinterOptions::set_allocated_paper_id(::std::string* paper_id) {
  if (paper_id_ != &::google::protobuf::internal::kEmptyString) {
    delete paper_id_;
  }
  if (paper_id) {
    set_has_paper_id();
    paper_id_ = paper_id;
  } else {
    clear_has_paper_id();
    paper_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .TSP.Size page_size = 3;
inline bool CommandSetDocumentPrinterOptions::has_page_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandSetDocumentPrinterOptions::set_has_page_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandSetDocumentPrinterOptions::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandSetDocumentPrinterOptions::clear_page_size() {
  if (page_size_ != NULL) page_size_->::TSP::Size::Clear();
  clear_has_page_size();
}
inline const ::TSP::Size& CommandSetDocumentPrinterOptions::page_size() const {
  return page_size_ != NULL ? *page_size_ : *default_instance_->page_size_;
}
inline ::TSP::Size* CommandSetDocumentPrinterOptions::mutable_page_size() {
  set_has_page_size();
  if (page_size_ == NULL) page_size_ = new ::TSP::Size;
  return page_size_;
}
inline ::TSP::Size* CommandSetDocumentPrinterOptions::release_page_size() {
  clear_has_page_size();
  ::TSP::Size* temp = page_size_;
  page_size_ = NULL;
  return temp;
}
inline void CommandSetDocumentPrinterOptions::set_allocated_page_size(::TSP::Size* page_size) {
  delete page_size_;
  page_size_ = page_size;
  if (page_size) {
    set_has_page_size();
  } else {
    clear_has_page_size();
  }
}

// required .TSK.CommandArchive super = 4;
inline bool CommandSetDocumentPrinterOptions::has_super() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandSetDocumentPrinterOptions::set_has_super() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandSetDocumentPrinterOptions::clear_has_super() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandSetDocumentPrinterOptions::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandSetDocumentPrinterOptions::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandSetDocumentPrinterOptions::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandSetDocumentPrinterOptions::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandSetDocumentPrinterOptions::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandEnterPrintPreviewModeArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandEnterPrintPreviewModeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandEnterPrintPreviewModeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandEnterPrintPreviewModeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandEnterPrintPreviewModeArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandEnterPrintPreviewModeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandEnterPrintPreviewModeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandEnterPrintPreviewModeArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandEnterPrintPreviewModeArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandExitPrintPreviewModeArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandExitPrintPreviewModeArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandExitPrintPreviewModeArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandExitPrintPreviewModeArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandExitPrintPreviewModeArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandExitPrintPreviewModeArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandExitPrintPreviewModeArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandExitPrintPreviewModeArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandExitPrintPreviewModeArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandPasteDrawablesArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandPasteDrawablesArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPasteDrawablesArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPasteDrawablesArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPasteDrawablesArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandPasteDrawablesArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandPasteDrawablesArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandPasteDrawablesArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandPasteDrawablesArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandPasteDrawablesArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPasteDrawablesArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPasteDrawablesArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPasteDrawablesArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandPasteDrawablesArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandPasteDrawablesArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandPasteDrawablesArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandPasteDrawablesArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// repeated .TSP.Reference drawables = 3;
inline int CommandPasteDrawablesArchive::drawables_size() const {
  return drawables_.size();
}
inline void CommandPasteDrawablesArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& CommandPasteDrawablesArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* CommandPasteDrawablesArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* CommandPasteDrawablesArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandPasteDrawablesArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandPasteDrawablesArchive::mutable_drawables() {
  return &drawables_;
}

// -------------------------------------------------------------------

// CommandPasteSheetArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandPasteSheetArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandPasteSheetArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandPasteSheetArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandPasteSheetArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandPasteSheetArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandPasteSheetArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandPasteSheetArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandPasteSheetArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference document = 2;
inline bool CommandPasteSheetArchive::has_document() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandPasteSheetArchive::set_has_document() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandPasteSheetArchive::clear_has_document() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandPasteSheetArchive::clear_document() {
  if (document_ != NULL) document_->::TSP::Reference::Clear();
  clear_has_document();
}
inline const ::TSP::Reference& CommandPasteSheetArchive::document() const {
  return document_ != NULL ? *document_ : *default_instance_->document_;
}
inline ::TSP::Reference* CommandPasteSheetArchive::mutable_document() {
  set_has_document();
  if (document_ == NULL) document_ = new ::TSP::Reference;
  return document_;
}
inline ::TSP::Reference* CommandPasteSheetArchive::release_document() {
  clear_has_document();
  ::TSP::Reference* temp = document_;
  document_ = NULL;
  return temp;
}
inline void CommandPasteSheetArchive::set_allocated_document(::TSP::Reference* document) {
  delete document_;
  document_ = document;
  if (document) {
    set_has_document();
  } else {
    clear_has_document();
  }
}

// required .TSP.Reference sheet = 3;
inline bool CommandPasteSheetArchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandPasteSheetArchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandPasteSheetArchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandPasteSheetArchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandPasteSheetArchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandPasteSheetArchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandPasteSheetArchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandPasteSheetArchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// optional .TN.SheetUIStateArchive sheet_uistate = 4;
inline bool CommandPasteSheetArchive::has_sheet_uistate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandPasteSheetArchive::set_has_sheet_uistate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandPasteSheetArchive::clear_has_sheet_uistate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandPasteSheetArchive::clear_sheet_uistate() {
  if (sheet_uistate_ != NULL) sheet_uistate_->::TN::SheetUIStateArchive::Clear();
  clear_has_sheet_uistate();
}
inline const ::TN::SheetUIStateArchive& CommandPasteSheetArchive::sheet_uistate() const {
  return sheet_uistate_ != NULL ? *sheet_uistate_ : *default_instance_->sheet_uistate_;
}
inline ::TN::SheetUIStateArchive* CommandPasteSheetArchive::mutable_sheet_uistate() {
  set_has_sheet_uistate();
  if (sheet_uistate_ == NULL) sheet_uistate_ = new ::TN::SheetUIStateArchive;
  return sheet_uistate_;
}
inline ::TN::SheetUIStateArchive* CommandPasteSheetArchive::release_sheet_uistate() {
  clear_has_sheet_uistate();
  ::TN::SheetUIStateArchive* temp = sheet_uistate_;
  sheet_uistate_ = NULL;
  return temp;
}
inline void CommandPasteSheetArchive::set_allocated_sheet_uistate(::TN::SheetUIStateArchive* sheet_uistate) {
  delete sheet_uistate_;
  sheet_uistate_ = sheet_uistate;
  if (sheet_uistate) {
    set_has_sheet_uistate();
  } else {
    clear_has_sheet_uistate();
  }
}

// required uint32 sheetIndex = 5;
inline bool CommandPasteSheetArchive::has_sheetindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandPasteSheetArchive::set_has_sheetindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandPasteSheetArchive::clear_has_sheetindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandPasteSheetArchive::clear_sheetindex() {
  sheetindex_ = 0u;
  clear_has_sheetindex();
}
inline ::google::protobuf::uint32 CommandPasteSheetArchive::sheetindex() const {
  return sheetindex_;
}
inline void CommandPasteSheetArchive::set_sheetindex(::google::protobuf::uint32 value) {
  set_has_sheetindex();
  sheetindex_ = value;
}

// -------------------------------------------------------------------

// CommandReorderSidebarItemChildrenAchive

// required .TSK.CommandArchive super = 1;
inline bool CommandReorderSidebarItemChildrenAchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandReorderSidebarItemChildrenAchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandReorderSidebarItemChildrenAchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandReorderSidebarItemChildrenAchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandReorderSidebarItemChildrenAchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandReorderSidebarItemChildrenAchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandReorderSidebarItemChildrenAchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandReorderSidebarItemChildrenAchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference sheet = 2;
inline bool CommandReorderSidebarItemChildrenAchive::has_sheet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandReorderSidebarItemChildrenAchive::set_has_sheet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandReorderSidebarItemChildrenAchive::clear_has_sheet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandReorderSidebarItemChildrenAchive::clear_sheet() {
  if (sheet_ != NULL) sheet_->::TSP::Reference::Clear();
  clear_has_sheet();
}
inline const ::TSP::Reference& CommandReorderSidebarItemChildrenAchive::sheet() const {
  return sheet_ != NULL ? *sheet_ : *default_instance_->sheet_;
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::mutable_sheet() {
  set_has_sheet();
  if (sheet_ == NULL) sheet_ = new ::TSP::Reference;
  return sheet_;
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::release_sheet() {
  clear_has_sheet();
  ::TSP::Reference* temp = sheet_;
  sheet_ = NULL;
  return temp;
}
inline void CommandReorderSidebarItemChildrenAchive::set_allocated_sheet(::TSP::Reference* sheet) {
  delete sheet_;
  sheet_ = sheet;
  if (sheet) {
    set_has_sheet();
  } else {
    clear_has_sheet();
  }
}

// repeated .TSP.Reference old_children = 3;
inline int CommandReorderSidebarItemChildrenAchive::old_children_size() const {
  return old_children_.size();
}
inline void CommandReorderSidebarItemChildrenAchive::clear_old_children() {
  old_children_.Clear();
}
inline const ::TSP::Reference& CommandReorderSidebarItemChildrenAchive::old_children(int index) const {
  return old_children_.Get(index);
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::mutable_old_children(int index) {
  return old_children_.Mutable(index);
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::add_old_children() {
  return old_children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandReorderSidebarItemChildrenAchive::old_children() const {
  return old_children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandReorderSidebarItemChildrenAchive::mutable_old_children() {
  return &old_children_;
}

// repeated .TSP.Reference new_children = 4;
inline int CommandReorderSidebarItemChildrenAchive::new_children_size() const {
  return new_children_.size();
}
inline void CommandReorderSidebarItemChildrenAchive::clear_new_children() {
  new_children_.Clear();
}
inline const ::TSP::Reference& CommandReorderSidebarItemChildrenAchive::new_children(int index) const {
  return new_children_.Get(index);
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::mutable_new_children(int index) {
  return new_children_.Mutable(index);
}
inline ::TSP::Reference* CommandReorderSidebarItemChildrenAchive::add_new_children() {
  return new_children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandReorderSidebarItemChildrenAchive::new_children() const {
  return new_children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandReorderSidebarItemChildrenAchive::mutable_new_children() {
  return &new_children_;
}

// -------------------------------------------------------------------

// CommandChartMediatorSetEditingState

// required .TSCH.ChartCommandArchive super = 1;
inline bool CommandChartMediatorSetEditingState::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandChartMediatorSetEditingState::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandChartMediatorSetEditingState::clear_super() {
  if (super_ != NULL) super_->::TSCH::ChartCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSCH::ChartCommandArchive& CommandChartMediatorSetEditingState::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSCH::ChartCommandArchive* CommandChartMediatorSetEditingState::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSCH::ChartCommandArchive;
  return super_;
}
inline ::TSCH::ChartCommandArchive* CommandChartMediatorSetEditingState::release_super() {
  clear_has_super();
  ::TSCH::ChartCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandChartMediatorSetEditingState::set_allocated_super(::TSCH::ChartCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TN.ChartMediatorFormulaStorage old_formulas = 3;
inline bool CommandChartMediatorSetEditingState::has_old_formulas() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_old_formulas() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandChartMediatorSetEditingState::clear_has_old_formulas() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandChartMediatorSetEditingState::clear_old_formulas() {
  if (old_formulas_ != NULL) old_formulas_->::TN::ChartMediatorFormulaStorage::Clear();
  clear_has_old_formulas();
}
inline const ::TN::ChartMediatorFormulaStorage& CommandChartMediatorSetEditingState::old_formulas() const {
  return old_formulas_ != NULL ? *old_formulas_ : *default_instance_->old_formulas_;
}
inline ::TN::ChartMediatorFormulaStorage* CommandChartMediatorSetEditingState::mutable_old_formulas() {
  set_has_old_formulas();
  if (old_formulas_ == NULL) old_formulas_ = new ::TN::ChartMediatorFormulaStorage;
  return old_formulas_;
}
inline ::TN::ChartMediatorFormulaStorage* CommandChartMediatorSetEditingState::release_old_formulas() {
  clear_has_old_formulas();
  ::TN::ChartMediatorFormulaStorage* temp = old_formulas_;
  old_formulas_ = NULL;
  return temp;
}
inline void CommandChartMediatorSetEditingState::set_allocated_old_formulas(::TN::ChartMediatorFormulaStorage* old_formulas) {
  delete old_formulas_;
  old_formulas_ = old_formulas;
  if (old_formulas) {
    set_has_old_formulas();
  } else {
    clear_has_old_formulas();
  }
}

// optional .TN.ChartMediatorFormulaStorage new_formulas = 4;
inline bool CommandChartMediatorSetEditingState::has_new_formulas() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_new_formulas() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandChartMediatorSetEditingState::clear_has_new_formulas() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandChartMediatorSetEditingState::clear_new_formulas() {
  if (new_formulas_ != NULL) new_formulas_->::TN::ChartMediatorFormulaStorage::Clear();
  clear_has_new_formulas();
}
inline const ::TN::ChartMediatorFormulaStorage& CommandChartMediatorSetEditingState::new_formulas() const {
  return new_formulas_ != NULL ? *new_formulas_ : *default_instance_->new_formulas_;
}
inline ::TN::ChartMediatorFormulaStorage* CommandChartMediatorSetEditingState::mutable_new_formulas() {
  set_has_new_formulas();
  if (new_formulas_ == NULL) new_formulas_ = new ::TN::ChartMediatorFormulaStorage;
  return new_formulas_;
}
inline ::TN::ChartMediatorFormulaStorage* CommandChartMediatorSetEditingState::release_new_formulas() {
  clear_has_new_formulas();
  ::TN::ChartMediatorFormulaStorage* temp = new_formulas_;
  new_formulas_ = NULL;
  return temp;
}
inline void CommandChartMediatorSetEditingState::set_allocated_new_formulas(::TN::ChartMediatorFormulaStorage* new_formulas) {
  delete new_formulas_;
  new_formulas_ = new_formulas;
  if (new_formulas) {
    set_has_new_formulas();
  } else {
    clear_has_new_formulas();
  }
}

// optional int32 old_direction = 5;
inline bool CommandChartMediatorSetEditingState::has_old_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_old_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandChartMediatorSetEditingState::clear_has_old_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandChartMediatorSetEditingState::clear_old_direction() {
  old_direction_ = 0;
  clear_has_old_direction();
}
inline ::google::protobuf::int32 CommandChartMediatorSetEditingState::old_direction() const {
  return old_direction_;
}
inline void CommandChartMediatorSetEditingState::set_old_direction(::google::protobuf::int32 value) {
  set_has_old_direction();
  old_direction_ = value;
}

// optional int32 new_direction = 6;
inline bool CommandChartMediatorSetEditingState::has_new_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_new_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandChartMediatorSetEditingState::clear_has_new_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandChartMediatorSetEditingState::clear_new_direction() {
  new_direction_ = 0;
  clear_has_new_direction();
}
inline ::google::protobuf::int32 CommandChartMediatorSetEditingState::new_direction() const {
  return new_direction_;
}
inline void CommandChartMediatorSetEditingState::set_new_direction(::google::protobuf::int32 value) {
  set_has_new_direction();
  new_direction_ = value;
}

// optional int32 old_scatter_format = 7;
inline bool CommandChartMediatorSetEditingState::has_old_scatter_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_old_scatter_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandChartMediatorSetEditingState::clear_has_old_scatter_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandChartMediatorSetEditingState::clear_old_scatter_format() {
  old_scatter_format_ = 0;
  clear_has_old_scatter_format();
}
inline ::google::protobuf::int32 CommandChartMediatorSetEditingState::old_scatter_format() const {
  return old_scatter_format_;
}
inline void CommandChartMediatorSetEditingState::set_old_scatter_format(::google::protobuf::int32 value) {
  set_has_old_scatter_format();
  old_scatter_format_ = value;
}

// optional int32 new_scatter_format = 8;
inline bool CommandChartMediatorSetEditingState::has_new_scatter_format() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandChartMediatorSetEditingState::set_has_new_scatter_format() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandChartMediatorSetEditingState::clear_has_new_scatter_format() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandChartMediatorSetEditingState::clear_new_scatter_format() {
  new_scatter_format_ = 0;
  clear_has_new_scatter_format();
}
inline ::google::protobuf::int32 CommandChartMediatorSetEditingState::new_scatter_format() const {
  return new_scatter_format_;
}
inline void CommandChartMediatorSetEditingState::set_new_scatter_format(::google::protobuf::int32 value) {
  set_has_new_scatter_format();
  new_scatter_format_ = value;
}

// -------------------------------------------------------------------

// CommandChartMediatorUpdateForEntityDelete

// required .TSCH.ChartCommandArchive super = 1;
inline bool CommandChartMediatorUpdateForEntityDelete::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandChartMediatorUpdateForEntityDelete::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandChartMediatorUpdateForEntityDelete::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandChartMediatorUpdateForEntityDelete::clear_super() {
  if (super_ != NULL) super_->::TSCH::ChartCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSCH::ChartCommandArchive& CommandChartMediatorUpdateForEntityDelete::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSCH::ChartCommandArchive* CommandChartMediatorUpdateForEntityDelete::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSCH::ChartCommandArchive;
  return super_;
}
inline ::TSCH::ChartCommandArchive* CommandChartMediatorUpdateForEntityDelete::release_super() {
  clear_has_super();
  ::TSCH::ChartCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandChartMediatorUpdateForEntityDelete::set_allocated_super(::TSCH::ChartCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference cmd = 3;
inline bool CommandChartMediatorUpdateForEntityDelete::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandChartMediatorUpdateForEntityDelete::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandChartMediatorUpdateForEntityDelete::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandChartMediatorUpdateForEntityDelete::clear_cmd() {
  if (cmd_ != NULL) cmd_->::TSP::Reference::Clear();
  clear_has_cmd();
}
inline const ::TSP::Reference& CommandChartMediatorUpdateForEntityDelete::cmd() const {
  return cmd_ != NULL ? *cmd_ : *default_instance_->cmd_;
}
inline ::TSP::Reference* CommandChartMediatorUpdateForEntityDelete::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == NULL) cmd_ = new ::TSP::Reference;
  return cmd_;
}
inline ::TSP::Reference* CommandChartMediatorUpdateForEntityDelete::release_cmd() {
  clear_has_cmd();
  ::TSP::Reference* temp = cmd_;
  cmd_ = NULL;
  return temp;
}
inline void CommandChartMediatorUpdateForEntityDelete::set_allocated_cmd(::TSP::Reference* cmd) {
  delete cmd_;
  cmd_ = cmd;
  if (cmd) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
}

// -------------------------------------------------------------------

// ChartCommandSetSeriesNameArchive

// required .TSCH.ChartCommandArchive super = 1;
inline bool ChartCommandSetSeriesNameArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartCommandSetSeriesNameArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartCommandSetSeriesNameArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartCommandSetSeriesNameArchive::clear_super() {
  if (super_ != NULL) super_->::TSCH::ChartCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSCH::ChartCommandArchive& ChartCommandSetSeriesNameArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSCH::ChartCommandArchive* ChartCommandSetSeriesNameArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSCH::ChartCommandArchive;
  return super_;
}
inline ::TSCH::ChartCommandArchive* ChartCommandSetSeriesNameArchive::release_super() {
  clear_has_super();
  ::TSCH::ChartCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartCommandSetSeriesNameArchive::set_allocated_super(::TSCH::ChartCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// required .TSP.Reference mediator = 2;
inline bool ChartCommandSetSeriesNameArchive::has_mediator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChartCommandSetSeriesNameArchive::set_has_mediator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChartCommandSetSeriesNameArchive::clear_has_mediator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChartCommandSetSeriesNameArchive::clear_mediator() {
  if (mediator_ != NULL) mediator_->::TSP::Reference::Clear();
  clear_has_mediator();
}
inline const ::TSP::Reference& ChartCommandSetSeriesNameArchive::mediator() const {
  return mediator_ != NULL ? *mediator_ : *default_instance_->mediator_;
}
inline ::TSP::Reference* ChartCommandSetSeriesNameArchive::mutable_mediator() {
  set_has_mediator();
  if (mediator_ == NULL) mediator_ = new ::TSP::Reference;
  return mediator_;
}
inline ::TSP::Reference* ChartCommandSetSeriesNameArchive::release_mediator() {
  clear_has_mediator();
  ::TSP::Reference* temp = mediator_;
  mediator_ = NULL;
  return temp;
}
inline void ChartCommandSetSeriesNameArchive::set_allocated_mediator(::TSP::Reference* mediator) {
  delete mediator_;
  mediator_ = mediator;
  if (mediator) {
    set_has_mediator();
  } else {
    clear_has_mediator();
  }
}

// required uint32 seriesindex = 3;
inline bool ChartCommandSetSeriesNameArchive::has_seriesindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChartCommandSetSeriesNameArchive::set_has_seriesindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChartCommandSetSeriesNameArchive::clear_has_seriesindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChartCommandSetSeriesNameArchive::clear_seriesindex() {
  seriesindex_ = 0u;
  clear_has_seriesindex();
}
inline ::google::protobuf::uint32 ChartCommandSetSeriesNameArchive::seriesindex() const {
  return seriesindex_;
}
inline void ChartCommandSetSeriesNameArchive::set_seriesindex(::google::protobuf::uint32 value) {
  set_has_seriesindex();
  seriesindex_ = value;
}

// optional .TSCE.FormulaArchive old_formula = 4;
inline bool ChartCommandSetSeriesNameArchive::has_old_formula() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChartCommandSetSeriesNameArchive::set_has_old_formula() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChartCommandSetSeriesNameArchive::clear_has_old_formula() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChartCommandSetSeriesNameArchive::clear_old_formula() {
  if (old_formula_ != NULL) old_formula_->::TSCE::FormulaArchive::Clear();
  clear_has_old_formula();
}
inline const ::TSCE::FormulaArchive& ChartCommandSetSeriesNameArchive::old_formula() const {
  return old_formula_ != NULL ? *old_formula_ : *default_instance_->old_formula_;
}
inline ::TSCE::FormulaArchive* ChartCommandSetSeriesNameArchive::mutable_old_formula() {
  set_has_old_formula();
  if (old_formula_ == NULL) old_formula_ = new ::TSCE::FormulaArchive;
  return old_formula_;
}
inline ::TSCE::FormulaArchive* ChartCommandSetSeriesNameArchive::release_old_formula() {
  clear_has_old_formula();
  ::TSCE::FormulaArchive* temp = old_formula_;
  old_formula_ = NULL;
  return temp;
}
inline void ChartCommandSetSeriesNameArchive::set_allocated_old_formula(::TSCE::FormulaArchive* old_formula) {
  delete old_formula_;
  old_formula_ = old_formula;
  if (old_formula) {
    set_has_old_formula();
  } else {
    clear_has_old_formula();
  }
}

// optional .TSCE.FormulaArchive new_formula = 5;
inline bool ChartCommandSetSeriesNameArchive::has_new_formula() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChartCommandSetSeriesNameArchive::set_has_new_formula() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChartCommandSetSeriesNameArchive::clear_has_new_formula() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChartCommandSetSeriesNameArchive::clear_new_formula() {
  if (new_formula_ != NULL) new_formula_->::TSCE::FormulaArchive::Clear();
  clear_has_new_formula();
}
inline const ::TSCE::FormulaArchive& ChartCommandSetSeriesNameArchive::new_formula() const {
  return new_formula_ != NULL ? *new_formula_ : *default_instance_->new_formula_;
}
inline ::TSCE::FormulaArchive* ChartCommandSetSeriesNameArchive::mutable_new_formula() {
  set_has_new_formula();
  if (new_formula_ == NULL) new_formula_ = new ::TSCE::FormulaArchive;
  return new_formula_;
}
inline ::TSCE::FormulaArchive* ChartCommandSetSeriesNameArchive::release_new_formula() {
  clear_has_new_formula();
  ::TSCE::FormulaArchive* temp = new_formula_;
  new_formula_ = NULL;
  return temp;
}
inline void ChartCommandSetSeriesNameArchive::set_allocated_new_formula(::TSCE::FormulaArchive* new_formula) {
  delete new_formula_;
  new_formula_ = new_formula;
  if (new_formula) {
    set_has_new_formula();
  } else {
    clear_has_new_formula();
  }
}

// -------------------------------------------------------------------

// ChartCommandSelectionBehaviorArchive

// required .TSP.Reference drawable_info = 1;
inline bool ChartCommandSelectionBehaviorArchive::has_drawable_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartCommandSelectionBehaviorArchive::set_has_drawable_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_has_drawable_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_drawable_info() {
  if (drawable_info_ != NULL) drawable_info_->::TSP::Reference::Clear();
  clear_has_drawable_info();
}
inline const ::TSP::Reference& ChartCommandSelectionBehaviorArchive::drawable_info() const {
  return drawable_info_ != NULL ? *drawable_info_ : *default_instance_->drawable_info_;
}
inline ::TSP::Reference* ChartCommandSelectionBehaviorArchive::mutable_drawable_info() {
  set_has_drawable_info();
  if (drawable_info_ == NULL) drawable_info_ = new ::TSP::Reference;
  return drawable_info_;
}
inline ::TSP::Reference* ChartCommandSelectionBehaviorArchive::release_drawable_info() {
  clear_has_drawable_info();
  ::TSP::Reference* temp = drawable_info_;
  drawable_info_ = NULL;
  return temp;
}
inline void ChartCommandSelectionBehaviorArchive::set_allocated_drawable_info(::TSP::Reference* drawable_info) {
  delete drawable_info_;
  drawable_info_ = drawable_info;
  if (drawable_info) {
    set_has_drawable_info();
  } else {
    clear_has_drawable_info();
  }
}

// optional .TN.ChartSelectionArchive begin_selection = 2;
inline bool ChartCommandSelectionBehaviorArchive::has_begin_selection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChartCommandSelectionBehaviorArchive::set_has_begin_selection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_has_begin_selection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_begin_selection() {
  if (begin_selection_ != NULL) begin_selection_->::TN::ChartSelectionArchive::Clear();
  clear_has_begin_selection();
}
inline const ::TN::ChartSelectionArchive& ChartCommandSelectionBehaviorArchive::begin_selection() const {
  return begin_selection_ != NULL ? *begin_selection_ : *default_instance_->begin_selection_;
}
inline ::TN::ChartSelectionArchive* ChartCommandSelectionBehaviorArchive::mutable_begin_selection() {
  set_has_begin_selection();
  if (begin_selection_ == NULL) begin_selection_ = new ::TN::ChartSelectionArchive;
  return begin_selection_;
}
inline ::TN::ChartSelectionArchive* ChartCommandSelectionBehaviorArchive::release_begin_selection() {
  clear_has_begin_selection();
  ::TN::ChartSelectionArchive* temp = begin_selection_;
  begin_selection_ = NULL;
  return temp;
}
inline void ChartCommandSelectionBehaviorArchive::set_allocated_begin_selection(::TN::ChartSelectionArchive* begin_selection) {
  delete begin_selection_;
  begin_selection_ = begin_selection;
  if (begin_selection) {
    set_has_begin_selection();
  } else {
    clear_has_begin_selection();
  }
}

// optional .TN.ChartSelectionArchive end_selection = 3;
inline bool ChartCommandSelectionBehaviorArchive::has_end_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChartCommandSelectionBehaviorArchive::set_has_end_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_has_end_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChartCommandSelectionBehaviorArchive::clear_end_selection() {
  if (end_selection_ != NULL) end_selection_->::TN::ChartSelectionArchive::Clear();
  clear_has_end_selection();
}
inline const ::TN::ChartSelectionArchive& ChartCommandSelectionBehaviorArchive::end_selection() const {
  return end_selection_ != NULL ? *end_selection_ : *default_instance_->end_selection_;
}
inline ::TN::ChartSelectionArchive* ChartCommandSelectionBehaviorArchive::mutable_end_selection() {
  set_has_end_selection();
  if (end_selection_ == NULL) end_selection_ = new ::TN::ChartSelectionArchive;
  return end_selection_;
}
inline ::TN::ChartSelectionArchive* ChartCommandSelectionBehaviorArchive::release_end_selection() {
  clear_has_end_selection();
  ::TN::ChartSelectionArchive* temp = end_selection_;
  end_selection_ = NULL;
  return temp;
}
inline void ChartCommandSelectionBehaviorArchive::set_allocated_end_selection(::TN::ChartSelectionArchive* end_selection) {
  delete end_selection_;
  end_selection_ = end_selection;
  if (end_selection) {
    set_has_end_selection();
  } else {
    clear_has_end_selection();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TN

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TNCommandArchives_2eproto__INCLUDED
