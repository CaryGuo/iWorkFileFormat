// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TPCommandArchives.proto

#ifndef PROTOBUF_TPCommandArchives_2eproto__INCLUDED
#define PROTOBUF_TPCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSPMessages.pb.h"
#include "TSWPArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSAArchives.pb.h"
#include "TPArchives.pb.h"
#include "TSWPCommandArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TPCommandArchives_2eproto();
void protobuf_AssignDesc_TPCommandArchives_2eproto();
void protobuf_ShutdownFile_TPCommandArchives_2eproto();

class InsertDrawablesCommandArchive;
class PasteDrawablesCommandArchive;
class PasteDrawablesCommandArchive_DrawableAndPage;
class PasteAnchoredDrawablesCommandArchive;
class MoveDrawablesPageIndexCommandArchive;
class MoveDrawablesPageIndexCommandArchive_Drawable;
class InsertSectionBreakCommandArchive;
class DeleteSectionCommandArchive;
class ReplaceSectionCommandArchive;
class ChangeSectionPropertyCommandArchive;
class SwapDrawableZOrderCommandArchive;
class SwapDrawableZOrderCommandArchive_SwapPair;
class RemoveDrawablesCommandArchive;
class RemoveDrawablesCommandArchive_DrawableInfo;
class NudgeDrawablesCommandArchive;
class ChangeHeaderFooterVisibilityCommandArchive;
class ChangeSectionMarginsCommandArchive;
class ChangeDocumentPrinterOptionsCommandArchive;
class InsertMasterDrawablesCommandArchive;
class MoveMasterDrawableZOrderCommandArchive;
class RemoveMasterDrawablesCommandArchive;
class RemoveMasterDrawablesCommandArchive_MasterDrawable;
class PasteMasterDrawablesCommandArchive;
class MoveDrawablesAttachedCommandArchive;
class MoveDrawablesAttachedCommandArchive_FloatingUndo;
class MoveDrawablesFloatingCommandArchive;
class MoveDrawablesFloatingCommandArchive_AttachedUndo;
class RemoveAnchoredDrawableCommandArchive;
class ChangeFootnoteFormatCommandArchive;
class ChangeFootnoteKindCommandArchive;
class ChangeFootnoteNumberingCommandArchive;
class ChangeFootnoteSpacingCommandArchive;
class MoveInlineDrawableAnchoredCommandArchive;
class MoveAnchoredDrawableInlineCommandArchive;
class InsertFootnoteCommandArchive;
class ToggleBodyLayoutDirectionCommandArchive;
class ChangeCTVisibilityCommandArchive;
class TrackChangesCommandArchive;
class DocumentHyphenationCommandArchive;
class DocumentLigaturesCommandArchive;
class DocumentHasBodyCommandArchive;
class PauseChangeTrackingCommandArchive;

enum ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType {
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType = 0,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType = 1
};
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(int value);
const ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MIN = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType;
const ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType;
const int ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_ARRAYSIZE = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
inline const ::std::string& ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Name(ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor(), value);
}
inline bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Parse(
    const ::std::string& name, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor(), name, value);
}
enum ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex {
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft = 0,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderCenter = 1,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight = 2
};
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(int value);
const ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MIN = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft;
const ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight;
const int ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_ARRAYSIZE = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
inline const ::std::string& ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Name(ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor(), value);
}
inline bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Parse(
    const ::std::string& name, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor(), name, value);
}
enum ChangeSectionMarginsCommandArchive_SectionMargin {
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft = 0,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginRight = 1,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginTop = 2,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginBottom = 3,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginHeader = 4,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter = 5
};
bool ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(int value);
const ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MIN = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft;
const ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter;
const int ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_ARRAYSIZE = ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
inline const ::std::string& ChangeSectionMarginsCommandArchive_SectionMargin_Name(ChangeSectionMarginsCommandArchive_SectionMargin value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeSectionMarginsCommandArchive_SectionMargin_descriptor(), value);
}
inline bool ChangeSectionMarginsCommandArchive_SectionMargin_Parse(
    const ::std::string& name, ChangeSectionMarginsCommandArchive_SectionMargin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeSectionMarginsCommandArchive_SectionMargin>(
    ChangeSectionMarginsCommandArchive_SectionMargin_descriptor(), name, value);
}
enum ChangeFootnoteFormatCommandArchive_FootnoteFormat {
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric = 0,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatRoman = 1,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatSymbolic = 2,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseNumeric = 3,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic = 4
};
bool ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(int value);
const ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MIN = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric;
const ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic;
const int ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_ARRAYSIZE = ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
inline const ::std::string& ChangeFootnoteFormatCommandArchive_FootnoteFormat_Name(ChangeFootnoteFormatCommandArchive_FootnoteFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor(), value);
}
inline bool ChangeFootnoteFormatCommandArchive_FootnoteFormat_Parse(
    const ::std::string& name, ChangeFootnoteFormatCommandArchive_FootnoteFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeFootnoteFormatCommandArchive_FootnoteFormat>(
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor(), name, value);
}
enum ChangeFootnoteKindCommandArchive_FootnoteKind {
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes = 0,
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindDocumentEndnotes = 1,
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes = 2
};
bool ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(int value);
const ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MIN = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes;
const ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes;
const int ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_ARRAYSIZE = ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
inline const ::std::string& ChangeFootnoteKindCommandArchive_FootnoteKind_Name(ChangeFootnoteKindCommandArchive_FootnoteKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor(), value);
}
inline bool ChangeFootnoteKindCommandArchive_FootnoteKind_Parse(
    const ::std::string& name, ChangeFootnoteKindCommandArchive_FootnoteKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeFootnoteKindCommandArchive_FootnoteKind>(
    ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor(), name, value);
}
enum ChangeFootnoteNumberingCommandArchive_FootnoteNumbering {
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous = 0,
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachPage = 1,
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection = 2
};
bool ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(int value);
const ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MIN = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous;
const ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection;
const int ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_ARRAYSIZE = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
inline const ::std::string& ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Name(ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor(), value);
}
inline bool ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Parse(
    const ::std::string& name, ChangeFootnoteNumberingCommandArchive_FootnoteNumbering* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>(
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor(), name, value);
}
// ===================================================================

class InsertDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  InsertDrawablesCommandArchive();
  virtual ~InsertDrawablesCommandArchive();

  InsertDrawablesCommandArchive(const InsertDrawablesCommandArchive& from);

  inline InsertDrawablesCommandArchive& operator=(const InsertDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertDrawablesCommandArchive& default_instance();

  void Swap(InsertDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertDrawablesCommandArchive& from);
  void MergeFrom(const InsertDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional uint32 page_index = 2;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // optional uint32 z_order = 3;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 z_order() const;
  inline void set_z_order(::google::protobuf::uint32 value);

  // repeated .TSP.Reference drawables = 4;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 4;
  inline const ::TSP::Reference& drawables(int index) const;
  inline ::TSP::Reference* mutable_drawables(int index);
  inline ::TSP::Reference* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();

  // optional bool forPaste = 5;
  inline bool has_forpaste() const;
  inline void clear_forpaste();
  static const int kForPasteFieldNumber = 5;
  inline bool forpaste() const;
  inline void set_forpaste(bool value);

  // @@protoc_insertion_point(class_scope:TP.InsertDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_page_index();
  inline void clear_has_page_index();
  inline void set_has_z_order();
  inline void clear_has_z_order();
  inline void set_has_forpaste();
  inline void clear_has_forpaste();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::uint32 page_index_;
  ::google::protobuf::uint32 z_order_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > drawables_;
  bool forpaste_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class PasteDrawablesCommandArchive_DrawableAndPage : public ::google::protobuf::Message {
 public:
  PasteDrawablesCommandArchive_DrawableAndPage();
  virtual ~PasteDrawablesCommandArchive_DrawableAndPage();

  PasteDrawablesCommandArchive_DrawableAndPage(const PasteDrawablesCommandArchive_DrawableAndPage& from);

  inline PasteDrawablesCommandArchive_DrawableAndPage& operator=(const PasteDrawablesCommandArchive_DrawableAndPage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteDrawablesCommandArchive_DrawableAndPage& default_instance();

  void Swap(PasteDrawablesCommandArchive_DrawableAndPage* other);

  // implements Message ----------------------------------------------

  PasteDrawablesCommandArchive_DrawableAndPage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteDrawablesCommandArchive_DrawableAndPage& from);
  void MergeFrom(const PasteDrawablesCommandArchive_DrawableAndPage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional uint32 page_index = 2;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.PasteDrawablesCommandArchive.DrawableAndPage)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_page_index();
  inline void clear_has_page_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::google::protobuf::uint32 page_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteDrawablesCommandArchive_DrawableAndPage* default_instance_;
};
// -------------------------------------------------------------------

class PasteDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  PasteDrawablesCommandArchive();
  virtual ~PasteDrawablesCommandArchive();

  PasteDrawablesCommandArchive(const PasteDrawablesCommandArchive& from);

  inline PasteDrawablesCommandArchive& operator=(const PasteDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteDrawablesCommandArchive& default_instance();

  void Swap(PasteDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  PasteDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteDrawablesCommandArchive& from);
  void MergeFrom(const PasteDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PasteDrawablesCommandArchive_DrawableAndPage DrawableAndPage;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 2;
  inline const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& drawables(int index) const;
  inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* mutable_drawables(int index);
  inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >*
      mutable_drawables();

  // @@protoc_insertion_point(class_scope:TP.PasteDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage > drawables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class PasteAnchoredDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  PasteAnchoredDrawablesCommandArchive();
  virtual ~PasteAnchoredDrawablesCommandArchive();

  PasteAnchoredDrawablesCommandArchive(const PasteAnchoredDrawablesCommandArchive& from);

  inline PasteAnchoredDrawablesCommandArchive& operator=(const PasteAnchoredDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteAnchoredDrawablesCommandArchive& default_instance();

  void Swap(PasteAnchoredDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  PasteAnchoredDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteAnchoredDrawablesCommandArchive& from);
  void MergeFrom(const PasteAnchoredDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandGroupArchive deprecated_super = 1;
  inline bool has_deprecated_super() const;
  inline void clear_deprecated_super();
  static const int kDeprecatedSuperFieldNumber = 1;
  inline const ::TSK::CommandGroupArchive& deprecated_super() const;
  inline ::TSK::CommandGroupArchive* mutable_deprecated_super();
  inline ::TSK::CommandGroupArchive* release_deprecated_super();
  inline void set_allocated_deprecated_super(::TSK::CommandGroupArchive* deprecated_super);

  // optional .TSK.CommandArchive super = 4;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 4;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool select = 2;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 2;
  inline bool select() const;
  inline void set_select(bool value);

  // optional .TSP.Reference deprecated_undo_selection = 3;
  inline bool has_deprecated_undo_selection() const;
  inline void clear_deprecated_undo_selection();
  static const int kDeprecatedUndoSelectionFieldNumber = 3;
  inline const ::TSP::Reference& deprecated_undo_selection() const;
  inline ::TSP::Reference* mutable_deprecated_undo_selection();
  inline ::TSP::Reference* release_deprecated_undo_selection();
  inline void set_allocated_deprecated_undo_selection(::TSP::Reference* deprecated_undo_selection);

  // optional .TSP.Reference canvas_selection = 5;
  inline bool has_canvas_selection() const;
  inline void clear_canvas_selection();
  static const int kCanvasSelectionFieldNumber = 5;
  inline const ::TSP::Reference& canvas_selection() const;
  inline ::TSP::Reference* mutable_canvas_selection();
  inline ::TSP::Reference* release_canvas_selection();
  inline void set_allocated_canvas_selection(::TSP::Reference* canvas_selection);

  // @@protoc_insertion_point(class_scope:TP.PasteAnchoredDrawablesCommandArchive)
 private:
  inline void set_has_deprecated_super();
  inline void clear_has_deprecated_super();
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_select();
  inline void clear_has_select();
  inline void set_has_deprecated_undo_selection();
  inline void clear_has_deprecated_undo_selection();
  inline void set_has_canvas_selection();
  inline void clear_has_canvas_selection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandGroupArchive* deprecated_super_;
  ::TSK::CommandArchive* super_;
  ::TSP::Reference* deprecated_undo_selection_;
  ::TSP::Reference* canvas_selection_;
  bool select_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteAnchoredDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesPageIndexCommandArchive_Drawable : public ::google::protobuf::Message {
 public:
  MoveDrawablesPageIndexCommandArchive_Drawable();
  virtual ~MoveDrawablesPageIndexCommandArchive_Drawable();

  MoveDrawablesPageIndexCommandArchive_Drawable(const MoveDrawablesPageIndexCommandArchive_Drawable& from);

  inline MoveDrawablesPageIndexCommandArchive_Drawable& operator=(const MoveDrawablesPageIndexCommandArchive_Drawable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesPageIndexCommandArchive_Drawable& default_instance();

  void Swap(MoveDrawablesPageIndexCommandArchive_Drawable* other);

  // implements Message ----------------------------------------------

  MoveDrawablesPageIndexCommandArchive_Drawable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesPageIndexCommandArchive_Drawable& from);
  void MergeFrom(const MoveDrawablesPageIndexCommandArchive_Drawable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional uint32 z_order = 2;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 2;
  inline ::google::protobuf::uint32 z_order() const;
  inline void set_z_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_z_order();
  inline void clear_has_z_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::google::protobuf::uint32 z_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesPageIndexCommandArchive_Drawable* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesPageIndexCommandArchive : public ::google::protobuf::Message {
 public:
  MoveDrawablesPageIndexCommandArchive();
  virtual ~MoveDrawablesPageIndexCommandArchive();

  MoveDrawablesPageIndexCommandArchive(const MoveDrawablesPageIndexCommandArchive& from);

  inline MoveDrawablesPageIndexCommandArchive& operator=(const MoveDrawablesPageIndexCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesPageIndexCommandArchive& default_instance();

  void Swap(MoveDrawablesPageIndexCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveDrawablesPageIndexCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesPageIndexCommandArchive& from);
  void MergeFrom(const MoveDrawablesPageIndexCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesPageIndexCommandArchive_Drawable Drawable;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional uint32 page_index = 2;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 3;
  inline const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& drawables(int index) const;
  inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* mutable_drawables(int index);
  inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >*
      mutable_drawables();

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesPageIndexCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_page_index();
  inline void clear_has_page_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable > drawables_;
  ::google::protobuf::uint32 page_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesPageIndexCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertSectionBreakCommandArchive : public ::google::protobuf::Message {
 public:
  InsertSectionBreakCommandArchive();
  virtual ~InsertSectionBreakCommandArchive();

  InsertSectionBreakCommandArchive(const InsertSectionBreakCommandArchive& from);

  inline InsertSectionBreakCommandArchive& operator=(const InsertSectionBreakCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertSectionBreakCommandArchive& default_instance();

  void Swap(InsertSectionBreakCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertSectionBreakCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertSectionBreakCommandArchive& from);
  void MergeFrom(const InsertSectionBreakCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.TextCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextCommandArchive& super() const;
  inline ::TSWP::TextCommandArchive* mutable_super();
  inline ::TSWP::TextCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::TextCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TP.InsertSectionBreakCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertSectionBreakCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSectionCommandArchive : public ::google::protobuf::Message {
 public:
  DeleteSectionCommandArchive();
  virtual ~DeleteSectionCommandArchive();

  DeleteSectionCommandArchive(const DeleteSectionCommandArchive& from);

  inline DeleteSectionCommandArchive& operator=(const DeleteSectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSectionCommandArchive& default_instance();

  void Swap(DeleteSectionCommandArchive* other);

  // implements Message ----------------------------------------------

  DeleteSectionCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteSectionCommandArchive& from);
  void MergeFrom(const DeleteSectionCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TP.DeleteSectionCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DeleteSectionCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceSectionCommandArchive : public ::google::protobuf::Message {
 public:
  ReplaceSectionCommandArchive();
  virtual ~ReplaceSectionCommandArchive();

  ReplaceSectionCommandArchive(const ReplaceSectionCommandArchive& from);

  inline ReplaceSectionCommandArchive& operator=(const ReplaceSectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceSectionCommandArchive& default_instance();

  void Swap(ReplaceSectionCommandArchive* other);

  // implements Message ----------------------------------------------

  ReplaceSectionCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceSectionCommandArchive& from);
  void MergeFrom(const ReplaceSectionCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.TextCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextCommandArchive& super() const;
  inline ::TSWP::TextCommandArchive* mutable_super();
  inline ::TSWP::TextCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::TextCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TP.ReplaceSectionCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ReplaceSectionCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeSectionPropertyCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeSectionPropertyCommandArchive();
  virtual ~ChangeSectionPropertyCommandArchive();

  ChangeSectionPropertyCommandArchive(const ChangeSectionPropertyCommandArchive& from);

  inline ChangeSectionPropertyCommandArchive& operator=(const ChangeSectionPropertyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeSectionPropertyCommandArchive& default_instance();

  void Swap(ChangeSectionPropertyCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeSectionPropertyCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeSectionPropertyCommandArchive& from);
  void MergeFrom(const ChangeSectionPropertyCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional uint32 section_index = 2;
  inline bool has_section_index() const;
  inline void clear_section_index();
  static const int kSectionIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 section_index() const;
  inline void set_section_index(::google::protobuf::uint32 value);

  // optional string section_property = 3;
  inline bool has_section_property() const;
  inline void clear_section_property();
  static const int kSectionPropertyFieldNumber = 3;
  inline const ::std::string& section_property() const;
  inline void set_section_property(const ::std::string& value);
  inline void set_section_property(const char* value);
  inline void set_section_property(const char* value, size_t size);
  inline ::std::string* mutable_section_property();
  inline ::std::string* release_section_property();
  inline void set_allocated_section_property(::std::string* section_property);

  // optional bool section_value_bool = 4;
  inline bool has_section_value_bool() const;
  inline void clear_section_value_bool();
  static const int kSectionValueBoolFieldNumber = 4;
  inline bool section_value_bool() const;
  inline void set_section_value_bool(bool value);

  // @@protoc_insertion_point(class_scope:TP.ChangeSectionPropertyCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_section_index();
  inline void clear_has_section_index();
  inline void set_has_section_property();
  inline void clear_has_section_property();
  inline void set_has_section_value_bool();
  inline void clear_has_section_value_bool();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::std::string* section_property_;
  ::google::protobuf::uint32 section_index_;
  bool section_value_bool_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeSectionPropertyCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class SwapDrawableZOrderCommandArchive_SwapPair : public ::google::protobuf::Message {
 public:
  SwapDrawableZOrderCommandArchive_SwapPair();
  virtual ~SwapDrawableZOrderCommandArchive_SwapPair();

  SwapDrawableZOrderCommandArchive_SwapPair(const SwapDrawableZOrderCommandArchive_SwapPair& from);

  inline SwapDrawableZOrderCommandArchive_SwapPair& operator=(const SwapDrawableZOrderCommandArchive_SwapPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapDrawableZOrderCommandArchive_SwapPair& default_instance();

  void Swap(SwapDrawableZOrderCommandArchive_SwapPair* other);

  // implements Message ----------------------------------------------

  SwapDrawableZOrderCommandArchive_SwapPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapDrawableZOrderCommandArchive_SwapPair& from);
  void MergeFrom(const SwapDrawableZOrderCommandArchive_SwapPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 z_order_1 = 1;
  inline bool has_z_order_1() const;
  inline void clear_z_order_1();
  static const int kZOrder1FieldNumber = 1;
  inline ::google::protobuf::uint32 z_order_1() const;
  inline void set_z_order_1(::google::protobuf::uint32 value);

  // required uint32 z_order_2 = 2;
  inline bool has_z_order_2() const;
  inline void clear_z_order_2();
  static const int kZOrder2FieldNumber = 2;
  inline ::google::protobuf::uint32 z_order_2() const;
  inline void set_z_order_2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.SwapDrawableZOrderCommandArchive.SwapPair)
 private:
  inline void set_has_z_order_1();
  inline void clear_has_z_order_1();
  inline void set_has_z_order_2();
  inline void clear_has_z_order_2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 z_order_1_;
  ::google::protobuf::uint32 z_order_2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static SwapDrawableZOrderCommandArchive_SwapPair* default_instance_;
};
// -------------------------------------------------------------------

class SwapDrawableZOrderCommandArchive : public ::google::protobuf::Message {
 public:
  SwapDrawableZOrderCommandArchive();
  virtual ~SwapDrawableZOrderCommandArchive();

  SwapDrawableZOrderCommandArchive(const SwapDrawableZOrderCommandArchive& from);

  inline SwapDrawableZOrderCommandArchive& operator=(const SwapDrawableZOrderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapDrawableZOrderCommandArchive& default_instance();

  void Swap(SwapDrawableZOrderCommandArchive* other);

  // implements Message ----------------------------------------------

  SwapDrawableZOrderCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapDrawableZOrderCommandArchive& from);
  void MergeFrom(const SwapDrawableZOrderCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SwapDrawableZOrderCommandArchive_SwapPair SwapPair;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
  inline int swap_pairs_size() const;
  inline void clear_swap_pairs();
  static const int kSwapPairsFieldNumber = 2;
  inline const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& swap_pairs(int index) const;
  inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* mutable_swap_pairs(int index);
  inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* add_swap_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >&
      swap_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >*
      mutable_swap_pairs();

  // @@protoc_insertion_point(class_scope:TP.SwapDrawableZOrderCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair > swap_pairs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static SwapDrawableZOrderCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDrawablesCommandArchive_DrawableInfo : public ::google::protobuf::Message {
 public:
  RemoveDrawablesCommandArchive_DrawableInfo();
  virtual ~RemoveDrawablesCommandArchive_DrawableInfo();

  RemoveDrawablesCommandArchive_DrawableInfo(const RemoveDrawablesCommandArchive_DrawableInfo& from);

  inline RemoveDrawablesCommandArchive_DrawableInfo& operator=(const RemoveDrawablesCommandArchive_DrawableInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDrawablesCommandArchive_DrawableInfo& default_instance();

  void Swap(RemoveDrawablesCommandArchive_DrawableInfo* other);

  // implements Message ----------------------------------------------

  RemoveDrawablesCommandArchive_DrawableInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDrawablesCommandArchive_DrawableInfo& from);
  void MergeFrom(const RemoveDrawablesCommandArchive_DrawableInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page_index = 1;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // optional int32 z_order = 2;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 2;
  inline ::google::protobuf::int32 z_order() const;
  inline void set_z_order(::google::protobuf::int32 value);

  // optional .TSP.Reference drawable_object = 3;
  inline bool has_drawable_object() const;
  inline void clear_drawable_object();
  static const int kDrawableObjectFieldNumber = 3;
  inline const ::TSP::Reference& drawable_object() const;
  inline ::TSP::Reference* mutable_drawable_object();
  inline ::TSP::Reference* release_drawable_object();
  inline void set_allocated_drawable_object(::TSP::Reference* drawable_object);

  // @@protoc_insertion_point(class_scope:TP.RemoveDrawablesCommandArchive.DrawableInfo)
 private:
  inline void set_has_page_index();
  inline void clear_has_page_index();
  inline void set_has_z_order();
  inline void clear_has_z_order();
  inline void set_has_drawable_object();
  inline void clear_has_drawable_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 page_index_;
  ::google::protobuf::int32 z_order_;
  ::TSP::Reference* drawable_object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveDrawablesCommandArchive_DrawableInfo* default_instance_;
};
// -------------------------------------------------------------------

class RemoveDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveDrawablesCommandArchive();
  virtual ~RemoveDrawablesCommandArchive();

  RemoveDrawablesCommandArchive(const RemoveDrawablesCommandArchive& from);

  inline RemoveDrawablesCommandArchive& operator=(const RemoveDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveDrawablesCommandArchive& default_instance();

  void Swap(RemoveDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveDrawablesCommandArchive& from);
  void MergeFrom(const RemoveDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RemoveDrawablesCommandArchive_DrawableInfo DrawableInfo;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
  inline int drawables_size() const;
  inline void clear_drawables();
  static const int kDrawablesFieldNumber = 2;
  inline const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& drawables(int index) const;
  inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* mutable_drawables(int index);
  inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* add_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >&
      drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >*
      mutable_drawables();

  // @@protoc_insertion_point(class_scope:TP.RemoveDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo > drawables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class NudgeDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  NudgeDrawablesCommandArchive();
  virtual ~NudgeDrawablesCommandArchive();

  NudgeDrawablesCommandArchive(const NudgeDrawablesCommandArchive& from);

  inline NudgeDrawablesCommandArchive& operator=(const NudgeDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NudgeDrawablesCommandArchive& default_instance();

  void Swap(NudgeDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  NudgeDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NudgeDrawablesCommandArchive& from);
  void MergeFrom(const NudgeDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference child_commands = 2;
  inline int child_commands_size() const;
  inline void clear_child_commands();
  static const int kChildCommandsFieldNumber = 2;
  inline const ::TSP::Reference& child_commands(int index) const;
  inline ::TSP::Reference* mutable_child_commands(int index);
  inline ::TSP::Reference* add_child_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      child_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_child_commands();

  // @@protoc_insertion_point(class_scope:TP.NudgeDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > child_commands_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static NudgeDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeHeaderFooterVisibilityCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeHeaderFooterVisibilityCommandArchive();
  virtual ~ChangeHeaderFooterVisibilityCommandArchive();

  ChangeHeaderFooterVisibilityCommandArchive(const ChangeHeaderFooterVisibilityCommandArchive& from);

  inline ChangeHeaderFooterVisibilityCommandArchive& operator=(const ChangeHeaderFooterVisibilityCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeHeaderFooterVisibilityCommandArchive& default_instance();

  void Swap(ChangeHeaderFooterVisibilityCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeHeaderFooterVisibilityCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeHeaderFooterVisibilityCommandArchive& from);
  void MergeFrom(const ChangeHeaderFooterVisibilityCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType TPHeaderFooterType;
  static const TPHeaderFooterType kTPHeaderType = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType;
  static const TPHeaderFooterType kTPFooterType = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType;
  static inline bool TPHeaderFooterType_IsValid(int value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(value);
  }
  static const TPHeaderFooterType TPHeaderFooterType_MIN =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MIN;
  static const TPHeaderFooterType TPHeaderFooterType_MAX =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX;
  static const int TPHeaderFooterType_ARRAYSIZE =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TPHeaderFooterType_descriptor() {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
  }
  static inline const ::std::string& TPHeaderFooterType_Name(TPHeaderFooterType value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Name(value);
  }
  static inline bool TPHeaderFooterType_Parse(const ::std::string& name,
      TPHeaderFooterType* value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Parse(name, value);
  }

  typedef ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex TPHeaderFragmentIndex;
  static const TPHeaderFragmentIndex kTPHeaderLeft = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft;
  static const TPHeaderFragmentIndex kTPHeaderCenter = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderCenter;
  static const TPHeaderFragmentIndex kTPHeaderRight = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight;
  static inline bool TPHeaderFragmentIndex_IsValid(int value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(value);
  }
  static const TPHeaderFragmentIndex TPHeaderFragmentIndex_MIN =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MIN;
  static const TPHeaderFragmentIndex TPHeaderFragmentIndex_MAX =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX;
  static const int TPHeaderFragmentIndex_ARRAYSIZE =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TPHeaderFragmentIndex_descriptor() {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
  }
  static inline const ::std::string& TPHeaderFragmentIndex_Name(TPHeaderFragmentIndex value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Name(value);
  }
  static inline bool TPHeaderFragmentIndex_Parse(const ::std::string& name,
      TPHeaderFragmentIndex* value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool visible = 2;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 2;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType type() const;
  inline void set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value);

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
  inline bool has_index_to_select() const;
  inline void clear_index_to_select();
  static const int kIndexToSelectFieldNumber = 4;
  inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex index_to_select() const;
  inline void set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value);

  // repeated .TSP.Reference storages = 5;
  inline int storages_size() const;
  inline void clear_storages();
  static const int kStoragesFieldNumber = 5;
  inline const ::TSP::Reference& storages(int index) const;
  inline ::TSP::Reference* mutable_storages(int index);
  inline ::TSP::Reference* add_storages();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      storages() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_storages();

  // @@protoc_insertion_point(class_scope:TP.ChangeHeaderFooterVisibilityCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index_to_select();
  inline void clear_has_index_to_select();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool visible_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > storages_;
  int index_to_select_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeHeaderFooterVisibilityCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeSectionMarginsCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeSectionMarginsCommandArchive();
  virtual ~ChangeSectionMarginsCommandArchive();

  ChangeSectionMarginsCommandArchive(const ChangeSectionMarginsCommandArchive& from);

  inline ChangeSectionMarginsCommandArchive& operator=(const ChangeSectionMarginsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeSectionMarginsCommandArchive& default_instance();

  void Swap(ChangeSectionMarginsCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeSectionMarginsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeSectionMarginsCommandArchive& from);
  void MergeFrom(const ChangeSectionMarginsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeSectionMarginsCommandArchive_SectionMargin SectionMargin;
  static const SectionMargin kSectionMarginLeft = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft;
  static const SectionMargin kSectionMarginRight = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginRight;
  static const SectionMargin kSectionMarginTop = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginTop;
  static const SectionMargin kSectionMarginBottom = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginBottom;
  static const SectionMargin kSectionMarginHeader = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginHeader;
  static const SectionMargin kSectionMarginFooter = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter;
  static inline bool SectionMargin_IsValid(int value) {
    return ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(value);
  }
  static const SectionMargin SectionMargin_MIN =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MIN;
  static const SectionMargin SectionMargin_MAX =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX;
  static const int SectionMargin_ARRAYSIZE =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SectionMargin_descriptor() {
    return ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
  }
  static inline const ::std::string& SectionMargin_Name(SectionMargin value) {
    return ChangeSectionMarginsCommandArchive_SectionMargin_Name(value);
  }
  static inline bool SectionMargin_Parse(const ::std::string& name,
      SectionMargin* value) {
    return ChangeSectionMarginsCommandArchive_SectionMargin_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference section = 2;
  inline bool has_section() const;
  inline void clear_section();
  static const int kSectionFieldNumber = 2;
  inline const ::TSP::Reference& section() const;
  inline ::TSP::Reference* mutable_section();
  inline ::TSP::Reference* release_section();
  inline void set_allocated_section(::TSP::Reference* section);

  // optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
  inline bool has_margin() const;
  inline void clear_margin();
  static const int kMarginFieldNumber = 3;
  inline ::TP::ChangeSectionMarginsCommandArchive_SectionMargin margin() const;
  inline void set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value);

  // optional float margin_value = 4;
  inline bool has_margin_value() const;
  inline void clear_margin_value();
  static const int kMarginValueFieldNumber = 4;
  inline float margin_value() const;
  inline void set_margin_value(float value);

  // @@protoc_insertion_point(class_scope:TP.ChangeSectionMarginsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_section();
  inline void clear_has_section();
  inline void set_has_margin();
  inline void clear_has_margin();
  inline void set_has_margin_value();
  inline void clear_has_margin_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* section_;
  int margin_;
  float margin_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeSectionMarginsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeDocumentPrinterOptionsCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeDocumentPrinterOptionsCommandArchive();
  virtual ~ChangeDocumentPrinterOptionsCommandArchive();

  ChangeDocumentPrinterOptionsCommandArchive(const ChangeDocumentPrinterOptionsCommandArchive& from);

  inline ChangeDocumentPrinterOptionsCommandArchive& operator=(const ChangeDocumentPrinterOptionsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeDocumentPrinterOptionsCommandArchive& default_instance();

  void Swap(ChangeDocumentPrinterOptionsCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeDocumentPrinterOptionsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeDocumentPrinterOptionsCommandArchive& from);
  void MergeFrom(const ChangeDocumentPrinterOptionsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference OBSOLETE_section = 2;
  inline bool has_obsolete_section() const;
  inline void clear_obsolete_section();
  static const int kOBSOLETESectionFieldNumber = 2;
  inline const ::TSP::Reference& obsolete_section() const;
  inline ::TSP::Reference* mutable_obsolete_section();
  inline ::TSP::Reference* release_obsolete_section();
  inline void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);

  // optional float paper_width = 3;
  inline bool has_paper_width() const;
  inline void clear_paper_width();
  static const int kPaperWidthFieldNumber = 3;
  inline float paper_width() const;
  inline void set_paper_width(float value);

  // optional float paper_height = 4;
  inline bool has_paper_height() const;
  inline void clear_paper_height();
  static const int kPaperHeightFieldNumber = 4;
  inline float paper_height() const;
  inline void set_paper_height(float value);

  // optional float page_scale = 5;
  inline bool has_page_scale() const;
  inline void clear_page_scale();
  static const int kPageScaleFieldNumber = 5;
  inline float page_scale() const;
  inline void set_page_scale(float value);

  // optional uint32 orientation = 6;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 6;
  inline ::google::protobuf::uint32 orientation() const;
  inline void set_orientation(::google::protobuf::uint32 value);

  // optional string printer_id = 7;
  inline bool has_printer_id() const;
  inline void clear_printer_id();
  static const int kPrinterIdFieldNumber = 7;
  inline const ::std::string& printer_id() const;
  inline void set_printer_id(const ::std::string& value);
  inline void set_printer_id(const char* value);
  inline void set_printer_id(const char* value, size_t size);
  inline ::std::string* mutable_printer_id();
  inline ::std::string* release_printer_id();
  inline void set_allocated_printer_id(::std::string* printer_id);

  // optional string paper_id = 8;
  inline bool has_paper_id() const;
  inline void clear_paper_id();
  static const int kPaperIdFieldNumber = 8;
  inline const ::std::string& paper_id() const;
  inline void set_paper_id(const ::std::string& value);
  inline void set_paper_id(const char* value);
  inline void set_paper_id(const char* value, size_t size);
  inline ::std::string* mutable_paper_id();
  inline ::std::string* release_paper_id();
  inline void set_allocated_paper_id(::std::string* paper_id);

  // @@protoc_insertion_point(class_scope:TP.ChangeDocumentPrinterOptionsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_obsolete_section();
  inline void clear_has_obsolete_section();
  inline void set_has_paper_width();
  inline void clear_has_paper_width();
  inline void set_has_paper_height();
  inline void clear_has_paper_height();
  inline void set_has_page_scale();
  inline void clear_has_page_scale();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_printer_id();
  inline void clear_has_printer_id();
  inline void set_has_paper_id();
  inline void clear_has_paper_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* obsolete_section_;
  float paper_width_;
  float paper_height_;
  float page_scale_;
  ::google::protobuf::uint32 orientation_;
  ::std::string* printer_id_;
  ::std::string* paper_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeDocumentPrinterOptionsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertMasterDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  InsertMasterDrawablesCommandArchive();
  virtual ~InsertMasterDrawablesCommandArchive();

  InsertMasterDrawablesCommandArchive(const InsertMasterDrawablesCommandArchive& from);

  inline InsertMasterDrawablesCommandArchive& operator=(const InsertMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertMasterDrawablesCommandArchive& default_instance();

  void Swap(InsertMasterDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertMasterDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertMasterDrawablesCommandArchive& from);
  void MergeFrom(const InsertMasterDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference OBSOLETE_section = 2;
  inline bool has_obsolete_section() const;
  inline void clear_obsolete_section();
  static const int kOBSOLETESectionFieldNumber = 2;
  inline const ::TSP::Reference& obsolete_section() const;
  inline ::TSP::Reference* mutable_obsolete_section();
  inline ::TSP::Reference* release_obsolete_section();
  inline void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);

  // repeated .TSP.Reference master_drawables = 3;
  inline int master_drawables_size() const;
  inline void clear_master_drawables();
  static const int kMasterDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& master_drawables(int index) const;
  inline ::TSP::Reference* mutable_master_drawables(int index);
  inline ::TSP::Reference* add_master_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();

  // optional uint32 drawable_index = 4;
  inline bool has_drawable_index() const;
  inline void clear_drawable_index();
  static const int kDrawableIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 drawable_index() const;
  inline void set_drawable_index(::google::protobuf::uint32 value);

  // optional .TSP.Reference master_drawable_provider = 5;
  inline bool has_master_drawable_provider() const;
  inline void clear_master_drawable_provider();
  static const int kMasterDrawableProviderFieldNumber = 5;
  inline const ::TSP::Reference& master_drawable_provider() const;
  inline ::TSP::Reference* mutable_master_drawable_provider();
  inline ::TSP::Reference* release_master_drawable_provider();
  inline void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);

  // @@protoc_insertion_point(class_scope:TP.InsertMasterDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_obsolete_section();
  inline void clear_has_obsolete_section();
  inline void set_has_drawable_index();
  inline void clear_has_drawable_index();
  inline void set_has_master_drawable_provider();
  inline void clear_has_master_drawable_provider();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* obsolete_section_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > master_drawables_;
  ::TSP::Reference* master_drawable_provider_;
  ::google::protobuf::uint32 drawable_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertMasterDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveMasterDrawableZOrderCommandArchive : public ::google::protobuf::Message {
 public:
  MoveMasterDrawableZOrderCommandArchive();
  virtual ~MoveMasterDrawableZOrderCommandArchive();

  MoveMasterDrawableZOrderCommandArchive(const MoveMasterDrawableZOrderCommandArchive& from);

  inline MoveMasterDrawableZOrderCommandArchive& operator=(const MoveMasterDrawableZOrderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveMasterDrawableZOrderCommandArchive& default_instance();

  void Swap(MoveMasterDrawableZOrderCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveMasterDrawableZOrderCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveMasterDrawableZOrderCommandArchive& from);
  void MergeFrom(const MoveMasterDrawableZOrderCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference OBSOLETE_section = 2;
  inline bool has_obsolete_section() const;
  inline void clear_obsolete_section();
  static const int kOBSOLETESectionFieldNumber = 2;
  inline const ::TSP::Reference& obsolete_section() const;
  inline ::TSP::Reference* mutable_obsolete_section();
  inline ::TSP::Reference* release_obsolete_section();
  inline void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);

  // repeated .TSP.Reference master_drawables = 3;
  inline int master_drawables_size() const;
  inline void clear_master_drawables();
  static const int kMasterDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& master_drawables(int index) const;
  inline ::TSP::Reference* mutable_master_drawables(int index);
  inline ::TSP::Reference* add_master_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();

  // repeated uint32 indexes = 4;
  inline int indexes_size() const;
  inline void clear_indexes();
  static const int kIndexesFieldNumber = 4;
  inline ::google::protobuf::uint32 indexes(int index) const;
  inline void set_indexes(int index, ::google::protobuf::uint32 value);
  inline void add_indexes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      indexes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_indexes();

  // optional .TSP.Reference master_drawable_provider = 5;
  inline bool has_master_drawable_provider() const;
  inline void clear_master_drawable_provider();
  static const int kMasterDrawableProviderFieldNumber = 5;
  inline const ::TSP::Reference& master_drawable_provider() const;
  inline ::TSP::Reference* mutable_master_drawable_provider();
  inline ::TSP::Reference* release_master_drawable_provider();
  inline void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);

  // @@protoc_insertion_point(class_scope:TP.MoveMasterDrawableZOrderCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_obsolete_section();
  inline void clear_has_obsolete_section();
  inline void set_has_master_drawable_provider();
  inline void clear_has_master_drawable_provider();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* obsolete_section_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > master_drawables_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > indexes_;
  ::TSP::Reference* master_drawable_provider_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveMasterDrawableZOrderCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveMasterDrawablesCommandArchive_MasterDrawable : public ::google::protobuf::Message {
 public:
  RemoveMasterDrawablesCommandArchive_MasterDrawable();
  virtual ~RemoveMasterDrawablesCommandArchive_MasterDrawable();

  RemoveMasterDrawablesCommandArchive_MasterDrawable(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from);

  inline RemoveMasterDrawablesCommandArchive_MasterDrawable& operator=(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveMasterDrawablesCommandArchive_MasterDrawable& default_instance();

  void Swap(RemoveMasterDrawablesCommandArchive_MasterDrawable* other);

  // implements Message ----------------------------------------------

  RemoveMasterDrawablesCommandArchive_MasterDrawable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from);
  void MergeFrom(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional uint32 drawable_index = 2;
  inline bool has_drawable_index() const;
  inline void clear_drawable_index();
  static const int kDrawableIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 drawable_index() const;
  inline void set_drawable_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_drawable_index();
  inline void clear_has_drawable_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::google::protobuf::uint32 drawable_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveMasterDrawablesCommandArchive_MasterDrawable* default_instance_;
};
// -------------------------------------------------------------------

class RemoveMasterDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveMasterDrawablesCommandArchive();
  virtual ~RemoveMasterDrawablesCommandArchive();

  RemoveMasterDrawablesCommandArchive(const RemoveMasterDrawablesCommandArchive& from);

  inline RemoveMasterDrawablesCommandArchive& operator=(const RemoveMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveMasterDrawablesCommandArchive& default_instance();

  void Swap(RemoveMasterDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveMasterDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveMasterDrawablesCommandArchive& from);
  void MergeFrom(const RemoveMasterDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RemoveMasterDrawablesCommandArchive_MasterDrawable MasterDrawable;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference OBSOLETE_section = 2;
  inline bool has_obsolete_section() const;
  inline void clear_obsolete_section();
  static const int kOBSOLETESectionFieldNumber = 2;
  inline const ::TSP::Reference& obsolete_section() const;
  inline ::TSP::Reference* mutable_obsolete_section();
  inline ::TSP::Reference* release_obsolete_section();
  inline void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);

  // repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
  inline int master_drawables_size() const;
  inline void clear_master_drawables();
  static const int kMasterDrawablesFieldNumber = 3;
  inline const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& master_drawables(int index) const;
  inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* mutable_master_drawables(int index);
  inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* add_master_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >&
      master_drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >*
      mutable_master_drawables();

  // optional .TSP.Reference master_drawable_provider = 4;
  inline bool has_master_drawable_provider() const;
  inline void clear_master_drawable_provider();
  static const int kMasterDrawableProviderFieldNumber = 4;
  inline const ::TSP::Reference& master_drawable_provider() const;
  inline ::TSP::Reference* mutable_master_drawable_provider();
  inline ::TSP::Reference* release_master_drawable_provider();
  inline void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);

  // @@protoc_insertion_point(class_scope:TP.RemoveMasterDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_obsolete_section();
  inline void clear_has_obsolete_section();
  inline void set_has_master_drawable_provider();
  inline void clear_has_master_drawable_provider();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* obsolete_section_;
  ::google::protobuf::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable > master_drawables_;
  ::TSP::Reference* master_drawable_provider_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveMasterDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class PasteMasterDrawablesCommandArchive : public ::google::protobuf::Message {
 public:
  PasteMasterDrawablesCommandArchive();
  virtual ~PasteMasterDrawablesCommandArchive();

  PasteMasterDrawablesCommandArchive(const PasteMasterDrawablesCommandArchive& from);

  inline PasteMasterDrawablesCommandArchive& operator=(const PasteMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PasteMasterDrawablesCommandArchive& default_instance();

  void Swap(PasteMasterDrawablesCommandArchive* other);

  // implements Message ----------------------------------------------

  PasteMasterDrawablesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PasteMasterDrawablesCommandArchive& from);
  void MergeFrom(const PasteMasterDrawablesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference section = 2;
  inline bool has_section() const;
  inline void clear_section();
  static const int kSectionFieldNumber = 2;
  inline const ::TSP::Reference& section() const;
  inline ::TSP::Reference* mutable_section();
  inline ::TSP::Reference* release_section();
  inline void set_allocated_section(::TSP::Reference* section);

  // repeated .TSP.Reference master_drawables = 3;
  inline int master_drawables_size() const;
  inline void clear_master_drawables();
  static const int kMasterDrawablesFieldNumber = 3;
  inline const ::TSP::Reference& master_drawables(int index) const;
  inline ::TSP::Reference* mutable_master_drawables(int index);
  inline ::TSP::Reference* add_master_drawables();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();

  // optional uint32 drawable_index = 4;
  inline bool has_drawable_index() const;
  inline void clear_drawable_index();
  static const int kDrawableIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 drawable_index() const;
  inline void set_drawable_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.PasteMasterDrawablesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_section();
  inline void clear_has_section();
  inline void set_has_drawable_index();
  inline void clear_has_drawable_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* section_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > master_drawables_;
  ::google::protobuf::uint32 drawable_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PasteMasterDrawablesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesAttachedCommandArchive_FloatingUndo : public ::google::protobuf::Message {
 public:
  MoveDrawablesAttachedCommandArchive_FloatingUndo();
  virtual ~MoveDrawablesAttachedCommandArchive_FloatingUndo();

  MoveDrawablesAttachedCommandArchive_FloatingUndo(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from);

  inline MoveDrawablesAttachedCommandArchive_FloatingUndo& operator=(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesAttachedCommandArchive_FloatingUndo& default_instance();

  void Swap(MoveDrawablesAttachedCommandArchive_FloatingUndo* other);

  // implements Message ----------------------------------------------

  MoveDrawablesAttachedCommandArchive_FloatingUndo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from);
  void MergeFrom(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional .TSD.GeometryArchive geometry = 2;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 2;
  inline const ::TSD::GeometryArchive& geometry() const;
  inline ::TSD::GeometryArchive* mutable_geometry();
  inline ::TSD::GeometryArchive* release_geometry();
  inline void set_allocated_geometry(::TSD::GeometryArchive* geometry);

  // optional .TSP.Reference attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::TSP::Reference& attachment() const;
  inline ::TSP::Reference* mutable_attachment();
  inline ::TSP::Reference* release_attachment();
  inline void set_allocated_attachment(::TSP::Reference* attachment);

  // optional uint32 wrap_type = 4;
  inline bool has_wrap_type() const;
  inline void clear_wrap_type();
  static const int kWrapTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 wrap_type() const;
  inline void set_wrap_type(::google::protobuf::uint32 value);

  // optional uint32 page_index = 5;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // optional int32 z_order = 6;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 6;
  inline ::google::protobuf::int32 z_order() const;
  inline void set_z_order(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_wrap_type();
  inline void clear_has_wrap_type();
  inline void set_has_page_index();
  inline void clear_has_page_index();
  inline void set_has_z_order();
  inline void clear_has_z_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* attachment_;
  ::google::protobuf::uint32 wrap_type_;
  ::google::protobuf::uint32 page_index_;
  ::google::protobuf::int32 z_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesAttachedCommandArchive_FloatingUndo* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesAttachedCommandArchive : public ::google::protobuf::Message {
 public:
  MoveDrawablesAttachedCommandArchive();
  virtual ~MoveDrawablesAttachedCommandArchive();

  MoveDrawablesAttachedCommandArchive(const MoveDrawablesAttachedCommandArchive& from);

  inline MoveDrawablesAttachedCommandArchive& operator=(const MoveDrawablesAttachedCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesAttachedCommandArchive& default_instance();

  void Swap(MoveDrawablesAttachedCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveDrawablesAttachedCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesAttachedCommandArchive& from);
  void MergeFrom(const MoveDrawablesAttachedCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesAttachedCommandArchive_FloatingUndo FloatingUndo;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSWP.UndoTransaction undo_transaction = 2;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 2;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
  inline int floating_undo_size() const;
  inline void clear_floating_undo();
  static const int kFloatingUndoFieldNumber = 3;
  inline const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& floating_undo(int index) const;
  inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* mutable_floating_undo(int index);
  inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* add_floating_undo();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >&
      floating_undo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >*
      mutable_floating_undo();

  // optional bool select = 4;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 4;
  inline bool select() const;
  inline void set_select(bool value);

  // optional bool make_inline = 5;
  inline bool has_make_inline() const;
  inline void clear_make_inline();
  static const int kMakeInlineFieldNumber = 5;
  inline bool make_inline() const;
  inline void set_make_inline(bool value);

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesAttachedCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_select();
  inline void clear_has_select();
  inline void set_has_make_inline();
  inline void clear_has_make_inline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo > floating_undo_;
  bool select_;
  bool make_inline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesAttachedCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesFloatingCommandArchive_AttachedUndo : public ::google::protobuf::Message {
 public:
  MoveDrawablesFloatingCommandArchive_AttachedUndo();
  virtual ~MoveDrawablesFloatingCommandArchive_AttachedUndo();

  MoveDrawablesFloatingCommandArchive_AttachedUndo(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from);

  inline MoveDrawablesFloatingCommandArchive_AttachedUndo& operator=(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesFloatingCommandArchive_AttachedUndo& default_instance();

  void Swap(MoveDrawablesFloatingCommandArchive_AttachedUndo* other);

  // implements Message ----------------------------------------------

  MoveDrawablesFloatingCommandArchive_AttachedUndo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from);
  void MergeFrom(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference drawable = 1;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 1;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional .TSD.GeometryArchive geometry = 2;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 2;
  inline const ::TSD::GeometryArchive& geometry() const;
  inline ::TSD::GeometryArchive* mutable_geometry();
  inline ::TSD::GeometryArchive* release_geometry();
  inline void set_allocated_geometry(::TSD::GeometryArchive* geometry);

  // optional .TSP.Reference attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::TSP::Reference& attachment() const;
  inline ::TSP::Reference* mutable_attachment();
  inline ::TSP::Reference* release_attachment();
  inline void set_allocated_attachment(::TSP::Reference* attachment);

  // optional uint32 page_index = 4;
  inline bool has_page_index() const;
  inline void clear_page_index();
  static const int kPageIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 page_index() const;
  inline void set_page_index(::google::protobuf::uint32 value);

  // optional bool is_html_wrap = 5;
  inline bool has_is_html_wrap() const;
  inline void clear_is_html_wrap();
  static const int kIsHtmlWrapFieldNumber = 5;
  inline bool is_html_wrap() const;
  inline void set_is_html_wrap(bool value);

  // optional uint32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 direction = 7;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 7;
  inline ::google::protobuf::uint32 direction() const;
  inline void set_direction(::google::protobuf::uint32 value);

  // optional uint32 fit_type = 8;
  inline bool has_fit_type() const;
  inline void clear_fit_type();
  static const int kFitTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 fit_type() const;
  inline void set_fit_type(::google::protobuf::uint32 value);

  // optional float margin = 9;
  inline bool has_margin() const;
  inline void clear_margin();
  static const int kMarginFieldNumber = 9;
  inline float margin() const;
  inline void set_margin(float value);

  // optional float alpha_threshold = 10;
  inline bool has_alpha_threshold() const;
  inline void clear_alpha_threshold();
  static const int kAlphaThresholdFieldNumber = 10;
  inline float alpha_threshold() const;
  inline void set_alpha_threshold(float value);

  // optional .TSP.Reference storage = 11;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 11;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 12;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 12;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
 private:
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_page_index();
  inline void clear_has_page_index();
  inline void set_has_is_html_wrap();
  inline void clear_has_is_html_wrap();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_fit_type();
  inline void clear_has_fit_type();
  inline void set_has_margin();
  inline void clear_has_margin();
  inline void set_has_alpha_threshold();
  inline void clear_has_alpha_threshold();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* drawable_;
  ::TSD::GeometryArchive* geometry_;
  ::TSP::Reference* attachment_;
  ::google::protobuf::uint32 page_index_;
  bool is_html_wrap_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 fit_type_;
  float margin_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;
  float alpha_threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesFloatingCommandArchive_AttachedUndo* default_instance_;
};
// -------------------------------------------------------------------

class MoveDrawablesFloatingCommandArchive : public ::google::protobuf::Message {
 public:
  MoveDrawablesFloatingCommandArchive();
  virtual ~MoveDrawablesFloatingCommandArchive();

  MoveDrawablesFloatingCommandArchive(const MoveDrawablesFloatingCommandArchive& from);

  inline MoveDrawablesFloatingCommandArchive& operator=(const MoveDrawablesFloatingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveDrawablesFloatingCommandArchive& default_instance();

  void Swap(MoveDrawablesFloatingCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveDrawablesFloatingCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveDrawablesFloatingCommandArchive& from);
  void MergeFrom(const MoveDrawablesFloatingCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesFloatingCommandArchive_AttachedUndo AttachedUndo;

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
  inline bool has_deprecated_undo_transaction() const;
  inline void clear_deprecated_undo_transaction();
  static const int kDeprecatedUndoTransactionFieldNumber = 2;
  inline const ::TSWP::UndoTransaction& deprecated_undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_deprecated_undo_transaction();
  inline ::TSWP::UndoTransaction* release_deprecated_undo_transaction();
  inline void set_allocated_deprecated_undo_transaction(::TSWP::UndoTransaction* deprecated_undo_transaction);

  // repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
  inline int attached_undo_size() const;
  inline void clear_attached_undo();
  static const int kAttachedUndoFieldNumber = 3;
  inline const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& attached_undo(int index) const;
  inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* mutable_attached_undo(int index);
  inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* add_attached_undo();
  inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >&
      attached_undo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >*
      mutable_attached_undo();

  // optional bool select = 4;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 4;
  inline bool select() const;
  inline void set_select(bool value);

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesFloatingCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_deprecated_undo_transaction();
  inline void clear_has_deprecated_undo_transaction();
  inline void set_has_select();
  inline void clear_has_select();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSWP::UndoTransaction* deprecated_undo_transaction_;
  ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo > attached_undo_;
  bool select_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveDrawablesFloatingCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveAnchoredDrawableCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveAnchoredDrawableCommandArchive();
  virtual ~RemoveAnchoredDrawableCommandArchive();

  RemoveAnchoredDrawableCommandArchive(const RemoveAnchoredDrawableCommandArchive& from);

  inline RemoveAnchoredDrawableCommandArchive& operator=(const RemoveAnchoredDrawableCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveAnchoredDrawableCommandArchive& default_instance();

  void Swap(RemoveAnchoredDrawableCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveAnchoredDrawableCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveAnchoredDrawableCommandArchive& from);
  void MergeFrom(const RemoveAnchoredDrawableCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.TextCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextCommandArchive& super() const;
  inline ::TSWP::TextCommandArchive* mutable_super();
  inline ::TSWP::TextCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::TextCommandArchive* super);

  // optional uint32 char_index = 2;
  inline bool has_char_index() const;
  inline void clear_char_index();
  static const int kCharIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 char_index() const;
  inline void set_char_index(::google::protobuf::uint32 value);

  // optional uint32 z_order = 3;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 3;
  inline ::google::protobuf::uint32 z_order() const;
  inline void set_z_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.RemoveAnchoredDrawableCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_char_index();
  inline void clear_has_char_index();
  inline void set_has_z_order();
  inline void clear_has_z_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextCommandArchive* super_;
  ::google::protobuf::uint32 char_index_;
  ::google::protobuf::uint32 z_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveAnchoredDrawableCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFootnoteFormatCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeFootnoteFormatCommandArchive();
  virtual ~ChangeFootnoteFormatCommandArchive();

  ChangeFootnoteFormatCommandArchive(const ChangeFootnoteFormatCommandArchive& from);

  inline ChangeFootnoteFormatCommandArchive& operator=(const ChangeFootnoteFormatCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFootnoteFormatCommandArchive& default_instance();

  void Swap(ChangeFootnoteFormatCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeFootnoteFormatCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFootnoteFormatCommandArchive& from);
  void MergeFrom(const ChangeFootnoteFormatCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteFormatCommandArchive_FootnoteFormat FootnoteFormat;
  static const FootnoteFormat kFootnoteFormatNumeric = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric;
  static const FootnoteFormat kFootnoteFormatRoman = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatRoman;
  static const FootnoteFormat kFootnoteFormatSymbolic = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatSymbolic;
  static const FootnoteFormat kFootnoteFormatJapaneseNumeric = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseNumeric;
  static const FootnoteFormat kFootnoteFormatJapaneseIdeographic = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic;
  static inline bool FootnoteFormat_IsValid(int value) {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(value);
  }
  static const FootnoteFormat FootnoteFormat_MIN =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MIN;
  static const FootnoteFormat FootnoteFormat_MAX =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX;
  static const int FootnoteFormat_ARRAYSIZE =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootnoteFormat_descriptor() {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
  }
  static inline const ::std::string& FootnoteFormat_Name(FootnoteFormat value) {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_Name(value);
  }
  static inline bool FootnoteFormat_Parse(const ::std::string& name,
      FootnoteFormat* value) {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat format() const;
  inline void set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value);

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteFormatCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  int format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeFootnoteFormatCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFootnoteKindCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeFootnoteKindCommandArchive();
  virtual ~ChangeFootnoteKindCommandArchive();

  ChangeFootnoteKindCommandArchive(const ChangeFootnoteKindCommandArchive& from);

  inline ChangeFootnoteKindCommandArchive& operator=(const ChangeFootnoteKindCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFootnoteKindCommandArchive& default_instance();

  void Swap(ChangeFootnoteKindCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeFootnoteKindCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFootnoteKindCommandArchive& from);
  void MergeFrom(const ChangeFootnoteKindCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteKindCommandArchive_FootnoteKind FootnoteKind;
  static const FootnoteKind kFootnoteKindFootnotes = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes;
  static const FootnoteKind kFootnoteKindDocumentEndnotes = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindDocumentEndnotes;
  static const FootnoteKind kFootnoteKindSectionEndnotes = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes;
  static inline bool FootnoteKind_IsValid(int value) {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(value);
  }
  static const FootnoteKind FootnoteKind_MIN =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MIN;
  static const FootnoteKind FootnoteKind_MAX =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX;
  static const int FootnoteKind_ARRAYSIZE =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootnoteKind_descriptor() {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
  }
  static inline const ::std::string& FootnoteKind_Name(FootnoteKind value) {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_Name(value);
  }
  static inline bool FootnoteKind_Parse(const ::std::string& name,
      FootnoteKind* value) {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 2;
  inline ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind kind() const;
  inline void set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteKindCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSWP::UndoTransaction* undo_transaction_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeFootnoteKindCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFootnoteNumberingCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeFootnoteNumberingCommandArchive();
  virtual ~ChangeFootnoteNumberingCommandArchive();

  ChangeFootnoteNumberingCommandArchive(const ChangeFootnoteNumberingCommandArchive& from);

  inline ChangeFootnoteNumberingCommandArchive& operator=(const ChangeFootnoteNumberingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFootnoteNumberingCommandArchive& default_instance();

  void Swap(ChangeFootnoteNumberingCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeFootnoteNumberingCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFootnoteNumberingCommandArchive& from);
  void MergeFrom(const ChangeFootnoteNumberingCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteNumberingCommandArchive_FootnoteNumbering FootnoteNumbering;
  static const FootnoteNumbering kFootnoteNumberingContinuous = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous;
  static const FootnoteNumbering kFootnoteNumberingRestartEachPage = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachPage;
  static const FootnoteNumbering kFootnoteNumberingRestartEachSection = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection;
  static inline bool FootnoteNumbering_IsValid(int value) {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(value);
  }
  static const FootnoteNumbering FootnoteNumbering_MIN =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MIN;
  static const FootnoteNumbering FootnoteNumbering_MAX =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX;
  static const int FootnoteNumbering_ARRAYSIZE =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootnoteNumbering_descriptor() {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
  }
  static inline const ::std::string& FootnoteNumbering_Name(FootnoteNumbering value) {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Name(value);
  }
  static inline bool FootnoteNumbering_Parse(const ::std::string& name,
      FootnoteNumbering* value) {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
  inline bool has_numbering() const;
  inline void clear_numbering();
  static const int kNumberingFieldNumber = 2;
  inline ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering numbering() const;
  inline void set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value);

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteNumberingCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_numbering();
  inline void clear_has_numbering();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  int numbering_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeFootnoteNumberingCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeFootnoteSpacingCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeFootnoteSpacingCommandArchive();
  virtual ~ChangeFootnoteSpacingCommandArchive();

  ChangeFootnoteSpacingCommandArchive(const ChangeFootnoteSpacingCommandArchive& from);

  inline ChangeFootnoteSpacingCommandArchive& operator=(const ChangeFootnoteSpacingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeFootnoteSpacingCommandArchive& default_instance();

  void Swap(ChangeFootnoteSpacingCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeFootnoteSpacingCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeFootnoteSpacingCommandArchive& from);
  void MergeFrom(const ChangeFootnoteSpacingCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional int32 footnote_spacing = 2;
  inline bool has_footnote_spacing() const;
  inline void clear_footnote_spacing();
  static const int kFootnoteSpacingFieldNumber = 2;
  inline ::google::protobuf::int32 footnote_spacing() const;
  inline void set_footnote_spacing(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteSpacingCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_footnote_spacing();
  inline void clear_has_footnote_spacing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::int32 footnote_spacing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeFootnoteSpacingCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveInlineDrawableAnchoredCommandArchive : public ::google::protobuf::Message {
 public:
  MoveInlineDrawableAnchoredCommandArchive();
  virtual ~MoveInlineDrawableAnchoredCommandArchive();

  MoveInlineDrawableAnchoredCommandArchive(const MoveInlineDrawableAnchoredCommandArchive& from);

  inline MoveInlineDrawableAnchoredCommandArchive& operator=(const MoveInlineDrawableAnchoredCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveInlineDrawableAnchoredCommandArchive& default_instance();

  void Swap(MoveInlineDrawableAnchoredCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveInlineDrawableAnchoredCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveInlineDrawableAnchoredCommandArchive& from);
  void MergeFrom(const MoveInlineDrawableAnchoredCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference drawable = 2;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 2;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional bool is_html_wrap = 3;
  inline bool has_is_html_wrap() const;
  inline void clear_is_html_wrap();
  static const int kIsHtmlWrapFieldNumber = 3;
  inline bool is_html_wrap() const;
  inline void set_is_html_wrap(bool value);

  // optional uint32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::uint32 direction() const;
  inline void set_direction(::google::protobuf::uint32 value);

  // optional uint32 fit_type = 6;
  inline bool has_fit_type() const;
  inline void clear_fit_type();
  static const int kFitTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 fit_type() const;
  inline void set_fit_type(::google::protobuf::uint32 value);

  // optional float margin = 7;
  inline bool has_margin() const;
  inline void clear_margin();
  static const int kMarginFieldNumber = 7;
  inline float margin() const;
  inline void set_margin(float value);

  // optional float alpha_threshold = 8;
  inline bool has_alpha_threshold() const;
  inline void clear_alpha_threshold();
  static const int kAlphaThresholdFieldNumber = 8;
  inline float alpha_threshold() const;
  inline void set_alpha_threshold(float value);

  // @@protoc_insertion_point(class_scope:TP.MoveInlineDrawableAnchoredCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_is_html_wrap();
  inline void clear_has_is_html_wrap();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_fit_type();
  inline void clear_has_fit_type();
  inline void set_has_margin();
  inline void clear_has_margin();
  inline void set_has_alpha_threshold();
  inline void clear_has_alpha_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* drawable_;
  bool is_html_wrap_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 fit_type_;
  float margin_;
  float alpha_threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveInlineDrawableAnchoredCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveAnchoredDrawableInlineCommandArchive : public ::google::protobuf::Message {
 public:
  MoveAnchoredDrawableInlineCommandArchive();
  virtual ~MoveAnchoredDrawableInlineCommandArchive();

  MoveAnchoredDrawableInlineCommandArchive(const MoveAnchoredDrawableInlineCommandArchive& from);

  inline MoveAnchoredDrawableInlineCommandArchive& operator=(const MoveAnchoredDrawableInlineCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveAnchoredDrawableInlineCommandArchive& default_instance();

  void Swap(MoveAnchoredDrawableInlineCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveAnchoredDrawableInlineCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveAnchoredDrawableInlineCommandArchive& from);
  void MergeFrom(const MoveAnchoredDrawableInlineCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference drawable = 2;
  inline bool has_drawable() const;
  inline void clear_drawable();
  static const int kDrawableFieldNumber = 2;
  inline const ::TSP::Reference& drawable() const;
  inline ::TSP::Reference* mutable_drawable();
  inline ::TSP::Reference* release_drawable();
  inline void set_allocated_drawable(::TSP::Reference* drawable);

  // optional bool is_html_wrap = 3;
  inline bool has_is_html_wrap() const;
  inline void clear_is_html_wrap();
  static const int kIsHtmlWrapFieldNumber = 3;
  inline bool is_html_wrap() const;
  inline void set_is_html_wrap(bool value);

  // optional uint32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::uint32 direction() const;
  inline void set_direction(::google::protobuf::uint32 value);

  // optional uint32 fit_type = 6;
  inline bool has_fit_type() const;
  inline void clear_fit_type();
  static const int kFitTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 fit_type() const;
  inline void set_fit_type(::google::protobuf::uint32 value);

  // optional float margin = 7;
  inline bool has_margin() const;
  inline void clear_margin();
  static const int kMarginFieldNumber = 7;
  inline float margin() const;
  inline void set_margin(float value);

  // optional float alpha_threshold = 8;
  inline bool has_alpha_threshold() const;
  inline void clear_alpha_threshold();
  static const int kAlphaThresholdFieldNumber = 8;
  inline float alpha_threshold() const;
  inline void set_alpha_threshold(float value);

  // optional uint32 z_order = 9;
  inline bool has_z_order() const;
  inline void clear_z_order();
  static const int kZOrderFieldNumber = 9;
  inline ::google::protobuf::uint32 z_order() const;
  inline void set_z_order(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.MoveAnchoredDrawableInlineCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_drawable();
  inline void clear_has_drawable();
  inline void set_has_is_html_wrap();
  inline void clear_has_is_html_wrap();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_fit_type();
  inline void clear_has_fit_type();
  inline void set_has_margin();
  inline void clear_has_margin();
  inline void set_has_alpha_threshold();
  inline void clear_has_alpha_threshold();
  inline void set_has_z_order();
  inline void clear_has_z_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* drawable_;
  bool is_html_wrap_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 direction_;
  ::google::protobuf::uint32 fit_type_;
  float margin_;
  float alpha_threshold_;
  ::google::protobuf::uint32 z_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveAnchoredDrawableInlineCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertFootnoteCommandArchive : public ::google::protobuf::Message {
 public:
  InsertFootnoteCommandArchive();
  virtual ~InsertFootnoteCommandArchive();

  InsertFootnoteCommandArchive(const InsertFootnoteCommandArchive& from);

  inline InsertFootnoteCommandArchive& operator=(const InsertFootnoteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertFootnoteCommandArchive& default_instance();

  void Swap(InsertFootnoteCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertFootnoteCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertFootnoteCommandArchive& from);
  void MergeFrom(const InsertFootnoteCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSWP.TextCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextCommandArchive& super() const;
  inline ::TSWP::TextCommandArchive* mutable_super();
  inline ::TSWP::TextCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::TextCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TP.InsertFootnoteCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertFootnoteCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ToggleBodyLayoutDirectionCommandArchive : public ::google::protobuf::Message {
 public:
  ToggleBodyLayoutDirectionCommandArchive();
  virtual ~ToggleBodyLayoutDirectionCommandArchive();

  ToggleBodyLayoutDirectionCommandArchive(const ToggleBodyLayoutDirectionCommandArchive& from);

  inline ToggleBodyLayoutDirectionCommandArchive& operator=(const ToggleBodyLayoutDirectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToggleBodyLayoutDirectionCommandArchive& default_instance();

  void Swap(ToggleBodyLayoutDirectionCommandArchive* other);

  // implements Message ----------------------------------------------

  ToggleBodyLayoutDirectionCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToggleBodyLayoutDirectionCommandArchive& from);
  void MergeFrom(const ToggleBodyLayoutDirectionCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool new_direction_is_vertical = 2;
  inline bool has_new_direction_is_vertical() const;
  inline void clear_new_direction_is_vertical();
  static const int kNewDirectionIsVerticalFieldNumber = 2;
  inline bool new_direction_is_vertical() const;
  inline void set_new_direction_is_vertical(bool value);

  // @@protoc_insertion_point(class_scope:TP.ToggleBodyLayoutDirectionCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_new_direction_is_vertical();
  inline void clear_has_new_direction_is_vertical();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool new_direction_is_vertical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ToggleBodyLayoutDirectionCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChangeCTVisibilityCommandArchive : public ::google::protobuf::Message {
 public:
  ChangeCTVisibilityCommandArchive();
  virtual ~ChangeCTVisibilityCommandArchive();

  ChangeCTVisibilityCommandArchive(const ChangeCTVisibilityCommandArchive& from);

  inline ChangeCTVisibilityCommandArchive& operator=(const ChangeCTVisibilityCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeCTVisibilityCommandArchive& default_instance();

  void Swap(ChangeCTVisibilityCommandArchive* other);

  // implements Message ----------------------------------------------

  ChangeCTVisibilityCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeCTVisibilityCommandArchive& from);
  void MergeFrom(const ChangeCTVisibilityCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool markup_visible = 2;
  inline bool has_markup_visible() const;
  inline void clear_markup_visible();
  static const int kMarkupVisibleFieldNumber = 2;
  inline bool markup_visible() const;
  inline void set_markup_visible(bool value);

  // optional bool deletions_visible = 3;
  inline bool has_deletions_visible() const;
  inline void clear_deletions_visible();
  static const int kDeletionsVisibleFieldNumber = 3;
  inline bool deletions_visible() const;
  inline void set_deletions_visible(bool value);

  // optional uint32 selection_range_location = 4;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 5;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TP.ChangeCTVisibilityCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_markup_visible();
  inline void clear_has_markup_visible();
  inline void set_has_deletions_visible();
  inline void clear_has_deletions_visible();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool markup_visible_;
  bool deletions_visible_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ChangeCTVisibilityCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class TrackChangesCommandArchive : public ::google::protobuf::Message {
 public:
  TrackChangesCommandArchive();
  virtual ~TrackChangesCommandArchive();

  TrackChangesCommandArchive(const TrackChangesCommandArchive& from);

  inline TrackChangesCommandArchive& operator=(const TrackChangesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackChangesCommandArchive& default_instance();

  void Swap(TrackChangesCommandArchive* other);

  // implements Message ----------------------------------------------

  TrackChangesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackChangesCommandArchive& from);
  void MergeFrom(const TrackChangesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool track_changes = 2;
  inline bool has_track_changes() const;
  inline void clear_track_changes();
  static const int kTrackChangesFieldNumber = 2;
  inline bool track_changes() const;
  inline void set_track_changes(bool value);

  // repeated .TSP.Reference change_session_history = 3;
  inline int change_session_history_size() const;
  inline void clear_change_session_history();
  static const int kChangeSessionHistoryFieldNumber = 3;
  inline const ::TSP::Reference& change_session_history(int index) const;
  inline ::TSP::Reference* mutable_change_session_history(int index);
  inline ::TSP::Reference* add_change_session_history();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      change_session_history() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_change_session_history();

  // optional bool paused = 4;
  inline bool has_paused() const;
  inline void clear_paused();
  static const int kPausedFieldNumber = 4;
  inline bool paused() const;
  inline void set_paused(bool value);

  // @@protoc_insertion_point(class_scope:TP.TrackChangesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_track_changes();
  inline void clear_has_track_changes();
  inline void set_has_paused();
  inline void clear_has_paused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > change_session_history_;
  bool track_changes_;
  bool paused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TrackChangesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DocumentHyphenationCommandArchive : public ::google::protobuf::Message {
 public:
  DocumentHyphenationCommandArchive();
  virtual ~DocumentHyphenationCommandArchive();

  DocumentHyphenationCommandArchive(const DocumentHyphenationCommandArchive& from);

  inline DocumentHyphenationCommandArchive& operator=(const DocumentHyphenationCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentHyphenationCommandArchive& default_instance();

  void Swap(DocumentHyphenationCommandArchive* other);

  // implements Message ----------------------------------------------

  DocumentHyphenationCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentHyphenationCommandArchive& from);
  void MergeFrom(const DocumentHyphenationCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool hyphenate_document = 2;
  inline bool has_hyphenate_document() const;
  inline void clear_hyphenate_document();
  static const int kHyphenateDocumentFieldNumber = 2;
  inline bool hyphenate_document() const;
  inline void set_hyphenate_document(bool value);

  // @@protoc_insertion_point(class_scope:TP.DocumentHyphenationCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_hyphenate_document();
  inline void clear_has_hyphenate_document();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool hyphenate_document_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentHyphenationCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DocumentLigaturesCommandArchive : public ::google::protobuf::Message {
 public:
  DocumentLigaturesCommandArchive();
  virtual ~DocumentLigaturesCommandArchive();

  DocumentLigaturesCommandArchive(const DocumentLigaturesCommandArchive& from);

  inline DocumentLigaturesCommandArchive& operator=(const DocumentLigaturesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentLigaturesCommandArchive& default_instance();

  void Swap(DocumentLigaturesCommandArchive* other);

  // implements Message ----------------------------------------------

  DocumentLigaturesCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentLigaturesCommandArchive& from);
  void MergeFrom(const DocumentLigaturesCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool use_ligatures = 2;
  inline bool has_use_ligatures() const;
  inline void clear_use_ligatures();
  static const int kUseLigaturesFieldNumber = 2;
  inline bool use_ligatures() const;
  inline void set_use_ligatures(bool value);

  // @@protoc_insertion_point(class_scope:TP.DocumentLigaturesCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_use_ligatures();
  inline void clear_has_use_ligatures();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool use_ligatures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentLigaturesCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class DocumentHasBodyCommandArchive : public ::google::protobuf::Message {
 public:
  DocumentHasBodyCommandArchive();
  virtual ~DocumentHasBodyCommandArchive();

  DocumentHasBodyCommandArchive(const DocumentHasBodyCommandArchive& from);

  inline DocumentHasBodyCommandArchive& operator=(const DocumentHasBodyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentHasBodyCommandArchive& default_instance();

  void Swap(DocumentHasBodyCommandArchive* other);

  // implements Message ----------------------------------------------

  DocumentHasBodyCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentHasBodyCommandArchive& from);
  void MergeFrom(const DocumentHasBodyCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool has_body = 2;
  inline bool has_has_body() const;
  inline void clear_has_body();
  static const int kHasBodyFieldNumber = 2;
  inline bool has_body() const;
  inline void set_has_body(bool value);

  // @@protoc_insertion_point(class_scope:TP.DocumentHasBodyCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_has_body();
  inline void clear_has_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool has_body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentHasBodyCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class PauseChangeTrackingCommandArchive : public ::google::protobuf::Message {
 public:
  PauseChangeTrackingCommandArchive();
  virtual ~PauseChangeTrackingCommandArchive();

  PauseChangeTrackingCommandArchive(const PauseChangeTrackingCommandArchive& from);

  inline PauseChangeTrackingCommandArchive& operator=(const PauseChangeTrackingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PauseChangeTrackingCommandArchive& default_instance();

  void Swap(PauseChangeTrackingCommandArchive* other);

  // implements Message ----------------------------------------------

  PauseChangeTrackingCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PauseChangeTrackingCommandArchive& from);
  void MergeFrom(const PauseChangeTrackingCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional bool paused = 2;
  inline bool has_paused() const;
  inline void clear_paused();
  static const int kPausedFieldNumber = 2;
  inline bool paused() const;
  inline void set_paused(bool value);

  // @@protoc_insertion_point(class_scope:TP.PauseChangeTrackingCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_paused();
  inline void clear_has_paused();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  bool paused_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static PauseChangeTrackingCommandArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// InsertDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InsertDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InsertDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 page_index = 2;
inline bool InsertDrawablesCommandArchive::has_page_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertDrawablesCommandArchive::set_has_page_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertDrawablesCommandArchive::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertDrawablesCommandArchive::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 InsertDrawablesCommandArchive::page_index() const {
  return page_index_;
}
inline void InsertDrawablesCommandArchive::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// optional uint32 z_order = 3;
inline bool InsertDrawablesCommandArchive::has_z_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertDrawablesCommandArchive::set_has_z_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertDrawablesCommandArchive::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertDrawablesCommandArchive::clear_z_order() {
  z_order_ = 0u;
  clear_has_z_order();
}
inline ::google::protobuf::uint32 InsertDrawablesCommandArchive::z_order() const {
  return z_order_;
}
inline void InsertDrawablesCommandArchive::set_z_order(::google::protobuf::uint32 value) {
  set_has_z_order();
  z_order_ = value;
}

// repeated .TSP.Reference drawables = 4;
inline int InsertDrawablesCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void InsertDrawablesCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TSP::Reference& InsertDrawablesCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TSP::Reference* InsertDrawablesCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TSP::Reference* InsertDrawablesCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
InsertDrawablesCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
InsertDrawablesCommandArchive::mutable_drawables() {
  return &drawables_;
}

// optional bool forPaste = 5;
inline bool InsertDrawablesCommandArchive::has_forpaste() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertDrawablesCommandArchive::set_has_forpaste() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertDrawablesCommandArchive::clear_has_forpaste() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertDrawablesCommandArchive::clear_forpaste() {
  forpaste_ = false;
  clear_has_forpaste();
}
inline bool InsertDrawablesCommandArchive::forpaste() const {
  return forpaste_;
}
inline void InsertDrawablesCommandArchive::set_forpaste(bool value) {
  set_has_forpaste();
  forpaste_ = value;
}

// -------------------------------------------------------------------

// PasteDrawablesCommandArchive_DrawableAndPage

// optional .TSP.Reference drawable = 1;
inline bool PasteDrawablesCommandArchive_DrawableAndPage::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& PasteDrawablesCommandArchive_DrawableAndPage::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional uint32 page_index = 2;
inline bool PasteDrawablesCommandArchive_DrawableAndPage::has_page_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_has_page_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 PasteDrawablesCommandArchive_DrawableAndPage::page_index() const {
  return page_index_;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// -------------------------------------------------------------------

// PasteDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PasteDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PasteDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PasteDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PasteDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& PasteDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PasteDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
inline int PasteDrawablesCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void PasteDrawablesCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& PasteDrawablesCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* PasteDrawablesCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* PasteDrawablesCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >&
PasteDrawablesCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >*
PasteDrawablesCommandArchive::mutable_drawables() {
  return &drawables_;
}

// -------------------------------------------------------------------

// PasteAnchoredDrawablesCommandArchive

// required .TSK.CommandGroupArchive deprecated_super = 1;
inline bool PasteAnchoredDrawablesCommandArchive::has_deprecated_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PasteAnchoredDrawablesCommandArchive::set_has_deprecated_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_has_deprecated_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_deprecated_super() {
  if (deprecated_super_ != NULL) deprecated_super_->::TSK::CommandGroupArchive::Clear();
  clear_has_deprecated_super();
}
inline const ::TSK::CommandGroupArchive& PasteAnchoredDrawablesCommandArchive::deprecated_super() const {
  return deprecated_super_ != NULL ? *deprecated_super_ : *default_instance_->deprecated_super_;
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::mutable_deprecated_super() {
  set_has_deprecated_super();
  if (deprecated_super_ == NULL) deprecated_super_ = new ::TSK::CommandGroupArchive;
  return deprecated_super_;
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::release_deprecated_super() {
  clear_has_deprecated_super();
  ::TSK::CommandGroupArchive* temp = deprecated_super_;
  deprecated_super_ = NULL;
  return temp;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_deprecated_super(::TSK::CommandGroupArchive* deprecated_super) {
  delete deprecated_super_;
  deprecated_super_ = deprecated_super;
  if (deprecated_super) {
    set_has_deprecated_super();
  } else {
    clear_has_deprecated_super();
  }
}

// optional .TSK.CommandArchive super = 4;
inline bool PasteAnchoredDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PasteAnchoredDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& PasteAnchoredDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool select = 2;
inline bool PasteAnchoredDrawablesCommandArchive::has_select() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PasteAnchoredDrawablesCommandArchive::set_has_select() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_has_select() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_select() {
  select_ = false;
  clear_has_select();
}
inline bool PasteAnchoredDrawablesCommandArchive::select() const {
  return select_;
}
inline void PasteAnchoredDrawablesCommandArchive::set_select(bool value) {
  set_has_select();
  select_ = value;
}

// optional .TSP.Reference deprecated_undo_selection = 3;
inline bool PasteAnchoredDrawablesCommandArchive::has_deprecated_undo_selection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PasteAnchoredDrawablesCommandArchive::set_has_deprecated_undo_selection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_has_deprecated_undo_selection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_deprecated_undo_selection() {
  if (deprecated_undo_selection_ != NULL) deprecated_undo_selection_->::TSP::Reference::Clear();
  clear_has_deprecated_undo_selection();
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::deprecated_undo_selection() const {
  return deprecated_undo_selection_ != NULL ? *deprecated_undo_selection_ : *default_instance_->deprecated_undo_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::mutable_deprecated_undo_selection() {
  set_has_deprecated_undo_selection();
  if (deprecated_undo_selection_ == NULL) deprecated_undo_selection_ = new ::TSP::Reference;
  return deprecated_undo_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::release_deprecated_undo_selection() {
  clear_has_deprecated_undo_selection();
  ::TSP::Reference* temp = deprecated_undo_selection_;
  deprecated_undo_selection_ = NULL;
  return temp;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_deprecated_undo_selection(::TSP::Reference* deprecated_undo_selection) {
  delete deprecated_undo_selection_;
  deprecated_undo_selection_ = deprecated_undo_selection;
  if (deprecated_undo_selection) {
    set_has_deprecated_undo_selection();
  } else {
    clear_has_deprecated_undo_selection();
  }
}

// optional .TSP.Reference canvas_selection = 5;
inline bool PasteAnchoredDrawablesCommandArchive::has_canvas_selection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PasteAnchoredDrawablesCommandArchive::set_has_canvas_selection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_has_canvas_selection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PasteAnchoredDrawablesCommandArchive::clear_canvas_selection() {
  if (canvas_selection_ != NULL) canvas_selection_->::TSP::Reference::Clear();
  clear_has_canvas_selection();
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::canvas_selection() const {
  return canvas_selection_ != NULL ? *canvas_selection_ : *default_instance_->canvas_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::mutable_canvas_selection() {
  set_has_canvas_selection();
  if (canvas_selection_ == NULL) canvas_selection_ = new ::TSP::Reference;
  return canvas_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::release_canvas_selection() {
  clear_has_canvas_selection();
  ::TSP::Reference* temp = canvas_selection_;
  canvas_selection_ = NULL;
  return temp;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_canvas_selection(::TSP::Reference* canvas_selection) {
  delete canvas_selection_;
  canvas_selection_ = canvas_selection;
  if (canvas_selection) {
    set_has_canvas_selection();
  } else {
    clear_has_canvas_selection();
  }
}

// -------------------------------------------------------------------

// MoveDrawablesPageIndexCommandArchive_Drawable

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesPageIndexCommandArchive_Drawable::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional uint32 z_order = 2;
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::has_z_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_has_z_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::clear_z_order() {
  z_order_ = 0u;
  clear_has_z_order();
}
inline ::google::protobuf::uint32 MoveDrawablesPageIndexCommandArchive_Drawable::z_order() const {
  return z_order_;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_z_order(::google::protobuf::uint32 value) {
  set_has_z_order();
  z_order_ = value;
}

// -------------------------------------------------------------------

// MoveDrawablesPageIndexCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesPageIndexCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesPageIndexCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesPageIndexCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesPageIndexCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesPageIndexCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveDrawablesPageIndexCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 page_index = 2;
inline bool MoveDrawablesPageIndexCommandArchive::has_page_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesPageIndexCommandArchive::set_has_page_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesPageIndexCommandArchive::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesPageIndexCommandArchive::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 MoveDrawablesPageIndexCommandArchive::page_index() const {
  return page_index_;
}
inline void MoveDrawablesPageIndexCommandArchive::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
inline int MoveDrawablesPageIndexCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void MoveDrawablesPageIndexCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& MoveDrawablesPageIndexCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* MoveDrawablesPageIndexCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* MoveDrawablesPageIndexCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >&
MoveDrawablesPageIndexCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >*
MoveDrawablesPageIndexCommandArchive::mutable_drawables() {
  return &drawables_;
}

// -------------------------------------------------------------------

// InsertSectionBreakCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool InsertSectionBreakCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertSectionBreakCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertSectionBreakCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertSectionBreakCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextCommandArchive& InsertSectionBreakCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextCommandArchive;
  return super_;
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::TextCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertSectionBreakCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// DeleteSectionCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DeleteSectionCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSectionCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSectionCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSectionCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DeleteSectionCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DeleteSectionCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ReplaceSectionCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool ReplaceSectionCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceSectionCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceSectionCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceSectionCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextCommandArchive& ReplaceSectionCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextCommandArchive;
  return super_;
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::TextCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReplaceSectionCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChangeSectionPropertyCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeSectionPropertyCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeSectionPropertyCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeSectionPropertyCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeSectionPropertyCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeSectionPropertyCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeSectionPropertyCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 section_index = 2;
inline bool ChangeSectionPropertyCommandArchive::has_section_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeSectionPropertyCommandArchive::set_has_section_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeSectionPropertyCommandArchive::clear_has_section_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeSectionPropertyCommandArchive::clear_section_index() {
  section_index_ = 0u;
  clear_has_section_index();
}
inline ::google::protobuf::uint32 ChangeSectionPropertyCommandArchive::section_index() const {
  return section_index_;
}
inline void ChangeSectionPropertyCommandArchive::set_section_index(::google::protobuf::uint32 value) {
  set_has_section_index();
  section_index_ = value;
}

// optional string section_property = 3;
inline bool ChangeSectionPropertyCommandArchive::has_section_property() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeSectionPropertyCommandArchive::set_has_section_property() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeSectionPropertyCommandArchive::clear_has_section_property() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeSectionPropertyCommandArchive::clear_section_property() {
  if (section_property_ != &::google::protobuf::internal::kEmptyString) {
    section_property_->clear();
  }
  clear_has_section_property();
}
inline const ::std::string& ChangeSectionPropertyCommandArchive::section_property() const {
  return *section_property_;
}
inline void ChangeSectionPropertyCommandArchive::set_section_property(const ::std::string& value) {
  set_has_section_property();
  if (section_property_ == &::google::protobuf::internal::kEmptyString) {
    section_property_ = new ::std::string;
  }
  section_property_->assign(value);
}
inline void ChangeSectionPropertyCommandArchive::set_section_property(const char* value) {
  set_has_section_property();
  if (section_property_ == &::google::protobuf::internal::kEmptyString) {
    section_property_ = new ::std::string;
  }
  section_property_->assign(value);
}
inline void ChangeSectionPropertyCommandArchive::set_section_property(const char* value, size_t size) {
  set_has_section_property();
  if (section_property_ == &::google::protobuf::internal::kEmptyString) {
    section_property_ = new ::std::string;
  }
  section_property_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeSectionPropertyCommandArchive::mutable_section_property() {
  set_has_section_property();
  if (section_property_ == &::google::protobuf::internal::kEmptyString) {
    section_property_ = new ::std::string;
  }
  return section_property_;
}
inline ::std::string* ChangeSectionPropertyCommandArchive::release_section_property() {
  clear_has_section_property();
  if (section_property_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = section_property_;
    section_property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeSectionPropertyCommandArchive::set_allocated_section_property(::std::string* section_property) {
  if (section_property_ != &::google::protobuf::internal::kEmptyString) {
    delete section_property_;
  }
  if (section_property) {
    set_has_section_property();
    section_property_ = section_property;
  } else {
    clear_has_section_property();
    section_property_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool section_value_bool = 4;
inline bool ChangeSectionPropertyCommandArchive::has_section_value_bool() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeSectionPropertyCommandArchive::set_has_section_value_bool() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeSectionPropertyCommandArchive::clear_has_section_value_bool() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeSectionPropertyCommandArchive::clear_section_value_bool() {
  section_value_bool_ = false;
  clear_has_section_value_bool();
}
inline bool ChangeSectionPropertyCommandArchive::section_value_bool() const {
  return section_value_bool_;
}
inline void ChangeSectionPropertyCommandArchive::set_section_value_bool(bool value) {
  set_has_section_value_bool();
  section_value_bool_ = value;
}

// -------------------------------------------------------------------

// SwapDrawableZOrderCommandArchive_SwapPair

// required uint32 z_order_1 = 1;
inline bool SwapDrawableZOrderCommandArchive_SwapPair::has_z_order_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_has_z_order_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_has_z_order_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_z_order_1() {
  z_order_1_ = 0u;
  clear_has_z_order_1();
}
inline ::google::protobuf::uint32 SwapDrawableZOrderCommandArchive_SwapPair::z_order_1() const {
  return z_order_1_;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_z_order_1(::google::protobuf::uint32 value) {
  set_has_z_order_1();
  z_order_1_ = value;
}

// required uint32 z_order_2 = 2;
inline bool SwapDrawableZOrderCommandArchive_SwapPair::has_z_order_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_has_z_order_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_has_z_order_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_z_order_2() {
  z_order_2_ = 0u;
  clear_has_z_order_2();
}
inline ::google::protobuf::uint32 SwapDrawableZOrderCommandArchive_SwapPair::z_order_2() const {
  return z_order_2_;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_z_order_2(::google::protobuf::uint32 value) {
  set_has_z_order_2();
  z_order_2_ = value;
}

// -------------------------------------------------------------------

// SwapDrawableZOrderCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool SwapDrawableZOrderCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapDrawableZOrderCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapDrawableZOrderCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapDrawableZOrderCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& SwapDrawableZOrderCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void SwapDrawableZOrderCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
inline int SwapDrawableZOrderCommandArchive::swap_pairs_size() const {
  return swap_pairs_.size();
}
inline void SwapDrawableZOrderCommandArchive::clear_swap_pairs() {
  swap_pairs_.Clear();
}
inline const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& SwapDrawableZOrderCommandArchive::swap_pairs(int index) const {
  return swap_pairs_.Get(index);
}
inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* SwapDrawableZOrderCommandArchive::mutable_swap_pairs(int index) {
  return swap_pairs_.Mutable(index);
}
inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* SwapDrawableZOrderCommandArchive::add_swap_pairs() {
  return swap_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >&
SwapDrawableZOrderCommandArchive::swap_pairs() const {
  return swap_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >*
SwapDrawableZOrderCommandArchive::mutable_swap_pairs() {
  return &swap_pairs_;
}

// -------------------------------------------------------------------

// RemoveDrawablesCommandArchive_DrawableInfo

// optional uint32 page_index = 1;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_page_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_has_page_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 RemoveDrawablesCommandArchive_DrawableInfo::page_index() const {
  return page_index_;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// optional int32 z_order = 2;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_z_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_has_z_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_z_order() {
  z_order_ = 0;
  clear_has_z_order();
}
inline ::google::protobuf::int32 RemoveDrawablesCommandArchive_DrawableInfo::z_order() const {
  return z_order_;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_z_order(::google::protobuf::int32 value) {
  set_has_z_order();
  z_order_ = value;
}

// optional .TSP.Reference drawable_object = 3;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_drawable_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_has_drawable_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_has_drawable_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_drawable_object() {
  if (drawable_object_ != NULL) drawable_object_->::TSP::Reference::Clear();
  clear_has_drawable_object();
}
inline const ::TSP::Reference& RemoveDrawablesCommandArchive_DrawableInfo::drawable_object() const {
  return drawable_object_ != NULL ? *drawable_object_ : *default_instance_->drawable_object_;
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::mutable_drawable_object() {
  set_has_drawable_object();
  if (drawable_object_ == NULL) drawable_object_ = new ::TSP::Reference;
  return drawable_object_;
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::release_drawable_object() {
  clear_has_drawable_object();
  ::TSP::Reference* temp = drawable_object_;
  drawable_object_ = NULL;
  return temp;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_allocated_drawable_object(::TSP::Reference* drawable_object) {
  delete drawable_object_;
  drawable_object_ = drawable_object;
  if (drawable_object) {
    set_has_drawable_object();
  } else {
    clear_has_drawable_object();
  }
}

// -------------------------------------------------------------------

// RemoveDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool RemoveDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
inline int RemoveDrawablesCommandArchive::drawables_size() const {
  return drawables_.size();
}
inline void RemoveDrawablesCommandArchive::clear_drawables() {
  drawables_.Clear();
}
inline const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& RemoveDrawablesCommandArchive::drawables(int index) const {
  return drawables_.Get(index);
}
inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* RemoveDrawablesCommandArchive::mutable_drawables(int index) {
  return drawables_.Mutable(index);
}
inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* RemoveDrawablesCommandArchive::add_drawables() {
  return drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >&
RemoveDrawablesCommandArchive::drawables() const {
  return drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >*
RemoveDrawablesCommandArchive::mutable_drawables() {
  return &drawables_;
}

// -------------------------------------------------------------------

// NudgeDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool NudgeDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NudgeDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NudgeDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NudgeDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& NudgeDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void NudgeDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference child_commands = 2;
inline int NudgeDrawablesCommandArchive::child_commands_size() const {
  return child_commands_.size();
}
inline void NudgeDrawablesCommandArchive::clear_child_commands() {
  child_commands_.Clear();
}
inline const ::TSP::Reference& NudgeDrawablesCommandArchive::child_commands(int index) const {
  return child_commands_.Get(index);
}
inline ::TSP::Reference* NudgeDrawablesCommandArchive::mutable_child_commands(int index) {
  return child_commands_.Mutable(index);
}
inline ::TSP::Reference* NudgeDrawablesCommandArchive::add_child_commands() {
  return child_commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
NudgeDrawablesCommandArchive::child_commands() const {
  return child_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
NudgeDrawablesCommandArchive::mutable_child_commands() {
  return &child_commands_;
}

// -------------------------------------------------------------------

// ChangeHeaderFooterVisibilityCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeHeaderFooterVisibilityCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool visible = 2;
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_has_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_has_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::visible() const {
  return visible_;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::type() const {
  return static_cast< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType >(type_);
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value) {
  assert(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_index_to_select() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_has_index_to_select() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_has_index_to_select() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_index_to_select() {
  index_to_select_ = 0;
  clear_has_index_to_select();
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::index_to_select() const {
  return static_cast< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex >(index_to_select_);
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value) {
  assert(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(value));
  set_has_index_to_select();
  index_to_select_ = value;
}

// repeated .TSP.Reference storages = 5;
inline int ChangeHeaderFooterVisibilityCommandArchive::storages_size() const {
  return storages_.size();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_storages() {
  storages_.Clear();
}
inline const ::TSP::Reference& ChangeHeaderFooterVisibilityCommandArchive::storages(int index) const {
  return storages_.Get(index);
}
inline ::TSP::Reference* ChangeHeaderFooterVisibilityCommandArchive::mutable_storages(int index) {
  return storages_.Mutable(index);
}
inline ::TSP::Reference* ChangeHeaderFooterVisibilityCommandArchive::add_storages() {
  return storages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ChangeHeaderFooterVisibilityCommandArchive::storages() const {
  return storages_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ChangeHeaderFooterVisibilityCommandArchive::mutable_storages() {
  return &storages_;
}

// -------------------------------------------------------------------

// ChangeSectionMarginsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeSectionMarginsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeSectionMarginsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeSectionMarginsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeSectionMarginsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeSectionMarginsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeSectionMarginsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference section = 2;
inline bool ChangeSectionMarginsCommandArchive::has_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeSectionMarginsCommandArchive::set_has_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeSectionMarginsCommandArchive::clear_has_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeSectionMarginsCommandArchive::clear_section() {
  if (section_ != NULL) section_->::TSP::Reference::Clear();
  clear_has_section();
}
inline const ::TSP::Reference& ChangeSectionMarginsCommandArchive::section() const {
  return section_ != NULL ? *section_ : *default_instance_->section_;
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::mutable_section() {
  set_has_section();
  if (section_ == NULL) section_ = new ::TSP::Reference;
  return section_;
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::release_section() {
  clear_has_section();
  ::TSP::Reference* temp = section_;
  section_ = NULL;
  return temp;
}
inline void ChangeSectionMarginsCommandArchive::set_allocated_section(::TSP::Reference* section) {
  delete section_;
  section_ = section;
  if (section) {
    set_has_section();
  } else {
    clear_has_section();
  }
}

// optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
inline bool ChangeSectionMarginsCommandArchive::has_margin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeSectionMarginsCommandArchive::set_has_margin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeSectionMarginsCommandArchive::clear_has_margin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeSectionMarginsCommandArchive::clear_margin() {
  margin_ = 0;
  clear_has_margin();
}
inline ::TP::ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::margin() const {
  return static_cast< ::TP::ChangeSectionMarginsCommandArchive_SectionMargin >(margin_);
}
inline void ChangeSectionMarginsCommandArchive::set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value) {
  assert(::TP::ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(value));
  set_has_margin();
  margin_ = value;
}

// optional float margin_value = 4;
inline bool ChangeSectionMarginsCommandArchive::has_margin_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeSectionMarginsCommandArchive::set_has_margin_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeSectionMarginsCommandArchive::clear_has_margin_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeSectionMarginsCommandArchive::clear_margin_value() {
  margin_value_ = 0;
  clear_has_margin_value();
}
inline float ChangeSectionMarginsCommandArchive::margin_value() const {
  return margin_value_;
}
inline void ChangeSectionMarginsCommandArchive::set_margin_value(float value) {
  set_has_margin_value();
  margin_value_ = value;
}

// -------------------------------------------------------------------

// ChangeDocumentPrinterOptionsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeDocumentPrinterOptionsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_obsolete_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_obsolete_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_obsolete_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_obsolete_section() {
  if (obsolete_section_ != NULL) obsolete_section_->::TSP::Reference::Clear();
  clear_has_obsolete_section();
}
inline const ::TSP::Reference& ChangeDocumentPrinterOptionsCommandArchive::obsolete_section() const {
  return obsolete_section_ != NULL ? *obsolete_section_ : *default_instance_->obsolete_section_;
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::mutable_obsolete_section() {
  set_has_obsolete_section();
  if (obsolete_section_ == NULL) obsolete_section_ = new ::TSP::Reference;
  return obsolete_section_;
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::release_obsolete_section() {
  clear_has_obsolete_section();
  ::TSP::Reference* temp = obsolete_section_;
  obsolete_section_ = NULL;
  return temp;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  delete obsolete_section_;
  obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    set_has_obsolete_section();
  } else {
    clear_has_obsolete_section();
  }
}

// optional float paper_width = 3;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_paper_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_paper_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_width() {
  paper_width_ = 0;
  clear_has_paper_width();
}
inline float ChangeDocumentPrinterOptionsCommandArchive::paper_width() const {
  return paper_width_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_width(float value) {
  set_has_paper_width();
  paper_width_ = value;
}

// optional float paper_height = 4;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_paper_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_paper_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_height() {
  paper_height_ = 0;
  clear_has_paper_height();
}
inline float ChangeDocumentPrinterOptionsCommandArchive::paper_height() const {
  return paper_height_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_height(float value) {
  set_has_paper_height();
  paper_height_ = value;
}

// optional float page_scale = 5;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_page_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_page_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_page_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_page_scale() {
  page_scale_ = 0;
  clear_has_page_scale();
}
inline float ChangeDocumentPrinterOptionsCommandArchive::page_scale() const {
  return page_scale_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_page_scale(float value) {
  set_has_page_scale();
  page_scale_ = value;
}

// optional uint32 orientation = 6;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_orientation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_orientation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_orientation() {
  orientation_ = 0u;
  clear_has_orientation();
}
inline ::google::protobuf::uint32 ChangeDocumentPrinterOptionsCommandArchive::orientation() const {
  return orientation_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_orientation(::google::protobuf::uint32 value) {
  set_has_orientation();
  orientation_ = value;
}

// optional string printer_id = 7;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_printer_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_printer_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_printer_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_printer_id() {
  if (printer_id_ != &::google::protobuf::internal::kEmptyString) {
    printer_id_->clear();
  }
  clear_has_printer_id();
}
inline const ::std::string& ChangeDocumentPrinterOptionsCommandArchive::printer_id() const {
  return *printer_id_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_printer_id(const ::std::string& value) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(value);
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_printer_id(const char* value) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(value);
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_printer_id(const char* value, size_t size) {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  printer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeDocumentPrinterOptionsCommandArchive::mutable_printer_id() {
  set_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    printer_id_ = new ::std::string;
  }
  return printer_id_;
}
inline ::std::string* ChangeDocumentPrinterOptionsCommandArchive::release_printer_id() {
  clear_has_printer_id();
  if (printer_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = printer_id_;
    printer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_printer_id(::std::string* printer_id) {
  if (printer_id_ != &::google::protobuf::internal::kEmptyString) {
    delete printer_id_;
  }
  if (printer_id) {
    set_has_printer_id();
    printer_id_ = printer_id;
  } else {
    clear_has_printer_id();
    printer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string paper_id = 8;
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_has_paper_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_has_paper_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_id() {
  if (paper_id_ != &::google::protobuf::internal::kEmptyString) {
    paper_id_->clear();
  }
  clear_has_paper_id();
}
inline const ::std::string& ChangeDocumentPrinterOptionsCommandArchive::paper_id() const {
  return *paper_id_;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_id(const ::std::string& value) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(value);
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_id(const char* value) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(value);
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_id(const char* value, size_t size) {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  paper_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangeDocumentPrinterOptionsCommandArchive::mutable_paper_id() {
  set_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    paper_id_ = new ::std::string;
  }
  return paper_id_;
}
inline ::std::string* ChangeDocumentPrinterOptionsCommandArchive::release_paper_id() {
  clear_has_paper_id();
  if (paper_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paper_id_;
    paper_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_paper_id(::std::string* paper_id) {
  if (paper_id_ != &::google::protobuf::internal::kEmptyString) {
    delete paper_id_;
  }
  if (paper_id) {
    set_has_paper_id();
    paper_id_ = paper_id;
  } else {
    clear_has_paper_id();
    paper_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InsertMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InsertMasterDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertMasterDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertMasterDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertMasterDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InsertMasterDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool InsertMasterDrawablesCommandArchive::has_obsolete_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertMasterDrawablesCommandArchive::set_has_obsolete_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertMasterDrawablesCommandArchive::clear_has_obsolete_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertMasterDrawablesCommandArchive::clear_obsolete_section() {
  if (obsolete_section_ != NULL) obsolete_section_->::TSP::Reference::Clear();
  clear_has_obsolete_section();
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::obsolete_section() const {
  return obsolete_section_ != NULL ? *obsolete_section_ : *default_instance_->obsolete_section_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_obsolete_section() {
  set_has_obsolete_section();
  if (obsolete_section_ == NULL) obsolete_section_ = new ::TSP::Reference;
  return obsolete_section_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::release_obsolete_section() {
  clear_has_obsolete_section();
  ::TSP::Reference* temp = obsolete_section_;
  obsolete_section_ = NULL;
  return temp;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  delete obsolete_section_;
  obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    set_has_obsolete_section();
  } else {
    clear_has_obsolete_section();
  }
}

// repeated .TSP.Reference master_drawables = 3;
inline int InsertMasterDrawablesCommandArchive::master_drawables_size() const {
  return master_drawables_.size();
}
inline void InsertMasterDrawablesCommandArchive::clear_master_drawables() {
  master_drawables_.Clear();
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::master_drawables(int index) const {
  return master_drawables_.Get(index);
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  return master_drawables_.Mutable(index);
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::add_master_drawables() {
  return master_drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
InsertMasterDrawablesCommandArchive::master_drawables() const {
  return master_drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
InsertMasterDrawablesCommandArchive::mutable_master_drawables() {
  return &master_drawables_;
}

// optional uint32 drawable_index = 4;
inline bool InsertMasterDrawablesCommandArchive::has_drawable_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsertMasterDrawablesCommandArchive::set_has_drawable_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsertMasterDrawablesCommandArchive::clear_has_drawable_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsertMasterDrawablesCommandArchive::clear_drawable_index() {
  drawable_index_ = 0u;
  clear_has_drawable_index();
}
inline ::google::protobuf::uint32 InsertMasterDrawablesCommandArchive::drawable_index() const {
  return drawable_index_;
}
inline void InsertMasterDrawablesCommandArchive::set_drawable_index(::google::protobuf::uint32 value) {
  set_has_drawable_index();
  drawable_index_ = value;
}

// optional .TSP.Reference master_drawable_provider = 5;
inline bool InsertMasterDrawablesCommandArchive::has_master_drawable_provider() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertMasterDrawablesCommandArchive::set_has_master_drawable_provider() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertMasterDrawablesCommandArchive::clear_has_master_drawable_provider() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertMasterDrawablesCommandArchive::clear_master_drawable_provider() {
  if (master_drawable_provider_ != NULL) master_drawable_provider_->::TSP::Reference::Clear();
  clear_has_master_drawable_provider();
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::master_drawable_provider() const {
  return master_drawable_provider_ != NULL ? *master_drawable_provider_ : *default_instance_->master_drawable_provider_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_master_drawable_provider() {
  set_has_master_drawable_provider();
  if (master_drawable_provider_ == NULL) master_drawable_provider_ = new ::TSP::Reference;
  return master_drawable_provider_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::release_master_drawable_provider() {
  clear_has_master_drawable_provider();
  ::TSP::Reference* temp = master_drawable_provider_;
  master_drawable_provider_ = NULL;
  return temp;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  delete master_drawable_provider_;
  master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    set_has_master_drawable_provider();
  } else {
    clear_has_master_drawable_provider();
  }
}

// -------------------------------------------------------------------

// MoveMasterDrawableZOrderCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveMasterDrawableZOrderCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveMasterDrawableZOrderCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool MoveMasterDrawableZOrderCommandArchive::has_obsolete_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_has_obsolete_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_has_obsolete_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_obsolete_section() {
  if (obsolete_section_ != NULL) obsolete_section_->::TSP::Reference::Clear();
  clear_has_obsolete_section();
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::obsolete_section() const {
  return obsolete_section_ != NULL ? *obsolete_section_ : *default_instance_->obsolete_section_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_obsolete_section() {
  set_has_obsolete_section();
  if (obsolete_section_ == NULL) obsolete_section_ = new ::TSP::Reference;
  return obsolete_section_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::release_obsolete_section() {
  clear_has_obsolete_section();
  ::TSP::Reference* temp = obsolete_section_;
  obsolete_section_ = NULL;
  return temp;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  delete obsolete_section_;
  obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    set_has_obsolete_section();
  } else {
    clear_has_obsolete_section();
  }
}

// repeated .TSP.Reference master_drawables = 3;
inline int MoveMasterDrawableZOrderCommandArchive::master_drawables_size() const {
  return master_drawables_.size();
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_master_drawables() {
  master_drawables_.Clear();
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::master_drawables(int index) const {
  return master_drawables_.Get(index);
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_master_drawables(int index) {
  return master_drawables_.Mutable(index);
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::add_master_drawables() {
  return master_drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
MoveMasterDrawableZOrderCommandArchive::master_drawables() const {
  return master_drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
MoveMasterDrawableZOrderCommandArchive::mutable_master_drawables() {
  return &master_drawables_;
}

// repeated uint32 indexes = 4;
inline int MoveMasterDrawableZOrderCommandArchive::indexes_size() const {
  return indexes_.size();
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_indexes() {
  indexes_.Clear();
}
inline ::google::protobuf::uint32 MoveMasterDrawableZOrderCommandArchive::indexes(int index) const {
  return indexes_.Get(index);
}
inline void MoveMasterDrawableZOrderCommandArchive::set_indexes(int index, ::google::protobuf::uint32 value) {
  indexes_.Set(index, value);
}
inline void MoveMasterDrawableZOrderCommandArchive::add_indexes(::google::protobuf::uint32 value) {
  indexes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoveMasterDrawableZOrderCommandArchive::indexes() const {
  return indexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoveMasterDrawableZOrderCommandArchive::mutable_indexes() {
  return &indexes_;
}

// optional .TSP.Reference master_drawable_provider = 5;
inline bool MoveMasterDrawableZOrderCommandArchive::has_master_drawable_provider() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_has_master_drawable_provider() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_has_master_drawable_provider() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_master_drawable_provider() {
  if (master_drawable_provider_ != NULL) master_drawable_provider_->::TSP::Reference::Clear();
  clear_has_master_drawable_provider();
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::master_drawable_provider() const {
  return master_drawable_provider_ != NULL ? *master_drawable_provider_ : *default_instance_->master_drawable_provider_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_master_drawable_provider() {
  set_has_master_drawable_provider();
  if (master_drawable_provider_ == NULL) master_drawable_provider_ = new ::TSP::Reference;
  return master_drawable_provider_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::release_master_drawable_provider() {
  clear_has_master_drawable_provider();
  ::TSP::Reference* temp = master_drawable_provider_;
  master_drawable_provider_ = NULL;
  return temp;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  delete master_drawable_provider_;
  master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    set_has_master_drawable_provider();
  } else {
    clear_has_master_drawable_provider();
  }
}

// -------------------------------------------------------------------

// RemoveMasterDrawablesCommandArchive_MasterDrawable

// optional .TSP.Reference drawable = 1;
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive_MasterDrawable::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional uint32 drawable_index = 2;
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::has_drawable_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_has_drawable_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_has_drawable_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_drawable_index() {
  drawable_index_ = 0u;
  clear_has_drawable_index();
}
inline ::google::protobuf::uint32 RemoveMasterDrawablesCommandArchive_MasterDrawable::drawable_index() const {
  return drawable_index_;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_drawable_index(::google::protobuf::uint32 value) {
  set_has_drawable_index();
  drawable_index_ = value;
}

// -------------------------------------------------------------------

// RemoveMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool RemoveMasterDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveMasterDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveMasterDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool RemoveMasterDrawablesCommandArchive::has_obsolete_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveMasterDrawablesCommandArchive::set_has_obsolete_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_has_obsolete_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_obsolete_section() {
  if (obsolete_section_ != NULL) obsolete_section_->::TSP::Reference::Clear();
  clear_has_obsolete_section();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::obsolete_section() const {
  return obsolete_section_ != NULL ? *obsolete_section_ : *default_instance_->obsolete_section_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::mutable_obsolete_section() {
  set_has_obsolete_section();
  if (obsolete_section_ == NULL) obsolete_section_ = new ::TSP::Reference;
  return obsolete_section_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::release_obsolete_section() {
  clear_has_obsolete_section();
  ::TSP::Reference* temp = obsolete_section_;
  obsolete_section_ = NULL;
  return temp;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  delete obsolete_section_;
  obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    set_has_obsolete_section();
  } else {
    clear_has_obsolete_section();
  }
}

// repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
inline int RemoveMasterDrawablesCommandArchive::master_drawables_size() const {
  return master_drawables_.size();
}
inline void RemoveMasterDrawablesCommandArchive::clear_master_drawables() {
  master_drawables_.Clear();
}
inline const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& RemoveMasterDrawablesCommandArchive::master_drawables(int index) const {
  return master_drawables_.Get(index);
}
inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* RemoveMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  return master_drawables_.Mutable(index);
}
inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* RemoveMasterDrawablesCommandArchive::add_master_drawables() {
  return master_drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >&
RemoveMasterDrawablesCommandArchive::master_drawables() const {
  return master_drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >*
RemoveMasterDrawablesCommandArchive::mutable_master_drawables() {
  return &master_drawables_;
}

// optional .TSP.Reference master_drawable_provider = 4;
inline bool RemoveMasterDrawablesCommandArchive::has_master_drawable_provider() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveMasterDrawablesCommandArchive::set_has_master_drawable_provider() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_has_master_drawable_provider() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveMasterDrawablesCommandArchive::clear_master_drawable_provider() {
  if (master_drawable_provider_ != NULL) master_drawable_provider_->::TSP::Reference::Clear();
  clear_has_master_drawable_provider();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::master_drawable_provider() const {
  return master_drawable_provider_ != NULL ? *master_drawable_provider_ : *default_instance_->master_drawable_provider_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::mutable_master_drawable_provider() {
  set_has_master_drawable_provider();
  if (master_drawable_provider_ == NULL) master_drawable_provider_ = new ::TSP::Reference;
  return master_drawable_provider_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::release_master_drawable_provider() {
  clear_has_master_drawable_provider();
  ::TSP::Reference* temp = master_drawable_provider_;
  master_drawable_provider_ = NULL;
  return temp;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  delete master_drawable_provider_;
  master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    set_has_master_drawable_provider();
  } else {
    clear_has_master_drawable_provider();
  }
}

// -------------------------------------------------------------------

// PasteMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PasteMasterDrawablesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PasteMasterDrawablesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PasteMasterDrawablesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PasteMasterDrawablesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& PasteMasterDrawablesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PasteMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference section = 2;
inline bool PasteMasterDrawablesCommandArchive::has_section() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PasteMasterDrawablesCommandArchive::set_has_section() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PasteMasterDrawablesCommandArchive::clear_has_section() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PasteMasterDrawablesCommandArchive::clear_section() {
  if (section_ != NULL) section_->::TSP::Reference::Clear();
  clear_has_section();
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::section() const {
  return section_ != NULL ? *section_ : *default_instance_->section_;
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::mutable_section() {
  set_has_section();
  if (section_ == NULL) section_ = new ::TSP::Reference;
  return section_;
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::release_section() {
  clear_has_section();
  ::TSP::Reference* temp = section_;
  section_ = NULL;
  return temp;
}
inline void PasteMasterDrawablesCommandArchive::set_allocated_section(::TSP::Reference* section) {
  delete section_;
  section_ = section;
  if (section) {
    set_has_section();
  } else {
    clear_has_section();
  }
}

// repeated .TSP.Reference master_drawables = 3;
inline int PasteMasterDrawablesCommandArchive::master_drawables_size() const {
  return master_drawables_.size();
}
inline void PasteMasterDrawablesCommandArchive::clear_master_drawables() {
  master_drawables_.Clear();
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::master_drawables(int index) const {
  return master_drawables_.Get(index);
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  return master_drawables_.Mutable(index);
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::add_master_drawables() {
  return master_drawables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
PasteMasterDrawablesCommandArchive::master_drawables() const {
  return master_drawables_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
PasteMasterDrawablesCommandArchive::mutable_master_drawables() {
  return &master_drawables_;
}

// optional uint32 drawable_index = 4;
inline bool PasteMasterDrawablesCommandArchive::has_drawable_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PasteMasterDrawablesCommandArchive::set_has_drawable_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PasteMasterDrawablesCommandArchive::clear_has_drawable_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PasteMasterDrawablesCommandArchive::clear_drawable_index() {
  drawable_index_ = 0u;
  clear_has_drawable_index();
}
inline ::google::protobuf::uint32 PasteMasterDrawablesCommandArchive::drawable_index() const {
  return drawable_index_;
}
inline void PasteMasterDrawablesCommandArchive::set_drawable_index(::google::protobuf::uint32 value) {
  set_has_drawable_index();
  drawable_index_ = value;
}

// -------------------------------------------------------------------

// MoveDrawablesAttachedCommandArchive_FloatingUndo

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional .TSD.GeometryArchive geometry = 2;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_geometry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_geometry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TSD::GeometryArchive::Clear();
  clear_has_geometry();
}
inline const ::TSD::GeometryArchive& MoveDrawablesAttachedCommandArchive_FloatingUndo::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TSD::GeometryArchive;
  return geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_geometry() {
  clear_has_geometry();
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .TSP.Reference attachment = 3;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_attachment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_attachment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_attachment() {
  if (attachment_ != NULL) attachment_->::TSP::Reference::Clear();
  clear_has_attachment();
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::attachment() const {
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::TSP::Reference;
  return attachment_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_attachment() {
  clear_has_attachment();
  ::TSP::Reference* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_attachment(::TSP::Reference* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
}

// optional uint32 wrap_type = 4;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_wrap_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_wrap_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_wrap_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_wrap_type() {
  wrap_type_ = 0u;
  clear_has_wrap_type();
}
inline ::google::protobuf::uint32 MoveDrawablesAttachedCommandArchive_FloatingUndo::wrap_type() const {
  return wrap_type_;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_wrap_type(::google::protobuf::uint32 value) {
  set_has_wrap_type();
  wrap_type_ = value;
}

// optional uint32 page_index = 5;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_page_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_page_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 MoveDrawablesAttachedCommandArchive_FloatingUndo::page_index() const {
  return page_index_;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// optional int32 z_order = 6;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_z_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_has_z_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_z_order() {
  z_order_ = 0;
  clear_has_z_order();
}
inline ::google::protobuf::int32 MoveDrawablesAttachedCommandArchive_FloatingUndo::z_order() const {
  return z_order_;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_z_order(::google::protobuf::int32 value) {
  set_has_z_order();
  z_order_ = value;
}

// -------------------------------------------------------------------

// MoveDrawablesAttachedCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesAttachedCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesAttachedCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveDrawablesAttachedCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 2;
inline bool MoveDrawablesAttachedCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesAttachedCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void MoveDrawablesAttachedCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
inline int MoveDrawablesAttachedCommandArchive::floating_undo_size() const {
  return floating_undo_.size();
}
inline void MoveDrawablesAttachedCommandArchive::clear_floating_undo() {
  floating_undo_.Clear();
}
inline const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& MoveDrawablesAttachedCommandArchive::floating_undo(int index) const {
  return floating_undo_.Get(index);
}
inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* MoveDrawablesAttachedCommandArchive::mutable_floating_undo(int index) {
  return floating_undo_.Mutable(index);
}
inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* MoveDrawablesAttachedCommandArchive::add_floating_undo() {
  return floating_undo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >&
MoveDrawablesAttachedCommandArchive::floating_undo() const {
  return floating_undo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >*
MoveDrawablesAttachedCommandArchive::mutable_floating_undo() {
  return &floating_undo_;
}

// optional bool select = 4;
inline bool MoveDrawablesAttachedCommandArchive::has_select() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive::set_has_select() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_has_select() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_select() {
  select_ = false;
  clear_has_select();
}
inline bool MoveDrawablesAttachedCommandArchive::select() const {
  return select_;
}
inline void MoveDrawablesAttachedCommandArchive::set_select(bool value) {
  set_has_select();
  select_ = value;
}

// optional bool make_inline = 5;
inline bool MoveDrawablesAttachedCommandArchive::has_make_inline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveDrawablesAttachedCommandArchive::set_has_make_inline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_has_make_inline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveDrawablesAttachedCommandArchive::clear_make_inline() {
  make_inline_ = false;
  clear_has_make_inline();
}
inline bool MoveDrawablesAttachedCommandArchive::make_inline() const {
  return make_inline_;
}
inline void MoveDrawablesAttachedCommandArchive::set_make_inline(bool value) {
  set_has_make_inline();
  make_inline_ = value;
}

// -------------------------------------------------------------------

// MoveDrawablesFloatingCommandArchive_AttachedUndo

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_drawable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_drawable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional .TSD.GeometryArchive geometry = 2;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_geometry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_geometry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_geometry() {
  if (geometry_ != NULL) geometry_->::TSD::GeometryArchive::Clear();
  clear_has_geometry();
}
inline const ::TSD::GeometryArchive& MoveDrawablesFloatingCommandArchive_AttachedUndo::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::TSD::GeometryArchive;
  return geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_geometry() {
  clear_has_geometry();
  ::TSD::GeometryArchive* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .TSP.Reference attachment = 3;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_attachment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_attachment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_attachment() {
  if (attachment_ != NULL) attachment_->::TSP::Reference::Clear();
  clear_has_attachment();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::attachment() const {
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::TSP::Reference;
  return attachment_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_attachment() {
  clear_has_attachment();
  ::TSP::Reference* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_attachment(::TSP::Reference* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
}

// optional uint32 page_index = 4;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_page_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_page_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_page_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_page_index() {
  page_index_ = 0u;
  clear_has_page_index();
}
inline ::google::protobuf::uint32 MoveDrawablesFloatingCommandArchive_AttachedUndo::page_index() const {
  return page_index_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_page_index(::google::protobuf::uint32 value) {
  set_has_page_index();
  page_index_ = value;
}

// optional bool is_html_wrap = 5;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_is_html_wrap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_is_html_wrap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_is_html_wrap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_is_html_wrap() {
  is_html_wrap_ = false;
  clear_has_is_html_wrap();
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::is_html_wrap() const {
  return is_html_wrap_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_is_html_wrap(bool value) {
  set_has_is_html_wrap();
  is_html_wrap_ = value;
}

// optional uint32 type = 6;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 MoveDrawablesFloatingCommandArchive_AttachedUndo::type() const {
  return type_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 direction = 7;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 MoveDrawablesFloatingCommandArchive_AttachedUndo::direction() const {
  return direction_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
}

// optional uint32 fit_type = 8;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_fit_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_fit_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_fit_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_fit_type() {
  fit_type_ = 0u;
  clear_has_fit_type();
}
inline ::google::protobuf::uint32 MoveDrawablesFloatingCommandArchive_AttachedUndo::fit_type() const {
  return fit_type_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_fit_type(::google::protobuf::uint32 value) {
  set_has_fit_type();
  fit_type_ = value;
}

// optional float margin = 9;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_margin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_margin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_margin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_margin() {
  margin_ = 0;
  clear_has_margin();
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::margin() const {
  return margin_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_margin(float value) {
  set_has_margin();
  margin_ = value;
}

// optional float alpha_threshold = 10;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_alpha_threshold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_alpha_threshold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_alpha_threshold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_alpha_threshold() {
  alpha_threshold_ = 0;
  clear_has_alpha_threshold();
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::alpha_threshold() const {
  return alpha_threshold_;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_alpha_threshold(float value) {
  set_has_alpha_threshold();
  alpha_threshold_ = value;
}

// optional .TSP.Reference storage = 11;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_storage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_storage() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_storage() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 12;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive_AttachedUndo::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// MoveDrawablesFloatingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesFloatingCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesFloatingCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
inline bool MoveDrawablesFloatingCommandArchive::has_deprecated_undo_transaction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive::set_has_deprecated_undo_transaction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_has_deprecated_undo_transaction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_deprecated_undo_transaction() {
  if (deprecated_undo_transaction_ != NULL) deprecated_undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_deprecated_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive::deprecated_undo_transaction() const {
  return deprecated_undo_transaction_ != NULL ? *deprecated_undo_transaction_ : *default_instance_->deprecated_undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::mutable_deprecated_undo_transaction() {
  set_has_deprecated_undo_transaction();
  if (deprecated_undo_transaction_ == NULL) deprecated_undo_transaction_ = new ::TSWP::UndoTransaction;
  return deprecated_undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::release_deprecated_undo_transaction() {
  clear_has_deprecated_undo_transaction();
  ::TSWP::UndoTransaction* temp = deprecated_undo_transaction_;
  deprecated_undo_transaction_ = NULL;
  return temp;
}
inline void MoveDrawablesFloatingCommandArchive::set_allocated_deprecated_undo_transaction(::TSWP::UndoTransaction* deprecated_undo_transaction) {
  delete deprecated_undo_transaction_;
  deprecated_undo_transaction_ = deprecated_undo_transaction;
  if (deprecated_undo_transaction) {
    set_has_deprecated_undo_transaction();
  } else {
    clear_has_deprecated_undo_transaction();
  }
}

// repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
inline int MoveDrawablesFloatingCommandArchive::attached_undo_size() const {
  return attached_undo_.size();
}
inline void MoveDrawablesFloatingCommandArchive::clear_attached_undo() {
  attached_undo_.Clear();
}
inline const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& MoveDrawablesFloatingCommandArchive::attached_undo(int index) const {
  return attached_undo_.Get(index);
}
inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* MoveDrawablesFloatingCommandArchive::mutable_attached_undo(int index) {
  return attached_undo_.Mutable(index);
}
inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* MoveDrawablesFloatingCommandArchive::add_attached_undo() {
  return attached_undo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >&
MoveDrawablesFloatingCommandArchive::attached_undo() const {
  return attached_undo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >*
MoveDrawablesFloatingCommandArchive::mutable_attached_undo() {
  return &attached_undo_;
}

// optional bool select = 4;
inline bool MoveDrawablesFloatingCommandArchive::has_select() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveDrawablesFloatingCommandArchive::set_has_select() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_has_select() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveDrawablesFloatingCommandArchive::clear_select() {
  select_ = false;
  clear_has_select();
}
inline bool MoveDrawablesFloatingCommandArchive::select() const {
  return select_;
}
inline void MoveDrawablesFloatingCommandArchive::set_select(bool value) {
  set_has_select();
  select_ = value;
}

// -------------------------------------------------------------------

// RemoveAnchoredDrawableCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool RemoveAnchoredDrawableCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveAnchoredDrawableCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextCommandArchive& RemoveAnchoredDrawableCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextCommandArchive;
  return super_;
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::TextCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveAnchoredDrawableCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 char_index = 2;
inline bool RemoveAnchoredDrawableCommandArchive::has_char_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveAnchoredDrawableCommandArchive::set_has_char_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_has_char_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_char_index() {
  char_index_ = 0u;
  clear_has_char_index();
}
inline ::google::protobuf::uint32 RemoveAnchoredDrawableCommandArchive::char_index() const {
  return char_index_;
}
inline void RemoveAnchoredDrawableCommandArchive::set_char_index(::google::protobuf::uint32 value) {
  set_has_char_index();
  char_index_ = value;
}

// optional uint32 z_order = 3;
inline bool RemoveAnchoredDrawableCommandArchive::has_z_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveAnchoredDrawableCommandArchive::set_has_z_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveAnchoredDrawableCommandArchive::clear_z_order() {
  z_order_ = 0u;
  clear_has_z_order();
}
inline ::google::protobuf::uint32 RemoveAnchoredDrawableCommandArchive::z_order() const {
  return z_order_;
}
inline void RemoveAnchoredDrawableCommandArchive::set_z_order(::google::protobuf::uint32 value) {
  set_has_z_order();
  z_order_ = value;
}

// -------------------------------------------------------------------

// ChangeFootnoteFormatCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteFormatCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFootnoteFormatCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFootnoteFormatCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFootnoteFormatCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteFormatCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeFootnoteFormatCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
inline bool ChangeFootnoteFormatCommandArchive::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFootnoteFormatCommandArchive::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFootnoteFormatCommandArchive::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFootnoteFormatCommandArchive::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::format() const {
  return static_cast< ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat >(format_);
}
inline void ChangeFootnoteFormatCommandArchive::set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value) {
  assert(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(value));
  set_has_format();
  format_ = value;
}

// -------------------------------------------------------------------

// ChangeFootnoteKindCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteKindCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFootnoteKindCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFootnoteKindCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFootnoteKindCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteKindCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeFootnoteKindCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
inline bool ChangeFootnoteKindCommandArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFootnoteKindCommandArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFootnoteKindCommandArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFootnoteKindCommandArchive::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::kind() const {
  return static_cast< ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind >(kind_);
}
inline void ChangeFootnoteKindCommandArchive::set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value) {
  assert(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ChangeFootnoteKindCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeFootnoteKindCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeFootnoteKindCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeFootnoteKindCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ChangeFootnoteKindCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ChangeFootnoteKindCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ChangeFootnoteNumberingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteNumberingCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFootnoteNumberingCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFootnoteNumberingCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFootnoteNumberingCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteNumberingCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeFootnoteNumberingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
inline bool ChangeFootnoteNumberingCommandArchive::has_numbering() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFootnoteNumberingCommandArchive::set_has_numbering() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFootnoteNumberingCommandArchive::clear_has_numbering() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFootnoteNumberingCommandArchive::clear_numbering() {
  numbering_ = 0;
  clear_has_numbering();
}
inline ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::numbering() const {
  return static_cast< ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering >(numbering_);
}
inline void ChangeFootnoteNumberingCommandArchive::set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value) {
  assert(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(value));
  set_has_numbering();
  numbering_ = value;
}

// -------------------------------------------------------------------

// ChangeFootnoteSpacingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteSpacingCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeFootnoteSpacingCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeFootnoteSpacingCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeFootnoteSpacingCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteSpacingCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeFootnoteSpacingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional int32 footnote_spacing = 2;
inline bool ChangeFootnoteSpacingCommandArchive::has_footnote_spacing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeFootnoteSpacingCommandArchive::set_has_footnote_spacing() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeFootnoteSpacingCommandArchive::clear_has_footnote_spacing() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeFootnoteSpacingCommandArchive::clear_footnote_spacing() {
  footnote_spacing_ = 0;
  clear_has_footnote_spacing();
}
inline ::google::protobuf::int32 ChangeFootnoteSpacingCommandArchive::footnote_spacing() const {
  return footnote_spacing_;
}
inline void ChangeFootnoteSpacingCommandArchive::set_footnote_spacing(::google::protobuf::int32 value) {
  set_has_footnote_spacing();
  footnote_spacing_ = value;
}

// -------------------------------------------------------------------

// MoveInlineDrawableAnchoredCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveInlineDrawableAnchoredCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference drawable = 2;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_drawable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_drawable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& MoveInlineDrawableAnchoredCommandArchive::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional bool is_html_wrap = 3;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_is_html_wrap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_is_html_wrap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_is_html_wrap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_is_html_wrap() {
  is_html_wrap_ = false;
  clear_has_is_html_wrap();
}
inline bool MoveInlineDrawableAnchoredCommandArchive::is_html_wrap() const {
  return is_html_wrap_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_is_html_wrap(bool value) {
  set_has_is_html_wrap();
  is_html_wrap_ = value;
}

// optional uint32 type = 4;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 MoveInlineDrawableAnchoredCommandArchive::type() const {
  return type_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 direction = 5;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 MoveInlineDrawableAnchoredCommandArchive::direction() const {
  return direction_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
}

// optional uint32 fit_type = 6;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_fit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_fit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_fit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_fit_type() {
  fit_type_ = 0u;
  clear_has_fit_type();
}
inline ::google::protobuf::uint32 MoveInlineDrawableAnchoredCommandArchive::fit_type() const {
  return fit_type_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_fit_type(::google::protobuf::uint32 value) {
  set_has_fit_type();
  fit_type_ = value;
}

// optional float margin = 7;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_margin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_margin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_margin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_margin() {
  margin_ = 0;
  clear_has_margin();
}
inline float MoveInlineDrawableAnchoredCommandArchive::margin() const {
  return margin_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_margin(float value) {
  set_has_margin();
  margin_ = value;
}

// optional float alpha_threshold = 8;
inline bool MoveInlineDrawableAnchoredCommandArchive::has_alpha_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_has_alpha_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_has_alpha_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_alpha_threshold() {
  alpha_threshold_ = 0;
  clear_has_alpha_threshold();
}
inline float MoveInlineDrawableAnchoredCommandArchive::alpha_threshold() const {
  return alpha_threshold_;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_alpha_threshold(float value) {
  set_has_alpha_threshold();
  alpha_threshold_ = value;
}

// -------------------------------------------------------------------

// MoveAnchoredDrawableInlineCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveAnchoredDrawableInlineCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference drawable = 2;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_drawable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_drawable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_drawable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_drawable() {
  if (drawable_ != NULL) drawable_->::TSP::Reference::Clear();
  clear_has_drawable();
}
inline const ::TSP::Reference& MoveAnchoredDrawableInlineCommandArchive::drawable() const {
  return drawable_ != NULL ? *drawable_ : *default_instance_->drawable_;
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::mutable_drawable() {
  set_has_drawable();
  if (drawable_ == NULL) drawable_ = new ::TSP::Reference;
  return drawable_;
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::release_drawable() {
  clear_has_drawable();
  ::TSP::Reference* temp = drawable_;
  drawable_ = NULL;
  return temp;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  delete drawable_;
  drawable_ = drawable;
  if (drawable) {
    set_has_drawable();
  } else {
    clear_has_drawable();
  }
}

// optional bool is_html_wrap = 3;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_is_html_wrap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_is_html_wrap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_is_html_wrap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_is_html_wrap() {
  is_html_wrap_ = false;
  clear_has_is_html_wrap();
}
inline bool MoveAnchoredDrawableInlineCommandArchive::is_html_wrap() const {
  return is_html_wrap_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_is_html_wrap(bool value) {
  set_has_is_html_wrap();
  is_html_wrap_ = value;
}

// optional uint32 type = 4;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 MoveAnchoredDrawableInlineCommandArchive::type() const {
  return type_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 direction = 5;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_direction() {
  direction_ = 0u;
  clear_has_direction();
}
inline ::google::protobuf::uint32 MoveAnchoredDrawableInlineCommandArchive::direction() const {
  return direction_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_direction(::google::protobuf::uint32 value) {
  set_has_direction();
  direction_ = value;
}

// optional uint32 fit_type = 6;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_fit_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_fit_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_fit_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_fit_type() {
  fit_type_ = 0u;
  clear_has_fit_type();
}
inline ::google::protobuf::uint32 MoveAnchoredDrawableInlineCommandArchive::fit_type() const {
  return fit_type_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_fit_type(::google::protobuf::uint32 value) {
  set_has_fit_type();
  fit_type_ = value;
}

// optional float margin = 7;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_margin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_margin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_margin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_margin() {
  margin_ = 0;
  clear_has_margin();
}
inline float MoveAnchoredDrawableInlineCommandArchive::margin() const {
  return margin_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_margin(float value) {
  set_has_margin();
  margin_ = value;
}

// optional float alpha_threshold = 8;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_alpha_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_alpha_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_alpha_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_alpha_threshold() {
  alpha_threshold_ = 0;
  clear_has_alpha_threshold();
}
inline float MoveAnchoredDrawableInlineCommandArchive::alpha_threshold() const {
  return alpha_threshold_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_alpha_threshold(float value) {
  set_has_alpha_threshold();
  alpha_threshold_ = value;
}

// optional uint32 z_order = 9;
inline bool MoveAnchoredDrawableInlineCommandArchive::has_z_order() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_has_z_order() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_has_z_order() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_z_order() {
  z_order_ = 0u;
  clear_has_z_order();
}
inline ::google::protobuf::uint32 MoveAnchoredDrawableInlineCommandArchive::z_order() const {
  return z_order_;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_z_order(::google::protobuf::uint32 value) {
  set_has_z_order();
  z_order_ = value;
}

// -------------------------------------------------------------------

// InsertFootnoteCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool InsertFootnoteCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertFootnoteCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertFootnoteCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertFootnoteCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextCommandArchive& InsertFootnoteCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextCommandArchive;
  return super_;
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::TextCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertFootnoteCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ToggleBodyLayoutDirectionCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ToggleBodyLayoutDirectionCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToggleBodyLayoutDirectionCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToggleBodyLayoutDirectionCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ToggleBodyLayoutDirectionCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool new_direction_is_vertical = 2;
inline bool ToggleBodyLayoutDirectionCommandArchive::has_new_direction_is_vertical() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_has_new_direction_is_vertical() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ToggleBodyLayoutDirectionCommandArchive::clear_has_new_direction_is_vertical() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ToggleBodyLayoutDirectionCommandArchive::clear_new_direction_is_vertical() {
  new_direction_is_vertical_ = false;
  clear_has_new_direction_is_vertical();
}
inline bool ToggleBodyLayoutDirectionCommandArchive::new_direction_is_vertical() const {
  return new_direction_is_vertical_;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_new_direction_is_vertical(bool value) {
  set_has_new_direction_is_vertical();
  new_direction_is_vertical_ = value;
}

// -------------------------------------------------------------------

// ChangeCTVisibilityCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeCTVisibilityCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeCTVisibilityCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeCTVisibilityCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeCTVisibilityCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ChangeCTVisibilityCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChangeCTVisibilityCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool markup_visible = 2;
inline bool ChangeCTVisibilityCommandArchive::has_markup_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeCTVisibilityCommandArchive::set_has_markup_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeCTVisibilityCommandArchive::clear_has_markup_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeCTVisibilityCommandArchive::clear_markup_visible() {
  markup_visible_ = false;
  clear_has_markup_visible();
}
inline bool ChangeCTVisibilityCommandArchive::markup_visible() const {
  return markup_visible_;
}
inline void ChangeCTVisibilityCommandArchive::set_markup_visible(bool value) {
  set_has_markup_visible();
  markup_visible_ = value;
}

// optional bool deletions_visible = 3;
inline bool ChangeCTVisibilityCommandArchive::has_deletions_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeCTVisibilityCommandArchive::set_has_deletions_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeCTVisibilityCommandArchive::clear_has_deletions_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeCTVisibilityCommandArchive::clear_deletions_visible() {
  deletions_visible_ = false;
  clear_has_deletions_visible();
}
inline bool ChangeCTVisibilityCommandArchive::deletions_visible() const {
  return deletions_visible_;
}
inline void ChangeCTVisibilityCommandArchive::set_deletions_visible(bool value) {
  set_has_deletions_visible();
  deletions_visible_ = value;
}

// optional uint32 selection_range_location = 4;
inline bool ChangeCTVisibilityCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeCTVisibilityCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeCTVisibilityCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeCTVisibilityCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 ChangeCTVisibilityCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void ChangeCTVisibilityCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 5;
inline bool ChangeCTVisibilityCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeCTVisibilityCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeCTVisibilityCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeCTVisibilityCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 ChangeCTVisibilityCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void ChangeCTVisibilityCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// -------------------------------------------------------------------

// TrackChangesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool TrackChangesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackChangesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackChangesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackChangesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& TrackChangesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TrackChangesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool track_changes = 2;
inline bool TrackChangesCommandArchive::has_track_changes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackChangesCommandArchive::set_has_track_changes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackChangesCommandArchive::clear_has_track_changes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackChangesCommandArchive::clear_track_changes() {
  track_changes_ = false;
  clear_has_track_changes();
}
inline bool TrackChangesCommandArchive::track_changes() const {
  return track_changes_;
}
inline void TrackChangesCommandArchive::set_track_changes(bool value) {
  set_has_track_changes();
  track_changes_ = value;
}

// repeated .TSP.Reference change_session_history = 3;
inline int TrackChangesCommandArchive::change_session_history_size() const {
  return change_session_history_.size();
}
inline void TrackChangesCommandArchive::clear_change_session_history() {
  change_session_history_.Clear();
}
inline const ::TSP::Reference& TrackChangesCommandArchive::change_session_history(int index) const {
  return change_session_history_.Get(index);
}
inline ::TSP::Reference* TrackChangesCommandArchive::mutable_change_session_history(int index) {
  return change_session_history_.Mutable(index);
}
inline ::TSP::Reference* TrackChangesCommandArchive::add_change_session_history() {
  return change_session_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
TrackChangesCommandArchive::change_session_history() const {
  return change_session_history_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
TrackChangesCommandArchive::mutable_change_session_history() {
  return &change_session_history_;
}

// optional bool paused = 4;
inline bool TrackChangesCommandArchive::has_paused() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackChangesCommandArchive::set_has_paused() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackChangesCommandArchive::clear_has_paused() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackChangesCommandArchive::clear_paused() {
  paused_ = false;
  clear_has_paused();
}
inline bool TrackChangesCommandArchive::paused() const {
  return paused_;
}
inline void TrackChangesCommandArchive::set_paused(bool value) {
  set_has_paused();
  paused_ = value;
}

// -------------------------------------------------------------------

// DocumentHyphenationCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentHyphenationCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentHyphenationCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentHyphenationCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentHyphenationCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DocumentHyphenationCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DocumentHyphenationCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool hyphenate_document = 2;
inline bool DocumentHyphenationCommandArchive::has_hyphenate_document() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentHyphenationCommandArchive::set_has_hyphenate_document() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentHyphenationCommandArchive::clear_has_hyphenate_document() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentHyphenationCommandArchive::clear_hyphenate_document() {
  hyphenate_document_ = false;
  clear_has_hyphenate_document();
}
inline bool DocumentHyphenationCommandArchive::hyphenate_document() const {
  return hyphenate_document_;
}
inline void DocumentHyphenationCommandArchive::set_hyphenate_document(bool value) {
  set_has_hyphenate_document();
  hyphenate_document_ = value;
}

// -------------------------------------------------------------------

// DocumentLigaturesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentLigaturesCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentLigaturesCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentLigaturesCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentLigaturesCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DocumentLigaturesCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DocumentLigaturesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool use_ligatures = 2;
inline bool DocumentLigaturesCommandArchive::has_use_ligatures() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentLigaturesCommandArchive::set_has_use_ligatures() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentLigaturesCommandArchive::clear_has_use_ligatures() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentLigaturesCommandArchive::clear_use_ligatures() {
  use_ligatures_ = false;
  clear_has_use_ligatures();
}
inline bool DocumentLigaturesCommandArchive::use_ligatures() const {
  return use_ligatures_;
}
inline void DocumentLigaturesCommandArchive::set_use_ligatures(bool value) {
  set_has_use_ligatures();
  use_ligatures_ = value;
}

// -------------------------------------------------------------------

// DocumentHasBodyCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentHasBodyCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentHasBodyCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentHasBodyCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentHasBodyCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& DocumentHasBodyCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void DocumentHasBodyCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool has_body = 2;
inline bool DocumentHasBodyCommandArchive::has_has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentHasBodyCommandArchive::set_has_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentHasBodyCommandArchive::clear_has_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentHasBodyCommandArchive::clear_has_body() {
  has_body_ = false;
  clear_has_has_body();
}
inline bool DocumentHasBodyCommandArchive::has_body() const {
  return has_body_;
}
inline void DocumentHasBodyCommandArchive::set_has_body(bool value) {
  set_has_has_body();
  has_body_ = value;
}

// -------------------------------------------------------------------

// PauseChangeTrackingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PauseChangeTrackingCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PauseChangeTrackingCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PauseChangeTrackingCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PauseChangeTrackingCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& PauseChangeTrackingCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void PauseChangeTrackingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional bool paused = 2;
inline bool PauseChangeTrackingCommandArchive::has_paused() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PauseChangeTrackingCommandArchive::set_has_paused() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PauseChangeTrackingCommandArchive::clear_has_paused() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PauseChangeTrackingCommandArchive::clear_paused() {
  paused_ = false;
  clear_has_paused();
}
inline bool PauseChangeTrackingCommandArchive::paused() const {
  return paused_;
}
inline void PauseChangeTrackingCommandArchive::set_paused(bool value) {
  set_has_paused();
  paused_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TP

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>() {
  return ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>() {
  return ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeSectionMarginsCommandArchive_SectionMargin>() {
  return ::TP::ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat>() {
  return ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind>() {
  return ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>() {
  return ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TPCommandArchives_2eproto__INCLUDED
