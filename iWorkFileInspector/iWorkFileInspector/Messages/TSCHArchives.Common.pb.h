// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSCHArchives.Common.proto

#ifndef PROTOBUF_TSCHArchives_2eCommon_2eproto__INCLUDED
#define PROTOBUF_TSCHArchives_2eCommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSCH3DArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSCH {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

class SparseReferenceArrayArchive;
class SparseReferenceArrayArchive_Entry;
class RectArchive;
class ChartsNSNumberDoubleArchive;
class ChartsNSArrayOfNSNumberDoubleArchive;
class DEPRECATEDChart3DFillArchive;
class ChartStyleArchive;
class ChartNonStyleArchive;
class LegendStyleArchive;
class LegendNonStyleArchive;
class ChartAxisStyleArchive;
class ChartAxisNonStyleArchive;
class ChartSeriesStyleArchive;
class ChartSeriesNonStyleArchive;

enum ChartType {
  undefinedChartType = 0,
  columnChartType2D = 1,
  barChartType2D = 2,
  lineChartType2D = 3,
  areaChartType2D = 4,
  pieChartType2D = 5,
  stackedColumnChartType2D = 6,
  stackedBarChartType2D = 7,
  stackedAreaChartType2D = 8,
  scatterChartType2D = 9,
  mixedChartType2D = 10,
  twoAxisChartType2D = 11,
  columnChartType3D = 12,
  barChartType3D = 13,
  lineChartType3D = 14,
  areaChartType3D = 15,
  pieChartType3D = 16,
  stackedColumnChartType3D = 17,
  stackedBarChartType3D = 18,
  stackedAreaChartType3D = 19,
  multiDataColumnChartType2D = 20,
  multiDataBarChartType2D = 21,
  bubbleChartType2D = 22,
  multiDataScatterChartType2D = 23,
  multiDataBubbleChartType2D = 24
};
bool ChartType_IsValid(int value);
const ChartType ChartType_MIN = undefinedChartType;
const ChartType ChartType_MAX = multiDataBubbleChartType2D;
const int ChartType_ARRAYSIZE = ChartType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChartType_descriptor();
inline const ::std::string& ChartType_Name(ChartType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChartType_descriptor(), value);
}
inline bool ChartType_Parse(
    const ::std::string& name, ChartType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChartType>(
    ChartType_descriptor(), name, value);
}
enum AxisType {
  axis_type_unknown = 0,
  axis_type_x = 1,
  axis_type_y = 2,
  axis_type_pie = 3,
  axis_type_size = 4
};
bool AxisType_IsValid(int value);
const AxisType AxisType_MIN = axis_type_unknown;
const AxisType AxisType_MAX = axis_type_size;
const int AxisType_ARRAYSIZE = AxisType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AxisType_descriptor();
inline const ::std::string& AxisType_Name(AxisType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AxisType_descriptor(), value);
}
inline bool AxisType_Parse(
    const ::std::string& name, AxisType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AxisType>(
    AxisType_descriptor(), name, value);
}
enum ScatterFormat {
  scatter_format_unknown = 0,
  scatter_format_separate_x = 1,
  scatter_format_shared_x = 2
};
bool ScatterFormat_IsValid(int value);
const ScatterFormat ScatterFormat_MIN = scatter_format_unknown;
const ScatterFormat ScatterFormat_MAX = scatter_format_shared_x;
const int ScatterFormat_ARRAYSIZE = ScatterFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScatterFormat_descriptor();
inline const ::std::string& ScatterFormat_Name(ScatterFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScatterFormat_descriptor(), value);
}
inline bool ScatterFormat_Parse(
    const ::std::string& name, ScatterFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScatterFormat>(
    ScatterFormat_descriptor(), name, value);
}
enum SeriesDirection {
  series_direction_unknown = 0,
  series_direction_by_row = 1,
  series_direction_by_column = 2
};
bool SeriesDirection_IsValid(int value);
const SeriesDirection SeriesDirection_MIN = series_direction_unknown;
const SeriesDirection SeriesDirection_MAX = series_direction_by_column;
const int SeriesDirection_ARRAYSIZE = SeriesDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* SeriesDirection_descriptor();
inline const ::std::string& SeriesDirection_Name(SeriesDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    SeriesDirection_descriptor(), value);
}
inline bool SeriesDirection_Parse(
    const ::std::string& name, SeriesDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SeriesDirection>(
    SeriesDirection_descriptor(), name, value);
}
enum NumberValueType {
  numberValueTypeDecimal = 0,
  numberValueTypeCurrency = 1,
  numberValueTypePercentage = 2,
  numberValueTypeScientific = 3,
  numberValueTypeFraction = 4,
  numberValueTypeBase = 5,
  numberValueTypeUnknown = -999
};
bool NumberValueType_IsValid(int value);
const NumberValueType NumberValueType_MIN = numberValueTypeUnknown;
const NumberValueType NumberValueType_MAX = numberValueTypeBase;
const int NumberValueType_ARRAYSIZE = NumberValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NumberValueType_descriptor();
inline const ::std::string& NumberValueType_Name(NumberValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NumberValueType_descriptor(), value);
}
inline bool NumberValueType_Parse(
    const ::std::string& name, NumberValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NumberValueType>(
    NumberValueType_descriptor(), name, value);
}
enum NegativeNumberStyle {
  negativeNumberStyleMinus = 0,
  negativeNumberStyleRed = 1,
  negativeNumberStyleParentheses = 2,
  negativeNumberStyleRedAndParentheses = 3,
  negativeNumberStyleNone = 4
};
bool NegativeNumberStyle_IsValid(int value);
const NegativeNumberStyle NegativeNumberStyle_MIN = negativeNumberStyleMinus;
const NegativeNumberStyle NegativeNumberStyle_MAX = negativeNumberStyleNone;
const int NegativeNumberStyle_ARRAYSIZE = NegativeNumberStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* NegativeNumberStyle_descriptor();
inline const ::std::string& NegativeNumberStyle_Name(NegativeNumberStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    NegativeNumberStyle_descriptor(), value);
}
inline bool NegativeNumberStyle_Parse(
    const ::std::string& name, NegativeNumberStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NegativeNumberStyle>(
    NegativeNumberStyle_descriptor(), name, value);
}
enum FractionAccuracy {
  fractionAccuracyConflicting = 0,
  fractionAccuracyUpToOneDigit = -1,
  fractionAccuracyUpToTwoDigits = -2,
  fractionAccuracyUpToThreeDigits = -3,
  fractionAccuracyHalves = 2,
  fractionAccuracyQuarters = 4,
  fractionAccuracyEighths = 8,
  fractionAccuracySixteenths = 16,
  fractionAccuracyTenths = 10,
  fractionAccuracyHundredths = 100
};
bool FractionAccuracy_IsValid(int value);
const FractionAccuracy FractionAccuracy_MIN = fractionAccuracyUpToThreeDigits;
const FractionAccuracy FractionAccuracy_MAX = fractionAccuracyHundredths;
const int FractionAccuracy_ARRAYSIZE = FractionAccuracy_MAX + 1;

const ::google::protobuf::EnumDescriptor* FractionAccuracy_descriptor();
inline const ::std::string& FractionAccuracy_Name(FractionAccuracy value) {
  return ::google::protobuf::internal::NameOfEnum(
    FractionAccuracy_descriptor(), value);
}
inline bool FractionAccuracy_Parse(
    const ::std::string& name, FractionAccuracy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FractionAccuracy>(
    FractionAccuracy_descriptor(), name, value);
}
// ===================================================================

class SparseReferenceArrayArchive_Entry : public ::google::protobuf::Message {
 public:
  SparseReferenceArrayArchive_Entry();
  virtual ~SparseReferenceArrayArchive_Entry();

  SparseReferenceArrayArchive_Entry(const SparseReferenceArrayArchive_Entry& from);

  inline SparseReferenceArrayArchive_Entry& operator=(const SparseReferenceArrayArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseReferenceArrayArchive_Entry& default_instance();

  void Swap(SparseReferenceArrayArchive_Entry* other);

  // implements Message ----------------------------------------------

  SparseReferenceArrayArchive_Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparseReferenceArrayArchive_Entry& from);
  void MergeFrom(const SparseReferenceArrayArchive_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required .TSP.Reference value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::TSP::Reference& value() const;
  inline ::TSP::Reference* mutable_value();
  inline ::TSP::Reference* release_value();
  inline void set_allocated_value(::TSP::Reference* value);

  // @@protoc_insertion_point(class_scope:TSCH.SparseReferenceArrayArchive.Entry)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* value_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static SparseReferenceArrayArchive_Entry* default_instance_;
};
// -------------------------------------------------------------------

class SparseReferenceArrayArchive : public ::google::protobuf::Message {
 public:
  SparseReferenceArrayArchive();
  virtual ~SparseReferenceArrayArchive();

  SparseReferenceArrayArchive(const SparseReferenceArrayArchive& from);

  inline SparseReferenceArrayArchive& operator=(const SparseReferenceArrayArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SparseReferenceArrayArchive& default_instance();

  void Swap(SparseReferenceArrayArchive* other);

  // implements Message ----------------------------------------------

  SparseReferenceArrayArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SparseReferenceArrayArchive& from);
  void MergeFrom(const SparseReferenceArrayArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SparseReferenceArrayArchive_Entry Entry;

  // accessors -------------------------------------------------------

  // required uint32 num_entries = 1;
  inline bool has_num_entries() const;
  inline void clear_num_entries();
  static const int kNumEntriesFieldNumber = 1;
  inline ::google::protobuf::uint32 num_entries() const;
  inline void set_num_entries(::google::protobuf::uint32 value);

  // repeated .TSCH.SparseReferenceArrayArchive.Entry entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::TSCH::SparseReferenceArrayArchive_Entry& entries(int index) const;
  inline ::TSCH::SparseReferenceArrayArchive_Entry* mutable_entries(int index);
  inline ::TSCH::SparseReferenceArrayArchive_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSCH.SparseReferenceArrayArchive)
 private:
  inline void set_has_num_entries();
  inline void clear_has_num_entries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry > entries_;
  ::google::protobuf::uint32 num_entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static SparseReferenceArrayArchive* default_instance_;
};
// -------------------------------------------------------------------

class RectArchive : public ::google::protobuf::Message {
 public:
  RectArchive();
  virtual ~RectArchive();

  RectArchive(const RectArchive& from);

  inline RectArchive& operator=(const RectArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectArchive& default_instance();

  void Swap(RectArchive* other);

  // implements Message ----------------------------------------------

  RectArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RectArchive& from);
  void MergeFrom(const RectArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Point origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::TSP::Point& origin() const;
  inline ::TSP::Point* mutable_origin();
  inline ::TSP::Point* release_origin();
  inline void set_allocated_origin(::TSP::Point* origin);

  // required .TSP.Size size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline const ::TSP::Size& size() const;
  inline ::TSP::Size* mutable_size();
  inline ::TSP::Size* release_size();
  inline void set_allocated_size(::TSP::Size* size);

  // @@protoc_insertion_point(class_scope:TSCH.RectArchive)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Point* origin_;
  ::TSP::Size* size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static RectArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartsNSNumberDoubleArchive : public ::google::protobuf::Message {
 public:
  ChartsNSNumberDoubleArchive();
  virtual ~ChartsNSNumberDoubleArchive();

  ChartsNSNumberDoubleArchive(const ChartsNSNumberDoubleArchive& from);

  inline ChartsNSNumberDoubleArchive& operator=(const ChartsNSNumberDoubleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartsNSNumberDoubleArchive& default_instance();

  void Swap(ChartsNSNumberDoubleArchive* other);

  // implements Message ----------------------------------------------

  ChartsNSNumberDoubleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartsNSNumberDoubleArchive& from);
  void MergeFrom(const ChartsNSNumberDoubleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double number_archive = 1;
  inline bool has_number_archive() const;
  inline void clear_number_archive();
  static const int kNumberArchiveFieldNumber = 1;
  inline double number_archive() const;
  inline void set_number_archive(double value);

  // @@protoc_insertion_point(class_scope:TSCH.ChartsNSNumberDoubleArchive)
 private:
  inline void set_has_number_archive();
  inline void clear_has_number_archive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double number_archive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartsNSNumberDoubleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartsNSArrayOfNSNumberDoubleArchive : public ::google::protobuf::Message {
 public:
  ChartsNSArrayOfNSNumberDoubleArchive();
  virtual ~ChartsNSArrayOfNSNumberDoubleArchive();

  ChartsNSArrayOfNSNumberDoubleArchive(const ChartsNSArrayOfNSNumberDoubleArchive& from);

  inline ChartsNSArrayOfNSNumberDoubleArchive& operator=(const ChartsNSArrayOfNSNumberDoubleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartsNSArrayOfNSNumberDoubleArchive& default_instance();

  void Swap(ChartsNSArrayOfNSNumberDoubleArchive* other);

  // implements Message ----------------------------------------------

  ChartsNSArrayOfNSNumberDoubleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartsNSArrayOfNSNumberDoubleArchive& from);
  void MergeFrom(const ChartsNSArrayOfNSNumberDoubleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double numbers = 1;
  inline int numbers_size() const;
  inline void clear_numbers();
  static const int kNumbersFieldNumber = 1;
  inline double numbers(int index) const;
  inline void set_numbers(int index, double value);
  inline void add_numbers(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      numbers() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_numbers();

  // @@protoc_insertion_point(class_scope:TSCH.ChartsNSArrayOfNSNumberDoubleArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< double > numbers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartsNSArrayOfNSNumberDoubleArchive* default_instance_;
};
// -------------------------------------------------------------------

class DEPRECATEDChart3DFillArchive : public ::google::protobuf::Message {
 public:
  DEPRECATEDChart3DFillArchive();
  virtual ~DEPRECATEDChart3DFillArchive();

  DEPRECATEDChart3DFillArchive(const DEPRECATEDChart3DFillArchive& from);

  inline DEPRECATEDChart3DFillArchive& operator=(const DEPRECATEDChart3DFillArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DEPRECATEDChart3DFillArchive& default_instance();

  void Swap(DEPRECATEDChart3DFillArchive* other);

  // implements Message ----------------------------------------------

  DEPRECATEDChart3DFillArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DEPRECATEDChart3DFillArchive& from);
  void MergeFrom(const DEPRECATEDChart3DFillArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSD.FillArchive fill = 1;
  inline bool has_fill() const;
  inline void clear_fill();
  static const int kFillFieldNumber = 1;
  inline const ::TSD::FillArchive& fill() const;
  inline ::TSD::FillArchive* mutable_fill();
  inline ::TSD::FillArchive* release_fill();
  inline void set_allocated_fill(::TSD::FillArchive* fill);

  // optional .TSCH.Chart3DLightingModelArchive lightingmodel = 2;
  inline bool has_lightingmodel() const;
  inline void clear_lightingmodel();
  static const int kLightingmodelFieldNumber = 2;
  inline const ::TSCH::Chart3DLightingModelArchive& lightingmodel() const;
  inline ::TSCH::Chart3DLightingModelArchive* mutable_lightingmodel();
  inline ::TSCH::Chart3DLightingModelArchive* release_lightingmodel();
  inline void set_allocated_lightingmodel(::TSCH::Chart3DLightingModelArchive* lightingmodel);

  // optional string textureset_id = 3;
  inline bool has_textureset_id() const;
  inline void clear_textureset_id();
  static const int kTexturesetIdFieldNumber = 3;
  inline const ::std::string& textureset_id() const;
  inline void set_textureset_id(const ::std::string& value);
  inline void set_textureset_id(const char* value);
  inline void set_textureset_id(const char* value, size_t size);
  inline ::std::string* mutable_textureset_id();
  inline ::std::string* release_textureset_id();
  inline void set_allocated_textureset_id(::std::string* textureset_id);

  // optional .TSCH.FillPropertyType fill_type = 4;
  inline bool has_fill_type() const;
  inline void clear_fill_type();
  static const int kFillTypeFieldNumber = 4;
  inline ::TSCH::FillPropertyType fill_type() const;
  inline void set_fill_type(::TSCH::FillPropertyType value);

  // optional uint32 series_index = 5;
  inline bool has_series_index() const;
  inline void clear_series_index();
  static const int kSeriesIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 series_index() const;
  inline void set_series_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSCH.DEPRECATEDChart3DFillArchive)
 private:
  inline void set_has_fill();
  inline void clear_has_fill();
  inline void set_has_lightingmodel();
  inline void clear_has_lightingmodel();
  inline void set_has_textureset_id();
  inline void clear_has_textureset_id();
  inline void set_has_fill_type();
  inline void clear_has_fill_type();
  inline void set_has_series_index();
  inline void clear_has_series_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::FillArchive* fill_;
  ::TSCH::Chart3DLightingModelArchive* lightingmodel_;
  ::std::string* textureset_id_;
  int fill_type_;
  ::google::protobuf::uint32 series_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static DEPRECATEDChart3DFillArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartStyleArchive : public ::google::protobuf::Message {
 public:
  ChartStyleArchive();
  virtual ~ChartStyleArchive();

  ChartStyleArchive(const ChartStyleArchive& from);

  inline ChartStyleArchive& operator=(const ChartStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartStyleArchive& default_instance();

  void Swap(ChartStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartStyleArchive& from);
  void MergeFrom(const ChartStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartNonStyleArchive : public ::google::protobuf::Message {
 public:
  ChartNonStyleArchive();
  virtual ~ChartNonStyleArchive();

  ChartNonStyleArchive(const ChartNonStyleArchive& from);

  inline ChartNonStyleArchive& operator=(const ChartNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartNonStyleArchive& default_instance();

  void Swap(ChartNonStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartNonStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartNonStyleArchive& from);
  void MergeFrom(const ChartNonStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartNonStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartNonStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartNonStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class LegendStyleArchive : public ::google::protobuf::Message {
 public:
  LegendStyleArchive();
  virtual ~LegendStyleArchive();

  LegendStyleArchive(const LegendStyleArchive& from);

  inline LegendStyleArchive& operator=(const LegendStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegendStyleArchive& default_instance();

  void Swap(LegendStyleArchive* other);

  // implements Message ----------------------------------------------

  LegendStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegendStyleArchive& from);
  void MergeFrom(const LegendStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LegendStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.LegendStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static LegendStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class LegendNonStyleArchive : public ::google::protobuf::Message {
 public:
  LegendNonStyleArchive();
  virtual ~LegendNonStyleArchive();

  LegendNonStyleArchive(const LegendNonStyleArchive& from);

  inline LegendNonStyleArchive& operator=(const LegendNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegendNonStyleArchive& default_instance();

  void Swap(LegendNonStyleArchive* other);

  // implements Message ----------------------------------------------

  LegendNonStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegendNonStyleArchive& from);
  void MergeFrom(const LegendNonStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LegendNonStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.LegendNonStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static LegendNonStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartAxisStyleArchive : public ::google::protobuf::Message {
 public:
  ChartAxisStyleArchive();
  virtual ~ChartAxisStyleArchive();

  ChartAxisStyleArchive(const ChartAxisStyleArchive& from);

  inline ChartAxisStyleArchive& operator=(const ChartAxisStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartAxisStyleArchive& default_instance();

  void Swap(ChartAxisStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartAxisStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartAxisStyleArchive& from);
  void MergeFrom(const ChartAxisStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartAxisStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartAxisStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartAxisStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartAxisNonStyleArchive : public ::google::protobuf::Message {
 public:
  ChartAxisNonStyleArchive();
  virtual ~ChartAxisNonStyleArchive();

  ChartAxisNonStyleArchive(const ChartAxisNonStyleArchive& from);

  inline ChartAxisNonStyleArchive& operator=(const ChartAxisNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartAxisNonStyleArchive& default_instance();

  void Swap(ChartAxisNonStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartAxisNonStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartAxisNonStyleArchive& from);
  void MergeFrom(const ChartAxisNonStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartAxisNonStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartAxisNonStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartAxisNonStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartSeriesStyleArchive : public ::google::protobuf::Message {
 public:
  ChartSeriesStyleArchive();
  virtual ~ChartSeriesStyleArchive();

  ChartSeriesStyleArchive(const ChartSeriesStyleArchive& from);

  inline ChartSeriesStyleArchive& operator=(const ChartSeriesStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartSeriesStyleArchive& default_instance();

  void Swap(ChartSeriesStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartSeriesStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartSeriesStyleArchive& from);
  void MergeFrom(const ChartSeriesStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartSeriesStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartSeriesStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartSeriesStyleArchive* default_instance_;
};
// -------------------------------------------------------------------

class ChartSeriesNonStyleArchive : public ::google::protobuf::Message {
 public:
  ChartSeriesNonStyleArchive();
  virtual ~ChartSeriesNonStyleArchive();

  ChartSeriesNonStyleArchive(const ChartSeriesNonStyleArchive& from);

  inline ChartSeriesNonStyleArchive& operator=(const ChartSeriesNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartSeriesNonStyleArchive& default_instance();

  void Swap(ChartSeriesNonStyleArchive* other);

  // implements Message ----------------------------------------------

  ChartSeriesNonStyleArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartSeriesNonStyleArchive& from);
  void MergeFrom(const ChartSeriesNonStyleArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.StyleArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleArchive& super() const;
  inline ::TSS::StyleArchive* mutable_super();
  inline ::TSS::StyleArchive* release_super();
  inline void set_allocated_super(::TSS::StyleArchive* super);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ChartSeriesNonStyleArchive)
  // @@protoc_insertion_point(class_scope:TSCH.ChartSeriesNonStyleArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_AssignDesc_TSCHArchives_2eCommon_2eproto();
  friend void protobuf_ShutdownFile_TSCHArchives_2eCommon_2eproto();

  void InitAsDefaultInstance();
  static ChartSeriesNonStyleArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// SparseReferenceArrayArchive_Entry

// required uint32 index = 1;
inline bool SparseReferenceArrayArchive_Entry::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseReferenceArrayArchive_Entry::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseReferenceArrayArchive_Entry::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseReferenceArrayArchive_Entry::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SparseReferenceArrayArchive_Entry::index() const {
  return index_;
}
inline void SparseReferenceArrayArchive_Entry::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required .TSP.Reference value = 2;
inline bool SparseReferenceArrayArchive_Entry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SparseReferenceArrayArchive_Entry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SparseReferenceArrayArchive_Entry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SparseReferenceArrayArchive_Entry::clear_value() {
  if (value_ != NULL) value_->::TSP::Reference::Clear();
  clear_has_value();
}
inline const ::TSP::Reference& SparseReferenceArrayArchive_Entry::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::TSP::Reference;
  return value_;
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::release_value() {
  clear_has_value();
  ::TSP::Reference* temp = value_;
  value_ = NULL;
  return temp;
}
inline void SparseReferenceArrayArchive_Entry::set_allocated_value(::TSP::Reference* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// SparseReferenceArrayArchive

// required uint32 num_entries = 1;
inline bool SparseReferenceArrayArchive::has_num_entries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SparseReferenceArrayArchive::set_has_num_entries() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SparseReferenceArrayArchive::clear_has_num_entries() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SparseReferenceArrayArchive::clear_num_entries() {
  num_entries_ = 0u;
  clear_has_num_entries();
}
inline ::google::protobuf::uint32 SparseReferenceArrayArchive::num_entries() const {
  return num_entries_;
}
inline void SparseReferenceArrayArchive::set_num_entries(::google::protobuf::uint32 value) {
  set_has_num_entries();
  num_entries_ = value;
}

// repeated .TSCH.SparseReferenceArrayArchive.Entry entries = 2;
inline int SparseReferenceArrayArchive::entries_size() const {
  return entries_.size();
}
inline void SparseReferenceArrayArchive::clear_entries() {
  entries_.Clear();
}
inline const ::TSCH::SparseReferenceArrayArchive_Entry& SparseReferenceArrayArchive::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSCH::SparseReferenceArrayArchive_Entry* SparseReferenceArrayArchive::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSCH::SparseReferenceArrayArchive_Entry* SparseReferenceArrayArchive::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >&
SparseReferenceArrayArchive::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >*
SparseReferenceArrayArchive::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// RectArchive

// required .TSP.Point origin = 1;
inline bool RectArchive::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectArchive::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectArchive::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectArchive::clear_origin() {
  if (origin_ != NULL) origin_->::TSP::Point::Clear();
  clear_has_origin();
}
inline const ::TSP::Point& RectArchive::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::TSP::Point* RectArchive::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::TSP::Point;
  return origin_;
}
inline ::TSP::Point* RectArchive::release_origin() {
  clear_has_origin();
  ::TSP::Point* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void RectArchive::set_allocated_origin(::TSP::Point* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// required .TSP.Size size = 2;
inline bool RectArchive::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectArchive::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectArchive::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectArchive::clear_size() {
  if (size_ != NULL) size_->::TSP::Size::Clear();
  clear_has_size();
}
inline const ::TSP::Size& RectArchive::size() const {
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::TSP::Size* RectArchive::mutable_size() {
  set_has_size();
  if (size_ == NULL) size_ = new ::TSP::Size;
  return size_;
}
inline ::TSP::Size* RectArchive::release_size() {
  clear_has_size();
  ::TSP::Size* temp = size_;
  size_ = NULL;
  return temp;
}
inline void RectArchive::set_allocated_size(::TSP::Size* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
}

// -------------------------------------------------------------------

// ChartsNSNumberDoubleArchive

// optional double number_archive = 1;
inline bool ChartsNSNumberDoubleArchive::has_number_archive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartsNSNumberDoubleArchive::set_has_number_archive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartsNSNumberDoubleArchive::clear_has_number_archive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartsNSNumberDoubleArchive::clear_number_archive() {
  number_archive_ = 0;
  clear_has_number_archive();
}
inline double ChartsNSNumberDoubleArchive::number_archive() const {
  return number_archive_;
}
inline void ChartsNSNumberDoubleArchive::set_number_archive(double value) {
  set_has_number_archive();
  number_archive_ = value;
}

// -------------------------------------------------------------------

// ChartsNSArrayOfNSNumberDoubleArchive

// repeated double numbers = 1;
inline int ChartsNSArrayOfNSNumberDoubleArchive::numbers_size() const {
  return numbers_.size();
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::clear_numbers() {
  numbers_.Clear();
}
inline double ChartsNSArrayOfNSNumberDoubleArchive::numbers(int index) const {
  return numbers_.Get(index);
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::set_numbers(int index, double value) {
  numbers_.Set(index, value);
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::add_numbers(double value) {
  numbers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
ChartsNSArrayOfNSNumberDoubleArchive::numbers() const {
  return numbers_;
}
inline ::google::protobuf::RepeatedField< double >*
ChartsNSArrayOfNSNumberDoubleArchive::mutable_numbers() {
  return &numbers_;
}

// -------------------------------------------------------------------

// DEPRECATEDChart3DFillArchive

// optional .TSD.FillArchive fill = 1;
inline bool DEPRECATEDChart3DFillArchive::has_fill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DEPRECATEDChart3DFillArchive::set_has_fill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DEPRECATEDChart3DFillArchive::clear_has_fill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DEPRECATEDChart3DFillArchive::clear_fill() {
  if (fill_ != NULL) fill_->::TSD::FillArchive::Clear();
  clear_has_fill();
}
inline const ::TSD::FillArchive& DEPRECATEDChart3DFillArchive::fill() const {
  return fill_ != NULL ? *fill_ : *default_instance_->fill_;
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) fill_ = new ::TSD::FillArchive;
  return fill_;
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::release_fill() {
  clear_has_fill();
  ::TSD::FillArchive* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    set_has_fill();
  } else {
    clear_has_fill();
  }
}

// optional .TSCH.Chart3DLightingModelArchive lightingmodel = 2;
inline bool DEPRECATEDChart3DFillArchive::has_lightingmodel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DEPRECATEDChart3DFillArchive::set_has_lightingmodel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DEPRECATEDChart3DFillArchive::clear_has_lightingmodel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DEPRECATEDChart3DFillArchive::clear_lightingmodel() {
  if (lightingmodel_ != NULL) lightingmodel_->::TSCH::Chart3DLightingModelArchive::Clear();
  clear_has_lightingmodel();
}
inline const ::TSCH::Chart3DLightingModelArchive& DEPRECATEDChart3DFillArchive::lightingmodel() const {
  return lightingmodel_ != NULL ? *lightingmodel_ : *default_instance_->lightingmodel_;
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::mutable_lightingmodel() {
  set_has_lightingmodel();
  if (lightingmodel_ == NULL) lightingmodel_ = new ::TSCH::Chart3DLightingModelArchive;
  return lightingmodel_;
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::release_lightingmodel() {
  clear_has_lightingmodel();
  ::TSCH::Chart3DLightingModelArchive* temp = lightingmodel_;
  lightingmodel_ = NULL;
  return temp;
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_lightingmodel(::TSCH::Chart3DLightingModelArchive* lightingmodel) {
  delete lightingmodel_;
  lightingmodel_ = lightingmodel;
  if (lightingmodel) {
    set_has_lightingmodel();
  } else {
    clear_has_lightingmodel();
  }
}

// optional string textureset_id = 3;
inline bool DEPRECATEDChart3DFillArchive::has_textureset_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DEPRECATEDChart3DFillArchive::set_has_textureset_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DEPRECATEDChart3DFillArchive::clear_has_textureset_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DEPRECATEDChart3DFillArchive::clear_textureset_id() {
  if (textureset_id_ != &::google::protobuf::internal::kEmptyString) {
    textureset_id_->clear();
  }
  clear_has_textureset_id();
}
inline const ::std::string& DEPRECATEDChart3DFillArchive::textureset_id() const {
  return *textureset_id_;
}
inline void DEPRECATEDChart3DFillArchive::set_textureset_id(const ::std::string& value) {
  set_has_textureset_id();
  if (textureset_id_ == &::google::protobuf::internal::kEmptyString) {
    textureset_id_ = new ::std::string;
  }
  textureset_id_->assign(value);
}
inline void DEPRECATEDChart3DFillArchive::set_textureset_id(const char* value) {
  set_has_textureset_id();
  if (textureset_id_ == &::google::protobuf::internal::kEmptyString) {
    textureset_id_ = new ::std::string;
  }
  textureset_id_->assign(value);
}
inline void DEPRECATEDChart3DFillArchive::set_textureset_id(const char* value, size_t size) {
  set_has_textureset_id();
  if (textureset_id_ == &::google::protobuf::internal::kEmptyString) {
    textureset_id_ = new ::std::string;
  }
  textureset_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DEPRECATEDChart3DFillArchive::mutable_textureset_id() {
  set_has_textureset_id();
  if (textureset_id_ == &::google::protobuf::internal::kEmptyString) {
    textureset_id_ = new ::std::string;
  }
  return textureset_id_;
}
inline ::std::string* DEPRECATEDChart3DFillArchive::release_textureset_id() {
  clear_has_textureset_id();
  if (textureset_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = textureset_id_;
    textureset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_textureset_id(::std::string* textureset_id) {
  if (textureset_id_ != &::google::protobuf::internal::kEmptyString) {
    delete textureset_id_;
  }
  if (textureset_id) {
    set_has_textureset_id();
    textureset_id_ = textureset_id;
  } else {
    clear_has_textureset_id();
    textureset_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSCH.FillPropertyType fill_type = 4;
inline bool DEPRECATEDChart3DFillArchive::has_fill_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DEPRECATEDChart3DFillArchive::set_has_fill_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DEPRECATEDChart3DFillArchive::clear_has_fill_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DEPRECATEDChart3DFillArchive::clear_fill_type() {
  fill_type_ = 0;
  clear_has_fill_type();
}
inline ::TSCH::FillPropertyType DEPRECATEDChart3DFillArchive::fill_type() const {
  return static_cast< ::TSCH::FillPropertyType >(fill_type_);
}
inline void DEPRECATEDChart3DFillArchive::set_fill_type(::TSCH::FillPropertyType value) {
  assert(::TSCH::FillPropertyType_IsValid(value));
  set_has_fill_type();
  fill_type_ = value;
}

// optional uint32 series_index = 5;
inline bool DEPRECATEDChart3DFillArchive::has_series_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DEPRECATEDChart3DFillArchive::set_has_series_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DEPRECATEDChart3DFillArchive::clear_has_series_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DEPRECATEDChart3DFillArchive::clear_series_index() {
  series_index_ = 0u;
  clear_has_series_index();
}
inline ::google::protobuf::uint32 DEPRECATEDChart3DFillArchive::series_index() const {
  return series_index_;
}
inline void DEPRECATEDChart3DFillArchive::set_series_index(::google::protobuf::uint32 value) {
  set_has_series_index();
  series_index_ = value;
}

// -------------------------------------------------------------------

// ChartStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChartNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartNonStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartNonStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartNonStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartNonStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartNonStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// LegendStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool LegendStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegendStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegendStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegendStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& LegendStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* LegendStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* LegendStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void LegendStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// LegendNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool LegendNonStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegendNonStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegendNonStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegendNonStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& LegendNonStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void LegendNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChartAxisStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartAxisStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartAxisStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartAxisStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartAxisStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartAxisStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartAxisStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChartAxisNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartAxisNonStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartAxisNonStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartAxisNonStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartAxisNonStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartAxisNonStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartAxisNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChartSeriesStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartSeriesStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartSeriesStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartSeriesStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartSeriesStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartSeriesStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartSeriesStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ChartSeriesNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartSeriesNonStyleArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartSeriesNonStyleArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartSeriesNonStyleArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartSeriesNonStyleArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleArchive& ChartSeriesNonStyleArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleArchive;
  return super_;
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::release_super() {
  clear_has_super();
  ::TSS::StyleArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ChartSeriesNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSCH

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::ChartType>() {
  return ::TSCH::ChartType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::AxisType>() {
  return ::TSCH::AxisType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::ScatterFormat>() {
  return ::TSCH::ScatterFormat_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::SeriesDirection>() {
  return ::TSCH::SeriesDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::NumberValueType>() {
  return ::TSCH::NumberValueType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::NegativeNumberStyle>() {
  return ::TSCH::NegativeNumberStyle_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::FractionAccuracy>() {
  return ::TSCH::FractionAccuracy_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSCHArchives_2eCommon_2eproto__INCLUDED
