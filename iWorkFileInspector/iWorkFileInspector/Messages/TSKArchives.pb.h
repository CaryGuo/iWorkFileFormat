// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSKArchives.proto

#ifndef PROTOBUF_TSKArchives_2eproto__INCLUDED
#define PROTOBUF_TSKArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
// @@protoc_insertion_point(includes)

namespace TSK {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSKArchives_2eproto();
void protobuf_AssignDesc_TSKArchives_2eproto();
void protobuf_ShutdownFile_TSKArchives_2eproto();

class TreeNode;
class CommandHistory;
class DocumentArchive;
class DocumentSupportArchive;
class ViewStateArchive;
class CommandArchive;
class CommandGroupArchive;
class CommandContainerArchive;
class ReplaceAllChildCommandArchive;
class ReplaceAllCommandArchive;
class ShuffleMappingArchive;
class ShuffleMappingArchive_Entry;
class ProgressiveCommandGroupArchive;
class CommandSelectionBehaviorHistoryArchive;
class CommandSelectionBehaviorHistoryArchive_Entry;
class UndoRedoStateCommandSelectionBehaviorArchive;
class FormatStructArchive;
class CustomFormatArchive;
class CustomFormatArchive_Condition;
class AnnotationAuthorArchive;
class DeprecatedChangeAuthorArchive;
class AnnotationAuthorStorageArchive;
class AddAnnotationAuthorCommandArchive;
class SetAnnotationAuthorColorCommandArchive;

// ===================================================================

class TreeNode : public ::google::protobuf::Message {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeNode& default_instance();

  void Swap(TreeNode* other);

  // implements Message ----------------------------------------------

  TreeNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .TSP.Reference children = 2;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 2;
  inline const ::TSP::Reference& children(int index) const;
  inline ::TSP::Reference* mutable_children(int index);
  inline ::TSP::Reference* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();

  // optional .TSP.Reference object = 3;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 3;
  inline const ::TSP::Reference& object() const;
  inline ::TSP::Reference* mutable_object();
  inline ::TSP::Reference* release_object();
  inline void set_allocated_object(::TSP::Reference* object);

  // @@protoc_insertion_point(class_scope:TSK.TreeNode)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > children_;
  ::TSP::Reference* object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static TreeNode* default_instance_;
};
// -------------------------------------------------------------------

class CommandHistory : public ::google::protobuf::Message {
 public:
  CommandHistory();
  virtual ~CommandHistory();

  CommandHistory(const CommandHistory& from);

  inline CommandHistory& operator=(const CommandHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandHistory& default_instance();

  void Swap(CommandHistory* other);

  // implements Message ----------------------------------------------

  CommandHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandHistory& from);
  void MergeFrom(const CommandHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 undo_count = 1;
  inline bool has_undo_count() const;
  inline void clear_undo_count();
  static const int kUndoCountFieldNumber = 1;
  inline ::google::protobuf::uint32 undo_count() const;
  inline void set_undo_count(::google::protobuf::uint32 value);

  // repeated .TSP.Reference commands = 2;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 2;
  inline const ::TSP::Reference& commands(int index) const;
  inline ::TSP::Reference* mutable_commands(int index);
  inline ::TSP::Reference* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();

  // repeated .TSP.Reference marked_redo_commands = 3;
  inline int marked_redo_commands_size() const;
  inline void clear_marked_redo_commands();
  static const int kMarkedRedoCommandsFieldNumber = 3;
  inline const ::TSP::Reference& marked_redo_commands(int index) const;
  inline ::TSP::Reference* mutable_marked_redo_commands(int index);
  inline ::TSP::Reference* add_marked_redo_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      marked_redo_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_marked_redo_commands();

  // optional .TSP.Reference pending_preflight_command = 4;
  inline bool has_pending_preflight_command() const;
  inline void clear_pending_preflight_command();
  static const int kPendingPreflightCommandFieldNumber = 4;
  inline const ::TSP::Reference& pending_preflight_command() const;
  inline ::TSP::Reference* mutable_pending_preflight_command();
  inline ::TSP::Reference* release_pending_preflight_command();
  inline void set_allocated_pending_preflight_command(::TSP::Reference* pending_preflight_command);

  // optional bool fixed_radar_13365177 = 10;
  inline bool has_fixed_radar_13365177() const;
  inline void clear_fixed_radar_13365177();
  static const int kFixedRadar13365177FieldNumber = 10;
  inline bool fixed_radar_13365177() const;
  inline void set_fixed_radar_13365177(bool value);

  // @@protoc_insertion_point(class_scope:TSK.CommandHistory)
 private:
  inline void set_has_undo_count();
  inline void clear_has_undo_count();
  inline void set_has_pending_preflight_command();
  inline void clear_has_pending_preflight_command();
  inline void set_has_fixed_radar_13365177();
  inline void clear_has_fixed_radar_13365177();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > commands_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > marked_redo_commands_;
  ::google::protobuf::uint32 undo_count_;
  bool fixed_radar_13365177_;
  ::TSP::Reference* pending_preflight_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandHistory* default_instance_;
};
// -------------------------------------------------------------------

class DocumentArchive : public ::google::protobuf::Message {
 public:
  DocumentArchive();
  virtual ~DocumentArchive();

  DocumentArchive(const DocumentArchive& from);

  inline DocumentArchive& operator=(const DocumentArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentArchive& default_instance();

  void Swap(DocumentArchive* other);

  // implements Message ----------------------------------------------

  DocumentArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentArchive& from);
  void MergeFrom(const DocumentArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string locale_identifier = 4;
  inline bool has_locale_identifier() const;
  inline void clear_locale_identifier();
  static const int kLocaleIdentifierFieldNumber = 4;
  inline const ::std::string& locale_identifier() const;
  inline void set_locale_identifier(const ::std::string& value);
  inline void set_locale_identifier(const char* value);
  inline void set_locale_identifier(const char* value, size_t size);
  inline ::std::string* mutable_locale_identifier();
  inline ::std::string* release_locale_identifier();
  inline void set_allocated_locale_identifier(::std::string* locale_identifier);

  // optional .TSP.Reference annotation_author_storage = 7;
  inline bool has_annotation_author_storage() const;
  inline void clear_annotation_author_storage();
  static const int kAnnotationAuthorStorageFieldNumber = 7;
  inline const ::TSP::Reference& annotation_author_storage() const;
  inline ::TSP::Reference* mutable_annotation_author_storage();
  inline ::TSP::Reference* release_annotation_author_storage();
  inline void set_allocated_annotation_author_storage(::TSP::Reference* annotation_author_storage);

  // @@protoc_insertion_point(class_scope:TSK.DocumentArchive)
 private:
  inline void set_has_locale_identifier();
  inline void clear_has_locale_identifier();
  inline void set_has_annotation_author_storage();
  inline void clear_has_annotation_author_storage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* locale_identifier_;
  ::TSP::Reference* annotation_author_storage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentArchive* default_instance_;
};
// -------------------------------------------------------------------

class DocumentSupportArchive : public ::google::protobuf::Message {
 public:
  DocumentSupportArchive();
  virtual ~DocumentSupportArchive();

  DocumentSupportArchive(const DocumentSupportArchive& from);

  inline DocumentSupportArchive& operator=(const DocumentSupportArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentSupportArchive& default_instance();

  void Swap(DocumentSupportArchive* other);

  // implements Message ----------------------------------------------

  DocumentSupportArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentSupportArchive& from);
  void MergeFrom(const DocumentSupportArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference command_history = 1;
  inline bool has_command_history() const;
  inline void clear_command_history();
  static const int kCommandHistoryFieldNumber = 1;
  inline const ::TSP::Reference& command_history() const;
  inline ::TSP::Reference* mutable_command_history();
  inline ::TSP::Reference* release_command_history();
  inline void set_allocated_command_history(::TSP::Reference* command_history);

  // optional .TSP.Reference command_selection_behavior_history = 2;
  inline bool has_command_selection_behavior_history() const;
  inline void clear_command_selection_behavior_history();
  static const int kCommandSelectionBehaviorHistoryFieldNumber = 2;
  inline const ::TSP::Reference& command_selection_behavior_history() const;
  inline ::TSP::Reference* mutable_command_selection_behavior_history();
  inline ::TSP::Reference* release_command_selection_behavior_history();
  inline void set_allocated_command_selection_behavior_history(::TSP::Reference* command_selection_behavior_history);

  // optional uint32 undo_count = 4;
  inline bool has_undo_count() const;
  inline void clear_undo_count();
  static const int kUndoCountFieldNumber = 4;
  inline ::google::protobuf::uint32 undo_count() const;
  inline void set_undo_count(::google::protobuf::uint32 value);

  // optional uint32 redo_count = 5;
  inline bool has_redo_count() const;
  inline void clear_redo_count();
  static const int kRedoCountFieldNumber = 5;
  inline ::google::protobuf::uint32 redo_count() const;
  inline void set_redo_count(::google::protobuf::uint32 value);

  // optional string undo_action_string = 6;
  inline bool has_undo_action_string() const;
  inline void clear_undo_action_string();
  static const int kUndoActionStringFieldNumber = 6;
  inline const ::std::string& undo_action_string() const;
  inline void set_undo_action_string(const ::std::string& value);
  inline void set_undo_action_string(const char* value);
  inline void set_undo_action_string(const char* value, size_t size);
  inline ::std::string* mutable_undo_action_string();
  inline ::std::string* release_undo_action_string();
  inline void set_allocated_undo_action_string(::std::string* undo_action_string);

  // optional string redo_action_string = 7;
  inline bool has_redo_action_string() const;
  inline void clear_redo_action_string();
  static const int kRedoActionStringFieldNumber = 7;
  inline const ::std::string& redo_action_string() const;
  inline void set_redo_action_string(const ::std::string& value);
  inline void set_redo_action_string(const char* value);
  inline void set_redo_action_string(const char* value, size_t size);
  inline ::std::string* mutable_redo_action_string();
  inline ::std::string* release_redo_action_string();
  inline void set_allocated_redo_action_string(::std::string* redo_action_string);

  // optional .TSP.Reference web_state = 8;
  inline bool has_web_state() const;
  inline void clear_web_state();
  static const int kWebStateFieldNumber = 8;
  inline const ::TSP::Reference& web_state() const;
  inline ::TSP::Reference* mutable_web_state();
  inline ::TSP::Reference* release_web_state();
  inline void set_allocated_web_state(::TSP::Reference* web_state);

  // @@protoc_insertion_point(class_scope:TSK.DocumentSupportArchive)
 private:
  inline void set_has_command_history();
  inline void clear_has_command_history();
  inline void set_has_command_selection_behavior_history();
  inline void clear_has_command_selection_behavior_history();
  inline void set_has_undo_count();
  inline void clear_has_undo_count();
  inline void set_has_redo_count();
  inline void clear_has_redo_count();
  inline void set_has_undo_action_string();
  inline void clear_has_undo_action_string();
  inline void set_has_redo_action_string();
  inline void clear_has_redo_action_string();
  inline void set_has_web_state();
  inline void clear_has_web_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* command_history_;
  ::TSP::Reference* command_selection_behavior_history_;
  ::google::protobuf::uint32 undo_count_;
  ::google::protobuf::uint32 redo_count_;
  ::std::string* undo_action_string_;
  ::std::string* redo_action_string_;
  ::TSP::Reference* web_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static DocumentSupportArchive* default_instance_;
};
// -------------------------------------------------------------------

class ViewStateArchive : public ::google::protobuf::Message {
 public:
  ViewStateArchive();
  virtual ~ViewStateArchive();

  ViewStateArchive(const ViewStateArchive& from);

  inline ViewStateArchive& operator=(const ViewStateArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ViewStateArchive& default_instance();

  void Swap(ViewStateArchive* other);

  // implements Message ----------------------------------------------

  ViewStateArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ViewStateArchive& from);
  void MergeFrom(const ViewStateArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference view_state_root = 1;
  inline bool has_view_state_root() const;
  inline void clear_view_state_root();
  static const int kViewStateRootFieldNumber = 1;
  inline const ::TSP::Reference& view_state_root() const;
  inline ::TSP::Reference* mutable_view_state_root();
  inline ::TSP::Reference* release_view_state_root();
  inline void set_allocated_view_state_root(::TSP::Reference* view_state_root);

  // @@protoc_insertion_point(class_scope:TSK.ViewStateArchive)
 private:
  inline void set_has_view_state_root();
  inline void clear_has_view_state_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* view_state_root_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ViewStateArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandArchive : public ::google::protobuf::Message {
 public:
  CommandArchive();
  virtual ~CommandArchive();

  CommandArchive(const CommandArchive& from);

  inline CommandArchive& operator=(const CommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandArchive& default_instance();

  void Swap(CommandArchive* other);

  // implements Message ----------------------------------------------

  CommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandArchive& from);
  void MergeFrom(const CommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference undoRedoState = 1;
  inline bool has_undoredostate() const;
  inline void clear_undoredostate();
  static const int kUndoRedoStateFieldNumber = 1;
  inline const ::TSP::Reference& undoredostate() const;
  inline ::TSP::Reference* mutable_undoredostate();
  inline ::TSP::Reference* release_undoredostate();
  inline void set_allocated_undoredostate(::TSP::Reference* undoredostate);

  // optional .TSP.Reference undoCollection = 2;
  inline bool has_undocollection() const;
  inline void clear_undocollection();
  static const int kUndoCollectionFieldNumber = 2;
  inline const ::TSP::Reference& undocollection() const;
  inline ::TSP::Reference* mutable_undocollection();
  inline ::TSP::Reference* release_undocollection();
  inline void set_allocated_undocollection(::TSP::Reference* undocollection);

  // @@protoc_insertion_point(class_scope:TSK.CommandArchive)
 private:
  inline void set_has_undoredostate();
  inline void clear_has_undoredostate();
  inline void set_has_undocollection();
  inline void clear_has_undocollection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* undoredostate_;
  ::TSP::Reference* undocollection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandGroupArchive : public ::google::protobuf::Message {
 public:
  CommandGroupArchive();
  virtual ~CommandGroupArchive();

  CommandGroupArchive(const CommandGroupArchive& from);

  inline CommandGroupArchive& operator=(const CommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandGroupArchive& default_instance();

  void Swap(CommandGroupArchive* other);

  // implements Message ----------------------------------------------

  CommandGroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandGroupArchive& from);
  void MergeFrom(const CommandGroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference commands = 2;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 2;
  inline const ::TSP::Reference& commands(int index) const;
  inline ::TSP::Reference* mutable_commands(int index);
  inline ::TSP::Reference* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();

  // optional .TSP.IndexSet process_results = 3;
  inline bool has_process_results() const;
  inline void clear_process_results();
  static const int kProcessResultsFieldNumber = 3;
  inline const ::TSP::IndexSet& process_results() const;
  inline ::TSP::IndexSet* mutable_process_results();
  inline ::TSP::IndexSet* release_process_results();
  inline void set_allocated_process_results(::TSP::IndexSet* process_results);

  // @@protoc_insertion_point(class_scope:TSK.CommandGroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_process_results();
  inline void clear_has_process_results();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > commands_;
  ::TSP::IndexSet* process_results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandGroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandContainerArchive : public ::google::protobuf::Message {
 public:
  CommandContainerArchive();
  virtual ~CommandContainerArchive();

  CommandContainerArchive(const CommandContainerArchive& from);

  inline CommandContainerArchive& operator=(const CommandContainerArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandContainerArchive& default_instance();

  void Swap(CommandContainerArchive* other);

  // implements Message ----------------------------------------------

  CommandContainerArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandContainerArchive& from);
  void MergeFrom(const CommandContainerArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference commands = 1;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 1;
  inline const ::TSP::Reference& commands(int index) const;
  inline ::TSP::Reference* mutable_commands(int index);
  inline ::TSP::Reference* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();

  // @@protoc_insertion_point(class_scope:TSK.CommandContainerArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > commands_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandContainerArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceAllChildCommandArchive : public ::google::protobuf::Message {
 public:
  ReplaceAllChildCommandArchive();
  virtual ~ReplaceAllChildCommandArchive();

  ReplaceAllChildCommandArchive(const ReplaceAllChildCommandArchive& from);

  inline ReplaceAllChildCommandArchive& operator=(const ReplaceAllChildCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceAllChildCommandArchive& default_instance();

  void Swap(ReplaceAllChildCommandArchive* other);

  // implements Message ----------------------------------------------

  ReplaceAllChildCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceAllChildCommandArchive& from);
  void MergeFrom(const ReplaceAllChildCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSK.ReplaceAllChildCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ReplaceAllChildCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceAllCommandArchive : public ::google::protobuf::Message {
 public:
  ReplaceAllCommandArchive();
  virtual ~ReplaceAllCommandArchive();

  ReplaceAllCommandArchive(const ReplaceAllCommandArchive& from);

  inline ReplaceAllCommandArchive& operator=(const ReplaceAllCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceAllCommandArchive& default_instance();

  void Swap(ReplaceAllCommandArchive* other);

  // implements Message ----------------------------------------------

  ReplaceAllCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceAllCommandArchive& from);
  void MergeFrom(const ReplaceAllCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // repeated .TSP.Reference commands = 2;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 2;
  inline const ::TSP::Reference& commands(int index) const;
  inline ::TSP::Reference* mutable_commands(int index);
  inline ::TSP::Reference* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();

  // required string find_string = 3;
  inline bool has_find_string() const;
  inline void clear_find_string();
  static const int kFindStringFieldNumber = 3;
  inline const ::std::string& find_string() const;
  inline void set_find_string(const ::std::string& value);
  inline void set_find_string(const char* value);
  inline void set_find_string(const char* value, size_t size);
  inline ::std::string* mutable_find_string();
  inline ::std::string* release_find_string();
  inline void set_allocated_find_string(::std::string* find_string);

  // required string replace_string = 4;
  inline bool has_replace_string() const;
  inline void clear_replace_string();
  static const int kReplaceStringFieldNumber = 4;
  inline const ::std::string& replace_string() const;
  inline void set_replace_string(const ::std::string& value);
  inline void set_replace_string(const char* value);
  inline void set_replace_string(const char* value, size_t size);
  inline ::std::string* mutable_replace_string();
  inline ::std::string* release_replace_string();
  inline void set_allocated_replace_string(::std::string* replace_string);

  // required uint32 options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline ::google::protobuf::uint32 options() const;
  inline void set_options(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSK.ReplaceAllCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_find_string();
  inline void clear_has_find_string();
  inline void set_has_replace_string();
  inline void clear_has_replace_string();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > commands_;
  ::std::string* find_string_;
  ::std::string* replace_string_;
  ::google::protobuf::uint32 options_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ReplaceAllCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShuffleMappingArchive_Entry : public ::google::protobuf::Message {
 public:
  ShuffleMappingArchive_Entry();
  virtual ~ShuffleMappingArchive_Entry();

  ShuffleMappingArchive_Entry(const ShuffleMappingArchive_Entry& from);

  inline ShuffleMappingArchive_Entry& operator=(const ShuffleMappingArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShuffleMappingArchive_Entry& default_instance();

  void Swap(ShuffleMappingArchive_Entry* other);

  // implements Message ----------------------------------------------

  ShuffleMappingArchive_Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShuffleMappingArchive_Entry& from);
  void MergeFrom(const ShuffleMappingArchive_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline ::google::protobuf::uint32 from() const;
  inline void set_from(::google::protobuf::uint32 value);

  // required uint32 to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline ::google::protobuf::uint32 to() const;
  inline void set_to(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSK.ShuffleMappingArchive.Entry)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 from_;
  ::google::protobuf::uint32 to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ShuffleMappingArchive_Entry* default_instance_;
};
// -------------------------------------------------------------------

class ShuffleMappingArchive : public ::google::protobuf::Message {
 public:
  ShuffleMappingArchive();
  virtual ~ShuffleMappingArchive();

  ShuffleMappingArchive(const ShuffleMappingArchive& from);

  inline ShuffleMappingArchive& operator=(const ShuffleMappingArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShuffleMappingArchive& default_instance();

  void Swap(ShuffleMappingArchive* other);

  // implements Message ----------------------------------------------

  ShuffleMappingArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShuffleMappingArchive& from);
  void MergeFrom(const ShuffleMappingArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ShuffleMappingArchive_Entry Entry;

  // accessors -------------------------------------------------------

  // required uint32 start_index = 1;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 start_index() const;
  inline void set_start_index(::google::protobuf::uint32 value);

  // required uint32 end_index = 2;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 end_index() const;
  inline void set_end_index(::google::protobuf::uint32 value);

  // repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline const ::TSK::ShuffleMappingArchive_Entry& entries(int index) const;
  inline ::TSK::ShuffleMappingArchive_Entry* mutable_entries(int index);
  inline ::TSK::ShuffleMappingArchive_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >*
      mutable_entries();

  // optional bool is_vertical = 4 [default = true];
  inline bool has_is_vertical() const;
  inline void clear_is_vertical();
  static const int kIsVerticalFieldNumber = 4;
  inline bool is_vertical() const;
  inline void set_is_vertical(bool value);

  // optional bool is_move_operation = 5 [default = false];
  inline bool has_is_move_operation() const;
  inline void clear_is_move_operation();
  static const int kIsMoveOperationFieldNumber = 5;
  inline bool is_move_operation() const;
  inline void set_is_move_operation(bool value);

  // optional uint32 first_moved_index = 6 [default = 0];
  inline bool has_first_moved_index() const;
  inline void clear_first_moved_index();
  static const int kFirstMovedIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 first_moved_index() const;
  inline void set_first_moved_index(::google::protobuf::uint32 value);

  // optional uint32 destination_index_for_move = 7 [default = 0];
  inline bool has_destination_index_for_move() const;
  inline void clear_destination_index_for_move();
  static const int kDestinationIndexForMoveFieldNumber = 7;
  inline ::google::protobuf::uint32 destination_index_for_move() const;
  inline void set_destination_index_for_move(::google::protobuf::uint32 value);

  // optional uint32 number_of_indices_moved = 8 [default = 0];
  inline bool has_number_of_indices_moved() const;
  inline void clear_number_of_indices_moved();
  static const int kNumberOfIndicesMovedFieldNumber = 8;
  inline ::google::protobuf::uint32 number_of_indices_moved() const;
  inline void set_number_of_indices_moved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSK.ShuffleMappingArchive)
 private:
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();
  inline void set_has_is_vertical();
  inline void clear_has_is_vertical();
  inline void set_has_is_move_operation();
  inline void clear_has_is_move_operation();
  inline void set_has_first_moved_index();
  inline void clear_has_first_moved_index();
  inline void set_has_destination_index_for_move();
  inline void clear_has_destination_index_for_move();
  inline void set_has_number_of_indices_moved();
  inline void clear_has_number_of_indices_moved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_index_;
  ::google::protobuf::uint32 end_index_;
  ::google::protobuf::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry > entries_;
  bool is_vertical_;
  bool is_move_operation_;
  ::google::protobuf::uint32 first_moved_index_;
  ::google::protobuf::uint32 destination_index_for_move_;
  ::google::protobuf::uint32 number_of_indices_moved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ShuffleMappingArchive* default_instance_;
};
// -------------------------------------------------------------------

class ProgressiveCommandGroupArchive : public ::google::protobuf::Message {
 public:
  ProgressiveCommandGroupArchive();
  virtual ~ProgressiveCommandGroupArchive();

  ProgressiveCommandGroupArchive(const ProgressiveCommandGroupArchive& from);

  inline ProgressiveCommandGroupArchive& operator=(const ProgressiveCommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressiveCommandGroupArchive& default_instance();

  void Swap(ProgressiveCommandGroupArchive* other);

  // implements Message ----------------------------------------------

  ProgressiveCommandGroupArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProgressiveCommandGroupArchive& from);
  void MergeFrom(const ProgressiveCommandGroupArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandGroupArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandGroupArchive& super() const;
  inline ::TSK::CommandGroupArchive* mutable_super();
  inline ::TSK::CommandGroupArchive* release_super();
  inline void set_allocated_super(::TSK::CommandGroupArchive* super);

  // @@protoc_insertion_point(class_scope:TSK.ProgressiveCommandGroupArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandGroupArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static ProgressiveCommandGroupArchive* default_instance_;
};
// -------------------------------------------------------------------

class CommandSelectionBehaviorHistoryArchive_Entry : public ::google::protobuf::Message {
 public:
  CommandSelectionBehaviorHistoryArchive_Entry();
  virtual ~CommandSelectionBehaviorHistoryArchive_Entry();

  CommandSelectionBehaviorHistoryArchive_Entry(const CommandSelectionBehaviorHistoryArchive_Entry& from);

  inline CommandSelectionBehaviorHistoryArchive_Entry& operator=(const CommandSelectionBehaviorHistoryArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSelectionBehaviorHistoryArchive_Entry& default_instance();

  void Swap(CommandSelectionBehaviorHistoryArchive_Entry* other);

  // implements Message ----------------------------------------------

  CommandSelectionBehaviorHistoryArchive_Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSelectionBehaviorHistoryArchive_Entry& from);
  void MergeFrom(const CommandSelectionBehaviorHistoryArchive_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSP.Reference command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::TSP::Reference& command() const;
  inline ::TSP::Reference* mutable_command();
  inline ::TSP::Reference* release_command();
  inline void set_allocated_command(::TSP::Reference* command);

  // required .TSP.Reference command_selection_behavior = 2;
  inline bool has_command_selection_behavior() const;
  inline void clear_command_selection_behavior();
  static const int kCommandSelectionBehaviorFieldNumber = 2;
  inline const ::TSP::Reference& command_selection_behavior() const;
  inline ::TSP::Reference* mutable_command_selection_behavior();
  inline ::TSP::Reference* release_command_selection_behavior();
  inline void set_allocated_command_selection_behavior(::TSP::Reference* command_selection_behavior);

  // @@protoc_insertion_point(class_scope:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_command_selection_behavior();
  inline void clear_has_command_selection_behavior();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* command_;
  ::TSP::Reference* command_selection_behavior_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSelectionBehaviorHistoryArchive_Entry* default_instance_;
};
// -------------------------------------------------------------------

class CommandSelectionBehaviorHistoryArchive : public ::google::protobuf::Message {
 public:
  CommandSelectionBehaviorHistoryArchive();
  virtual ~CommandSelectionBehaviorHistoryArchive();

  CommandSelectionBehaviorHistoryArchive(const CommandSelectionBehaviorHistoryArchive& from);

  inline CommandSelectionBehaviorHistoryArchive& operator=(const CommandSelectionBehaviorHistoryArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandSelectionBehaviorHistoryArchive& default_instance();

  void Swap(CommandSelectionBehaviorHistoryArchive* other);

  // implements Message ----------------------------------------------

  CommandSelectionBehaviorHistoryArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandSelectionBehaviorHistoryArchive& from);
  void MergeFrom(const CommandSelectionBehaviorHistoryArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommandSelectionBehaviorHistoryArchive_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& entries(int index) const;
  inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* mutable_entries(int index);
  inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:TSK.CommandSelectionBehaviorHistoryArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CommandSelectionBehaviorHistoryArchive* default_instance_;
};
// -------------------------------------------------------------------

class UndoRedoStateCommandSelectionBehaviorArchive : public ::google::protobuf::Message {
 public:
  UndoRedoStateCommandSelectionBehaviorArchive();
  virtual ~UndoRedoStateCommandSelectionBehaviorArchive();

  UndoRedoStateCommandSelectionBehaviorArchive(const UndoRedoStateCommandSelectionBehaviorArchive& from);

  inline UndoRedoStateCommandSelectionBehaviorArchive& operator=(const UndoRedoStateCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndoRedoStateCommandSelectionBehaviorArchive& default_instance();

  void Swap(UndoRedoStateCommandSelectionBehaviorArchive* other);

  // implements Message ----------------------------------------------

  UndoRedoStateCommandSelectionBehaviorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  void MergeFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSP.Reference undo_redo_state = 2;
  inline bool has_undo_redo_state() const;
  inline void clear_undo_redo_state();
  static const int kUndoRedoStateFieldNumber = 2;
  inline const ::TSP::Reference& undo_redo_state() const;
  inline ::TSP::Reference* mutable_undo_redo_state();
  inline ::TSP::Reference* release_undo_redo_state();
  inline void set_allocated_undo_redo_state(::TSP::Reference* undo_redo_state);

  // @@protoc_insertion_point(class_scope:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
 private:
  inline void set_has_undo_redo_state();
  inline void clear_has_undo_redo_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSP::Reference* undo_redo_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static UndoRedoStateCommandSelectionBehaviorArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormatStructArchive : public ::google::protobuf::Message {
 public:
  FormatStructArchive();
  virtual ~FormatStructArchive();

  FormatStructArchive(const FormatStructArchive& from);

  inline FormatStructArchive& operator=(const FormatStructArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatStructArchive& default_instance();

  void Swap(FormatStructArchive* other);

  // implements Message ----------------------------------------------

  FormatStructArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormatStructArchive& from);
  void MergeFrom(const FormatStructArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 format_type = 1;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // optional uint32 decimal_places = 2;
  inline bool has_decimal_places() const;
  inline void clear_decimal_places();
  static const int kDecimalPlacesFieldNumber = 2;
  inline ::google::protobuf::uint32 decimal_places() const;
  inline void set_decimal_places(::google::protobuf::uint32 value);

  // optional string currency_code = 3;
  inline bool has_currency_code() const;
  inline void clear_currency_code();
  static const int kCurrencyCodeFieldNumber = 3;
  inline const ::std::string& currency_code() const;
  inline void set_currency_code(const ::std::string& value);
  inline void set_currency_code(const char* value);
  inline void set_currency_code(const char* value, size_t size);
  inline ::std::string* mutable_currency_code();
  inline ::std::string* release_currency_code();
  inline void set_allocated_currency_code(::std::string* currency_code);

  // optional uint32 negative_style = 4;
  inline bool has_negative_style() const;
  inline void clear_negative_style();
  static const int kNegativeStyleFieldNumber = 4;
  inline ::google::protobuf::uint32 negative_style() const;
  inline void set_negative_style(::google::protobuf::uint32 value);

  // optional bool show_thousands_separator = 5;
  inline bool has_show_thousands_separator() const;
  inline void clear_show_thousands_separator();
  static const int kShowThousandsSeparatorFieldNumber = 5;
  inline bool show_thousands_separator() const;
  inline void set_show_thousands_separator(bool value);

  // optional bool use_accounting_style = 6;
  inline bool has_use_accounting_style() const;
  inline void clear_use_accounting_style();
  static const int kUseAccountingStyleFieldNumber = 6;
  inline bool use_accounting_style() const;
  inline void set_use_accounting_style(bool value);

  // optional uint32 duration_style = 7;
  inline bool has_duration_style() const;
  inline void clear_duration_style();
  static const int kDurationStyleFieldNumber = 7;
  inline ::google::protobuf::uint32 duration_style() const;
  inline void set_duration_style(::google::protobuf::uint32 value);

  // optional uint32 base = 8;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 8;
  inline ::google::protobuf::uint32 base() const;
  inline void set_base(::google::protobuf::uint32 value);

  // optional uint32 base_places = 9;
  inline bool has_base_places() const;
  inline void clear_base_places();
  static const int kBasePlacesFieldNumber = 9;
  inline ::google::protobuf::uint32 base_places() const;
  inline void set_base_places(::google::protobuf::uint32 value);

  // optional bool base_use_minus_sign = 10;
  inline bool has_base_use_minus_sign() const;
  inline void clear_base_use_minus_sign();
  static const int kBaseUseMinusSignFieldNumber = 10;
  inline bool base_use_minus_sign() const;
  inline void set_base_use_minus_sign(bool value);

  // optional uint32 fraction_accuracy = 11;
  inline bool has_fraction_accuracy() const;
  inline void clear_fraction_accuracy();
  static const int kFractionAccuracyFieldNumber = 11;
  inline ::google::protobuf::uint32 fraction_accuracy() const;
  inline void set_fraction_accuracy(::google::protobuf::uint32 value);

  // optional bool suppress_date_format = 12;
  inline bool has_suppress_date_format() const;
  inline void clear_suppress_date_format();
  static const int kSuppressDateFormatFieldNumber = 12;
  inline bool suppress_date_format() const;
  inline void set_suppress_date_format(bool value);

  // optional bool suppress_time_format = 13;
  inline bool has_suppress_time_format() const;
  inline void clear_suppress_time_format();
  static const int kSuppressTimeFormatFieldNumber = 13;
  inline bool suppress_time_format() const;
  inline void set_suppress_time_format(bool value);

  // optional string date_time_format = 14;
  inline bool has_date_time_format() const;
  inline void clear_date_time_format();
  static const int kDateTimeFormatFieldNumber = 14;
  inline const ::std::string& date_time_format() const;
  inline void set_date_time_format(const ::std::string& value);
  inline void set_date_time_format(const char* value);
  inline void set_date_time_format(const char* value, size_t size);
  inline ::std::string* mutable_date_time_format();
  inline ::std::string* release_date_time_format();
  inline void set_allocated_date_time_format(::std::string* date_time_format);

  // optional uint32 duration_unit_largest = 15;
  inline bool has_duration_unit_largest() const;
  inline void clear_duration_unit_largest();
  static const int kDurationUnitLargestFieldNumber = 15;
  inline ::google::protobuf::uint32 duration_unit_largest() const;
  inline void set_duration_unit_largest(::google::protobuf::uint32 value);

  // optional uint32 duration_unit_smallest = 16;
  inline bool has_duration_unit_smallest() const;
  inline void clear_duration_unit_smallest();
  static const int kDurationUnitSmallestFieldNumber = 16;
  inline ::google::protobuf::uint32 duration_unit_smallest() const;
  inline void set_duration_unit_smallest(::google::protobuf::uint32 value);

  // optional uint32 custom_id = 17;
  inline bool has_custom_id() const;
  inline void clear_custom_id();
  static const int kCustomIdFieldNumber = 17;
  inline ::google::protobuf::uint32 custom_id() const;
  inline void set_custom_id(::google::protobuf::uint32 value);

  // optional string custom_format_string = 18;
  inline bool has_custom_format_string() const;
  inline void clear_custom_format_string();
  static const int kCustomFormatStringFieldNumber = 18;
  inline const ::std::string& custom_format_string() const;
  inline void set_custom_format_string(const ::std::string& value);
  inline void set_custom_format_string(const char* value);
  inline void set_custom_format_string(const char* value, size_t size);
  inline ::std::string* mutable_custom_format_string();
  inline ::std::string* release_custom_format_string();
  inline void set_allocated_custom_format_string(::std::string* custom_format_string);

  // optional double scale_factor = 19;
  inline bool has_scale_factor() const;
  inline void clear_scale_factor();
  static const int kScaleFactorFieldNumber = 19;
  inline double scale_factor() const;
  inline void set_scale_factor(double value);

  // optional bool requires_fraction_replacement = 20;
  inline bool has_requires_fraction_replacement() const;
  inline void clear_requires_fraction_replacement();
  static const int kRequiresFractionReplacementFieldNumber = 20;
  inline bool requires_fraction_replacement() const;
  inline void set_requires_fraction_replacement(bool value);

  // optional double control_minimum = 21;
  inline bool has_control_minimum() const;
  inline void clear_control_minimum();
  static const int kControlMinimumFieldNumber = 21;
  inline double control_minimum() const;
  inline void set_control_minimum(double value);

  // optional double control_maximum = 22;
  inline bool has_control_maximum() const;
  inline void clear_control_maximum();
  static const int kControlMaximumFieldNumber = 22;
  inline double control_maximum() const;
  inline void set_control_maximum(double value);

  // optional double control_increment = 23;
  inline bool has_control_increment() const;
  inline void clear_control_increment();
  static const int kControlIncrementFieldNumber = 23;
  inline double control_increment() const;
  inline void set_control_increment(double value);

  // optional uint32 control_format_type = 24;
  inline bool has_control_format_type() const;
  inline void clear_control_format_type();
  static const int kControlFormatTypeFieldNumber = 24;
  inline ::google::protobuf::uint32 control_format_type() const;
  inline void set_control_format_type(::google::protobuf::uint32 value);

  // optional uint32 slider_orientation = 25;
  inline bool has_slider_orientation() const;
  inline void clear_slider_orientation();
  static const int kSliderOrientationFieldNumber = 25;
  inline ::google::protobuf::uint32 slider_orientation() const;
  inline void set_slider_orientation(::google::protobuf::uint32 value);

  // optional uint32 slider_position = 26;
  inline bool has_slider_position() const;
  inline void clear_slider_position();
  static const int kSliderPositionFieldNumber = 26;
  inline ::google::protobuf::uint32 slider_position() const;
  inline void set_slider_position(::google::protobuf::uint32 value);

  // optional uint32 decimal_width = 27;
  inline bool has_decimal_width() const;
  inline void clear_decimal_width();
  static const int kDecimalWidthFieldNumber = 27;
  inline ::google::protobuf::uint32 decimal_width() const;
  inline void set_decimal_width(::google::protobuf::uint32 value);

  // optional uint32 min_integer_width = 28;
  inline bool has_min_integer_width() const;
  inline void clear_min_integer_width();
  static const int kMinIntegerWidthFieldNumber = 28;
  inline ::google::protobuf::uint32 min_integer_width() const;
  inline void set_min_integer_width(::google::protobuf::uint32 value);

  // optional uint32 num_nonspace_integer_digits = 29;
  inline bool has_num_nonspace_integer_digits() const;
  inline void clear_num_nonspace_integer_digits();
  static const int kNumNonspaceIntegerDigitsFieldNumber = 29;
  inline ::google::protobuf::uint32 num_nonspace_integer_digits() const;
  inline void set_num_nonspace_integer_digits(::google::protobuf::uint32 value);

  // optional uint32 num_nonspace_decimal_digits = 30;
  inline bool has_num_nonspace_decimal_digits() const;
  inline void clear_num_nonspace_decimal_digits();
  static const int kNumNonspaceDecimalDigitsFieldNumber = 30;
  inline ::google::protobuf::uint32 num_nonspace_decimal_digits() const;
  inline void set_num_nonspace_decimal_digits(::google::protobuf::uint32 value);

  // optional uint32 index_from_right_last_integer = 31;
  inline bool has_index_from_right_last_integer() const;
  inline void clear_index_from_right_last_integer();
  static const int kIndexFromRightLastIntegerFieldNumber = 31;
  inline ::google::protobuf::uint32 index_from_right_last_integer() const;
  inline void set_index_from_right_last_integer(::google::protobuf::uint32 value);

  // repeated string interstitial_strings = 32;
  inline int interstitial_strings_size() const;
  inline void clear_interstitial_strings();
  static const int kInterstitialStringsFieldNumber = 32;
  inline const ::std::string& interstitial_strings(int index) const;
  inline ::std::string* mutable_interstitial_strings(int index);
  inline void set_interstitial_strings(int index, const ::std::string& value);
  inline void set_interstitial_strings(int index, const char* value);
  inline void set_interstitial_strings(int index, const char* value, size_t size);
  inline ::std::string* add_interstitial_strings();
  inline void add_interstitial_strings(const ::std::string& value);
  inline void add_interstitial_strings(const char* value);
  inline void add_interstitial_strings(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& interstitial_strings() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_interstitial_strings();

  // optional .TSP.IndexSet inters_str_insertion_indexes = 33;
  inline bool has_inters_str_insertion_indexes() const;
  inline void clear_inters_str_insertion_indexes();
  static const int kIntersStrInsertionIndexesFieldNumber = 33;
  inline const ::TSP::IndexSet& inters_str_insertion_indexes() const;
  inline ::TSP::IndexSet* mutable_inters_str_insertion_indexes();
  inline ::TSP::IndexSet* release_inters_str_insertion_indexes();
  inline void set_allocated_inters_str_insertion_indexes(::TSP::IndexSet* inters_str_insertion_indexes);

  // optional uint32 num_hash_decimal_digits = 34;
  inline bool has_num_hash_decimal_digits() const;
  inline void clear_num_hash_decimal_digits();
  static const int kNumHashDecimalDigitsFieldNumber = 34;
  inline ::google::protobuf::uint32 num_hash_decimal_digits() const;
  inline void set_num_hash_decimal_digits(::google::protobuf::uint32 value);

  // optional uint32 total_num_decimal_digits = 35;
  inline bool has_total_num_decimal_digits() const;
  inline void clear_total_num_decimal_digits();
  static const int kTotalNumDecimalDigitsFieldNumber = 35;
  inline ::google::protobuf::uint32 total_num_decimal_digits() const;
  inline void set_total_num_decimal_digits(::google::protobuf::uint32 value);

  // optional bool is_complex = 36;
  inline bool has_is_complex() const;
  inline void clear_is_complex();
  static const int kIsComplexFieldNumber = 36;
  inline bool is_complex() const;
  inline void set_is_complex(bool value);

  // optional bool contains_integer_token = 37;
  inline bool has_contains_integer_token() const;
  inline void clear_contains_integer_token();
  static const int kContainsIntegerTokenFieldNumber = 37;
  inline bool contains_integer_token() const;
  inline void set_contains_integer_token(bool value);

  // optional uint32 multiple_choice_list_initial_value = 38;
  inline bool has_multiple_choice_list_initial_value() const;
  inline void clear_multiple_choice_list_initial_value();
  static const int kMultipleChoiceListInitialValueFieldNumber = 38;
  inline ::google::protobuf::uint32 multiple_choice_list_initial_value() const;
  inline void set_multiple_choice_list_initial_value(::google::protobuf::uint32 value);

  // optional uint32 multiple_choice_list_id = 39;
  inline bool has_multiple_choice_list_id() const;
  inline void clear_multiple_choice_list_id();
  static const int kMultipleChoiceListIdFieldNumber = 39;
  inline ::google::protobuf::uint32 multiple_choice_list_id() const;
  inline void set_multiple_choice_list_id(::google::protobuf::uint32 value);

  // optional bool use_automatic_duration_units = 40;
  inline bool has_use_automatic_duration_units() const;
  inline void clear_use_automatic_duration_units();
  static const int kUseAutomaticDurationUnitsFieldNumber = 40;
  inline bool use_automatic_duration_units() const;
  inline void set_use_automatic_duration_units(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FormatStructArchive)
  // @@protoc_insertion_point(class_scope:TSK.FormatStructArchive)
 private:
  inline void set_has_format_type();
  inline void clear_has_format_type();
  inline void set_has_decimal_places();
  inline void clear_has_decimal_places();
  inline void set_has_currency_code();
  inline void clear_has_currency_code();
  inline void set_has_negative_style();
  inline void clear_has_negative_style();
  inline void set_has_show_thousands_separator();
  inline void clear_has_show_thousands_separator();
  inline void set_has_use_accounting_style();
  inline void clear_has_use_accounting_style();
  inline void set_has_duration_style();
  inline void clear_has_duration_style();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_base_places();
  inline void clear_has_base_places();
  inline void set_has_base_use_minus_sign();
  inline void clear_has_base_use_minus_sign();
  inline void set_has_fraction_accuracy();
  inline void clear_has_fraction_accuracy();
  inline void set_has_suppress_date_format();
  inline void clear_has_suppress_date_format();
  inline void set_has_suppress_time_format();
  inline void clear_has_suppress_time_format();
  inline void set_has_date_time_format();
  inline void clear_has_date_time_format();
  inline void set_has_duration_unit_largest();
  inline void clear_has_duration_unit_largest();
  inline void set_has_duration_unit_smallest();
  inline void clear_has_duration_unit_smallest();
  inline void set_has_custom_id();
  inline void clear_has_custom_id();
  inline void set_has_custom_format_string();
  inline void clear_has_custom_format_string();
  inline void set_has_scale_factor();
  inline void clear_has_scale_factor();
  inline void set_has_requires_fraction_replacement();
  inline void clear_has_requires_fraction_replacement();
  inline void set_has_control_minimum();
  inline void clear_has_control_minimum();
  inline void set_has_control_maximum();
  inline void clear_has_control_maximum();
  inline void set_has_control_increment();
  inline void clear_has_control_increment();
  inline void set_has_control_format_type();
  inline void clear_has_control_format_type();
  inline void set_has_slider_orientation();
  inline void clear_has_slider_orientation();
  inline void set_has_slider_position();
  inline void clear_has_slider_position();
  inline void set_has_decimal_width();
  inline void clear_has_decimal_width();
  inline void set_has_min_integer_width();
  inline void clear_has_min_integer_width();
  inline void set_has_num_nonspace_integer_digits();
  inline void clear_has_num_nonspace_integer_digits();
  inline void set_has_num_nonspace_decimal_digits();
  inline void clear_has_num_nonspace_decimal_digits();
  inline void set_has_index_from_right_last_integer();
  inline void clear_has_index_from_right_last_integer();
  inline void set_has_inters_str_insertion_indexes();
  inline void clear_has_inters_str_insertion_indexes();
  inline void set_has_num_hash_decimal_digits();
  inline void clear_has_num_hash_decimal_digits();
  inline void set_has_total_num_decimal_digits();
  inline void clear_has_total_num_decimal_digits();
  inline void set_has_is_complex();
  inline void clear_has_is_complex();
  inline void set_has_contains_integer_token();
  inline void clear_has_contains_integer_token();
  inline void set_has_multiple_choice_list_initial_value();
  inline void clear_has_multiple_choice_list_initial_value();
  inline void set_has_multiple_choice_list_id();
  inline void clear_has_multiple_choice_list_id();
  inline void set_has_use_automatic_duration_units();
  inline void clear_has_use_automatic_duration_units();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 format_type_;
  ::google::protobuf::uint32 decimal_places_;
  ::std::string* currency_code_;
  ::google::protobuf::uint32 negative_style_;
  ::google::protobuf::uint32 duration_style_;
  ::google::protobuf::uint32 base_;
  bool show_thousands_separator_;
  bool use_accounting_style_;
  bool base_use_minus_sign_;
  bool suppress_date_format_;
  ::google::protobuf::uint32 base_places_;
  ::google::protobuf::uint32 fraction_accuracy_;
  ::std::string* date_time_format_;
  ::google::protobuf::uint32 duration_unit_largest_;
  ::google::protobuf::uint32 duration_unit_smallest_;
  ::std::string* custom_format_string_;
  double scale_factor_;
  ::google::protobuf::uint32 custom_id_;
  ::google::protobuf::uint32 control_format_type_;
  double control_minimum_;
  double control_maximum_;
  double control_increment_;
  ::google::protobuf::uint32 slider_orientation_;
  ::google::protobuf::uint32 slider_position_;
  bool suppress_time_format_;
  bool requires_fraction_replacement_;
  bool is_complex_;
  bool contains_integer_token_;
  ::google::protobuf::uint32 decimal_width_;
  ::google::protobuf::uint32 min_integer_width_;
  ::google::protobuf::uint32 num_nonspace_integer_digits_;
  ::google::protobuf::uint32 num_nonspace_decimal_digits_;
  ::google::protobuf::uint32 index_from_right_last_integer_;
  ::google::protobuf::RepeatedPtrField< ::std::string> interstitial_strings_;
  ::TSP::IndexSet* inters_str_insertion_indexes_;
  ::google::protobuf::uint32 num_hash_decimal_digits_;
  ::google::protobuf::uint32 total_num_decimal_digits_;
  ::google::protobuf::uint32 multiple_choice_list_initial_value_;
  ::google::protobuf::uint32 multiple_choice_list_id_;
  bool use_automatic_duration_units_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static FormatStructArchive* default_instance_;
};
// -------------------------------------------------------------------

class CustomFormatArchive_Condition : public ::google::protobuf::Message {
 public:
  CustomFormatArchive_Condition();
  virtual ~CustomFormatArchive_Condition();

  CustomFormatArchive_Condition(const CustomFormatArchive_Condition& from);

  inline CustomFormatArchive_Condition& operator=(const CustomFormatArchive_Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomFormatArchive_Condition& default_instance();

  void Swap(CustomFormatArchive_Condition* other);

  // implements Message ----------------------------------------------

  CustomFormatArchive_Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomFormatArchive_Condition& from);
  void MergeFrom(const CustomFormatArchive_Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 condition_type = 1;
  inline bool has_condition_type() const;
  inline void clear_condition_type();
  static const int kConditionTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 condition_type() const;
  inline void set_condition_type(::google::protobuf::uint32 value);

  // optional float condition_value = 2;
  inline bool has_condition_value() const;
  inline void clear_condition_value();
  static const int kConditionValueFieldNumber = 2;
  inline float condition_value() const;
  inline void set_condition_value(float value);

  // required .TSK.FormatStructArchive condition_format = 3;
  inline bool has_condition_format() const;
  inline void clear_condition_format();
  static const int kConditionFormatFieldNumber = 3;
  inline const ::TSK::FormatStructArchive& condition_format() const;
  inline ::TSK::FormatStructArchive* mutable_condition_format();
  inline ::TSK::FormatStructArchive* release_condition_format();
  inline void set_allocated_condition_format(::TSK::FormatStructArchive* condition_format);

  // optional double condition_value_dbl = 4;
  inline bool has_condition_value_dbl() const;
  inline void clear_condition_value_dbl();
  static const int kConditionValueDblFieldNumber = 4;
  inline double condition_value_dbl() const;
  inline void set_condition_value_dbl(double value);

  // @@protoc_insertion_point(class_scope:TSK.CustomFormatArchive.Condition)
 private:
  inline void set_has_condition_type();
  inline void clear_has_condition_type();
  inline void set_has_condition_value();
  inline void clear_has_condition_value();
  inline void set_has_condition_format();
  inline void clear_has_condition_format();
  inline void set_has_condition_value_dbl();
  inline void clear_has_condition_value_dbl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 condition_type_;
  float condition_value_;
  ::TSK::FormatStructArchive* condition_format_;
  double condition_value_dbl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CustomFormatArchive_Condition* default_instance_;
};
// -------------------------------------------------------------------

class CustomFormatArchive : public ::google::protobuf::Message {
 public:
  CustomFormatArchive();
  virtual ~CustomFormatArchive();

  CustomFormatArchive(const CustomFormatArchive& from);

  inline CustomFormatArchive& operator=(const CustomFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomFormatArchive& default_instance();

  void Swap(CustomFormatArchive* other);

  // implements Message ----------------------------------------------

  CustomFormatArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomFormatArchive& from);
  void MergeFrom(const CustomFormatArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CustomFormatArchive_Condition Condition;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 format_type = 2;
  inline bool has_format_type() const;
  inline void clear_format_type();
  static const int kFormatTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 format_type() const;
  inline void set_format_type(::google::protobuf::uint32 value);

  // required .TSK.FormatStructArchive default_format = 3;
  inline bool has_default_format() const;
  inline void clear_default_format();
  static const int kDefaultFormatFieldNumber = 3;
  inline const ::TSK::FormatStructArchive& default_format() const;
  inline ::TSK::FormatStructArchive* mutable_default_format();
  inline ::TSK::FormatStructArchive* release_default_format();
  inline void set_allocated_default_format(::TSK::FormatStructArchive* default_format);

  // repeated .TSK.CustomFormatArchive.Condition conditions = 4;
  inline int conditions_size() const;
  inline void clear_conditions();
  static const int kConditionsFieldNumber = 4;
  inline const ::TSK::CustomFormatArchive_Condition& conditions(int index) const;
  inline ::TSK::CustomFormatArchive_Condition* mutable_conditions(int index);
  inline ::TSK::CustomFormatArchive_Condition* add_conditions();
  inline const ::google::protobuf::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >&
      conditions() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >*
      mutable_conditions();

  // @@protoc_insertion_point(class_scope:TSK.CustomFormatArchive)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_format_type();
  inline void clear_has_format_type();
  inline void set_has_default_format();
  inline void clear_has_default_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::TSK::FormatStructArchive* default_format_;
  ::google::protobuf::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition > conditions_;
  ::google::protobuf::uint32 format_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static CustomFormatArchive* default_instance_;
};
// -------------------------------------------------------------------

class AnnotationAuthorArchive : public ::google::protobuf::Message {
 public:
  AnnotationAuthorArchive();
  virtual ~AnnotationAuthorArchive();

  AnnotationAuthorArchive(const AnnotationAuthorArchive& from);

  inline AnnotationAuthorArchive& operator=(const AnnotationAuthorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotationAuthorArchive& default_instance();

  void Swap(AnnotationAuthorArchive* other);

  // implements Message ----------------------------------------------

  AnnotationAuthorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnnotationAuthorArchive& from);
  void MergeFrom(const AnnotationAuthorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .TSP.Color color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // @@protoc_insertion_point(class_scope:TSK.AnnotationAuthorArchive)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::TSP::Color* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static AnnotationAuthorArchive* default_instance_;
};
// -------------------------------------------------------------------

class DeprecatedChangeAuthorArchive : public ::google::protobuf::Message {
 public:
  DeprecatedChangeAuthorArchive();
  virtual ~DeprecatedChangeAuthorArchive();

  DeprecatedChangeAuthorArchive(const DeprecatedChangeAuthorArchive& from);

  inline DeprecatedChangeAuthorArchive& operator=(const DeprecatedChangeAuthorArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeprecatedChangeAuthorArchive& default_instance();

  void Swap(DeprecatedChangeAuthorArchive* other);

  // implements Message ----------------------------------------------

  DeprecatedChangeAuthorArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeprecatedChangeAuthorArchive& from);
  void MergeFrom(const DeprecatedChangeAuthorArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .TSP.Color change_color = 2;
  inline bool has_change_color() const;
  inline void clear_change_color();
  static const int kChangeColorFieldNumber = 2;
  inline const ::TSP::Color& change_color() const;
  inline ::TSP::Color* mutable_change_color();
  inline ::TSP::Color* release_change_color();
  inline void set_allocated_change_color(::TSP::Color* change_color);

  // @@protoc_insertion_point(class_scope:TSK.DeprecatedChangeAuthorArchive)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_change_color();
  inline void clear_has_change_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::TSP::Color* change_color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static DeprecatedChangeAuthorArchive* default_instance_;
};
// -------------------------------------------------------------------

class AnnotationAuthorStorageArchive : public ::google::protobuf::Message {
 public:
  AnnotationAuthorStorageArchive();
  virtual ~AnnotationAuthorStorageArchive();

  AnnotationAuthorStorageArchive(const AnnotationAuthorStorageArchive& from);

  inline AnnotationAuthorStorageArchive& operator=(const AnnotationAuthorStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotationAuthorStorageArchive& default_instance();

  void Swap(AnnotationAuthorStorageArchive* other);

  // implements Message ----------------------------------------------

  AnnotationAuthorStorageArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnnotationAuthorStorageArchive& from);
  void MergeFrom(const AnnotationAuthorStorageArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TSP.Reference annotation_author = 1;
  inline int annotation_author_size() const;
  inline void clear_annotation_author();
  static const int kAnnotationAuthorFieldNumber = 1;
  inline const ::TSP::Reference& annotation_author(int index) const;
  inline ::TSP::Reference* mutable_annotation_author(int index);
  inline ::TSP::Reference* add_annotation_author();
  inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
      annotation_author() const;
  inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
      mutable_annotation_author();

  // @@protoc_insertion_point(class_scope:TSK.AnnotationAuthorStorageArchive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TSP::Reference > annotation_author_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static AnnotationAuthorStorageArchive* default_instance_;
};
// -------------------------------------------------------------------

class AddAnnotationAuthorCommandArchive : public ::google::protobuf::Message {
 public:
  AddAnnotationAuthorCommandArchive();
  virtual ~AddAnnotationAuthorCommandArchive();

  AddAnnotationAuthorCommandArchive(const AddAnnotationAuthorCommandArchive& from);

  inline AddAnnotationAuthorCommandArchive& operator=(const AddAnnotationAuthorCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddAnnotationAuthorCommandArchive& default_instance();

  void Swap(AddAnnotationAuthorCommandArchive* other);

  // implements Message ----------------------------------------------

  AddAnnotationAuthorCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddAnnotationAuthorCommandArchive& from);
  void MergeFrom(const AddAnnotationAuthorCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference document_root = 2;
  inline bool has_document_root() const;
  inline void clear_document_root();
  static const int kDocumentRootFieldNumber = 2;
  inline const ::TSP::Reference& document_root() const;
  inline ::TSP::Reference* mutable_document_root();
  inline ::TSP::Reference* release_document_root();
  inline void set_allocated_document_root(::TSP::Reference* document_root);

  // optional .TSP.Reference annotation_author = 3;
  inline bool has_annotation_author() const;
  inline void clear_annotation_author();
  static const int kAnnotationAuthorFieldNumber = 3;
  inline const ::TSP::Reference& annotation_author() const;
  inline ::TSP::Reference* mutable_annotation_author();
  inline ::TSP::Reference* release_annotation_author();
  inline void set_allocated_annotation_author(::TSP::Reference* annotation_author);

  // @@protoc_insertion_point(class_scope:TSK.AddAnnotationAuthorCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_document_root();
  inline void clear_has_document_root();
  inline void set_has_annotation_author();
  inline void clear_has_annotation_author();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* document_root_;
  ::TSP::Reference* annotation_author_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static AddAnnotationAuthorCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class SetAnnotationAuthorColorCommandArchive : public ::google::protobuf::Message {
 public:
  SetAnnotationAuthorColorCommandArchive();
  virtual ~SetAnnotationAuthorColorCommandArchive();

  SetAnnotationAuthorColorCommandArchive(const SetAnnotationAuthorColorCommandArchive& from);

  inline SetAnnotationAuthorColorCommandArchive& operator=(const SetAnnotationAuthorColorCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAnnotationAuthorColorCommandArchive& default_instance();

  void Swap(SetAnnotationAuthorColorCommandArchive* other);

  // implements Message ----------------------------------------------

  SetAnnotationAuthorColorCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAnnotationAuthorColorCommandArchive& from);
  void MergeFrom(const SetAnnotationAuthorColorCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference annotation_author = 2;
  inline bool has_annotation_author() const;
  inline void clear_annotation_author();
  static const int kAnnotationAuthorFieldNumber = 2;
  inline const ::TSP::Reference& annotation_author() const;
  inline ::TSP::Reference* mutable_annotation_author();
  inline ::TSP::Reference* release_annotation_author();
  inline void set_allocated_annotation_author(::TSP::Reference* annotation_author);

  // optional .TSP.Color color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::TSP::Color& color() const;
  inline ::TSP::Color* mutable_color();
  inline ::TSP::Color* release_color();
  inline void set_allocated_color(::TSP::Color* color);

  // @@protoc_insertion_point(class_scope:TSK.SetAnnotationAuthorColorCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_annotation_author();
  inline void clear_has_annotation_author();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* annotation_author_;
  ::TSP::Color* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSKArchives_2eproto();
  friend void protobuf_AssignDesc_TSKArchives_2eproto();
  friend void protobuf_ShutdownFile_TSKArchives_2eproto();

  void InitAsDefaultInstance();
  static SetAnnotationAuthorColorCommandArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// TreeNode

// optional string name = 1;
inline bool TreeNode::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeNode::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TreeNode::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TreeNode::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TreeNode::name() const {
  return *name_;
}
inline void TreeNode::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeNode::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TreeNode::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TreeNode::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TreeNode::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TreeNode::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .TSP.Reference children = 2;
inline int TreeNode::children_size() const {
  return children_.size();
}
inline void TreeNode::clear_children() {
  children_.Clear();
}
inline const ::TSP::Reference& TreeNode::children(int index) const {
  return children_.Get(index);
}
inline ::TSP::Reference* TreeNode::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::TSP::Reference* TreeNode::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
TreeNode::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
TreeNode::mutable_children() {
  return &children_;
}

// optional .TSP.Reference object = 3;
inline bool TreeNode::has_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeNode::set_has_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TreeNode::clear_has_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TreeNode::clear_object() {
  if (object_ != NULL) object_->::TSP::Reference::Clear();
  clear_has_object();
}
inline const ::TSP::Reference& TreeNode::object() const {
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::TSP::Reference* TreeNode::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::TSP::Reference;
  return object_;
}
inline ::TSP::Reference* TreeNode::release_object() {
  clear_has_object();
  ::TSP::Reference* temp = object_;
  object_ = NULL;
  return temp;
}
inline void TreeNode::set_allocated_object(::TSP::Reference* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
}

// -------------------------------------------------------------------

// CommandHistory

// required uint32 undo_count = 1;
inline bool CommandHistory::has_undo_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandHistory::set_has_undo_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandHistory::clear_has_undo_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandHistory::clear_undo_count() {
  undo_count_ = 0u;
  clear_has_undo_count();
}
inline ::google::protobuf::uint32 CommandHistory::undo_count() const {
  return undo_count_;
}
inline void CommandHistory::set_undo_count(::google::protobuf::uint32 value) {
  set_has_undo_count();
  undo_count_ = value;
}

// repeated .TSP.Reference commands = 2;
inline int CommandHistory::commands_size() const {
  return commands_.size();
}
inline void CommandHistory::clear_commands() {
  commands_.Clear();
}
inline const ::TSP::Reference& CommandHistory::commands(int index) const {
  return commands_.Get(index);
}
inline ::TSP::Reference* CommandHistory::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::TSP::Reference* CommandHistory::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandHistory::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandHistory::mutable_commands() {
  return &commands_;
}

// repeated .TSP.Reference marked_redo_commands = 3;
inline int CommandHistory::marked_redo_commands_size() const {
  return marked_redo_commands_.size();
}
inline void CommandHistory::clear_marked_redo_commands() {
  marked_redo_commands_.Clear();
}
inline const ::TSP::Reference& CommandHistory::marked_redo_commands(int index) const {
  return marked_redo_commands_.Get(index);
}
inline ::TSP::Reference* CommandHistory::mutable_marked_redo_commands(int index) {
  return marked_redo_commands_.Mutable(index);
}
inline ::TSP::Reference* CommandHistory::add_marked_redo_commands() {
  return marked_redo_commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandHistory::marked_redo_commands() const {
  return marked_redo_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandHistory::mutable_marked_redo_commands() {
  return &marked_redo_commands_;
}

// optional .TSP.Reference pending_preflight_command = 4;
inline bool CommandHistory::has_pending_preflight_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandHistory::set_has_pending_preflight_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandHistory::clear_has_pending_preflight_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandHistory::clear_pending_preflight_command() {
  if (pending_preflight_command_ != NULL) pending_preflight_command_->::TSP::Reference::Clear();
  clear_has_pending_preflight_command();
}
inline const ::TSP::Reference& CommandHistory::pending_preflight_command() const {
  return pending_preflight_command_ != NULL ? *pending_preflight_command_ : *default_instance_->pending_preflight_command_;
}
inline ::TSP::Reference* CommandHistory::mutable_pending_preflight_command() {
  set_has_pending_preflight_command();
  if (pending_preflight_command_ == NULL) pending_preflight_command_ = new ::TSP::Reference;
  return pending_preflight_command_;
}
inline ::TSP::Reference* CommandHistory::release_pending_preflight_command() {
  clear_has_pending_preflight_command();
  ::TSP::Reference* temp = pending_preflight_command_;
  pending_preflight_command_ = NULL;
  return temp;
}
inline void CommandHistory::set_allocated_pending_preflight_command(::TSP::Reference* pending_preflight_command) {
  delete pending_preflight_command_;
  pending_preflight_command_ = pending_preflight_command;
  if (pending_preflight_command) {
    set_has_pending_preflight_command();
  } else {
    clear_has_pending_preflight_command();
  }
}

// optional bool fixed_radar_13365177 = 10;
inline bool CommandHistory::has_fixed_radar_13365177() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandHistory::set_has_fixed_radar_13365177() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandHistory::clear_has_fixed_radar_13365177() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandHistory::clear_fixed_radar_13365177() {
  fixed_radar_13365177_ = false;
  clear_has_fixed_radar_13365177();
}
inline bool CommandHistory::fixed_radar_13365177() const {
  return fixed_radar_13365177_;
}
inline void CommandHistory::set_fixed_radar_13365177(bool value) {
  set_has_fixed_radar_13365177();
  fixed_radar_13365177_ = value;
}

// -------------------------------------------------------------------

// DocumentArchive

// optional string locale_identifier = 4;
inline bool DocumentArchive::has_locale_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentArchive::set_has_locale_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentArchive::clear_has_locale_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentArchive::clear_locale_identifier() {
  if (locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    locale_identifier_->clear();
  }
  clear_has_locale_identifier();
}
inline const ::std::string& DocumentArchive::locale_identifier() const {
  return *locale_identifier_;
}
inline void DocumentArchive::set_locale_identifier(const ::std::string& value) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(value);
}
inline void DocumentArchive::set_locale_identifier(const char* value) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(value);
}
inline void DocumentArchive::set_locale_identifier(const char* value, size_t size) {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  locale_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentArchive::mutable_locale_identifier() {
  set_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    locale_identifier_ = new ::std::string;
  }
  return locale_identifier_;
}
inline ::std::string* DocumentArchive::release_locale_identifier() {
  clear_has_locale_identifier();
  if (locale_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_identifier_;
    locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentArchive::set_allocated_locale_identifier(::std::string* locale_identifier) {
  if (locale_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete locale_identifier_;
  }
  if (locale_identifier) {
    set_has_locale_identifier();
    locale_identifier_ = locale_identifier;
  } else {
    clear_has_locale_identifier();
    locale_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference annotation_author_storage = 7;
inline bool DocumentArchive::has_annotation_author_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentArchive::set_has_annotation_author_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentArchive::clear_has_annotation_author_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentArchive::clear_annotation_author_storage() {
  if (annotation_author_storage_ != NULL) annotation_author_storage_->::TSP::Reference::Clear();
  clear_has_annotation_author_storage();
}
inline const ::TSP::Reference& DocumentArchive::annotation_author_storage() const {
  return annotation_author_storage_ != NULL ? *annotation_author_storage_ : *default_instance_->annotation_author_storage_;
}
inline ::TSP::Reference* DocumentArchive::mutable_annotation_author_storage() {
  set_has_annotation_author_storage();
  if (annotation_author_storage_ == NULL) annotation_author_storage_ = new ::TSP::Reference;
  return annotation_author_storage_;
}
inline ::TSP::Reference* DocumentArchive::release_annotation_author_storage() {
  clear_has_annotation_author_storage();
  ::TSP::Reference* temp = annotation_author_storage_;
  annotation_author_storage_ = NULL;
  return temp;
}
inline void DocumentArchive::set_allocated_annotation_author_storage(::TSP::Reference* annotation_author_storage) {
  delete annotation_author_storage_;
  annotation_author_storage_ = annotation_author_storage;
  if (annotation_author_storage) {
    set_has_annotation_author_storage();
  } else {
    clear_has_annotation_author_storage();
  }
}

// -------------------------------------------------------------------

// DocumentSupportArchive

// optional .TSP.Reference command_history = 1;
inline bool DocumentSupportArchive::has_command_history() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentSupportArchive::set_has_command_history() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentSupportArchive::clear_has_command_history() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentSupportArchive::clear_command_history() {
  if (command_history_ != NULL) command_history_->::TSP::Reference::Clear();
  clear_has_command_history();
}
inline const ::TSP::Reference& DocumentSupportArchive::command_history() const {
  return command_history_ != NULL ? *command_history_ : *default_instance_->command_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_command_history() {
  set_has_command_history();
  if (command_history_ == NULL) command_history_ = new ::TSP::Reference;
  return command_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::release_command_history() {
  clear_has_command_history();
  ::TSP::Reference* temp = command_history_;
  command_history_ = NULL;
  return temp;
}
inline void DocumentSupportArchive::set_allocated_command_history(::TSP::Reference* command_history) {
  delete command_history_;
  command_history_ = command_history;
  if (command_history) {
    set_has_command_history();
  } else {
    clear_has_command_history();
  }
}

// optional .TSP.Reference command_selection_behavior_history = 2;
inline bool DocumentSupportArchive::has_command_selection_behavior_history() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentSupportArchive::set_has_command_selection_behavior_history() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentSupportArchive::clear_has_command_selection_behavior_history() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentSupportArchive::clear_command_selection_behavior_history() {
  if (command_selection_behavior_history_ != NULL) command_selection_behavior_history_->::TSP::Reference::Clear();
  clear_has_command_selection_behavior_history();
}
inline const ::TSP::Reference& DocumentSupportArchive::command_selection_behavior_history() const {
  return command_selection_behavior_history_ != NULL ? *command_selection_behavior_history_ : *default_instance_->command_selection_behavior_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_command_selection_behavior_history() {
  set_has_command_selection_behavior_history();
  if (command_selection_behavior_history_ == NULL) command_selection_behavior_history_ = new ::TSP::Reference;
  return command_selection_behavior_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::release_command_selection_behavior_history() {
  clear_has_command_selection_behavior_history();
  ::TSP::Reference* temp = command_selection_behavior_history_;
  command_selection_behavior_history_ = NULL;
  return temp;
}
inline void DocumentSupportArchive::set_allocated_command_selection_behavior_history(::TSP::Reference* command_selection_behavior_history) {
  delete command_selection_behavior_history_;
  command_selection_behavior_history_ = command_selection_behavior_history;
  if (command_selection_behavior_history) {
    set_has_command_selection_behavior_history();
  } else {
    clear_has_command_selection_behavior_history();
  }
}

// optional uint32 undo_count = 4;
inline bool DocumentSupportArchive::has_undo_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentSupportArchive::set_has_undo_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentSupportArchive::clear_has_undo_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentSupportArchive::clear_undo_count() {
  undo_count_ = 0u;
  clear_has_undo_count();
}
inline ::google::protobuf::uint32 DocumentSupportArchive::undo_count() const {
  return undo_count_;
}
inline void DocumentSupportArchive::set_undo_count(::google::protobuf::uint32 value) {
  set_has_undo_count();
  undo_count_ = value;
}

// optional uint32 redo_count = 5;
inline bool DocumentSupportArchive::has_redo_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentSupportArchive::set_has_redo_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentSupportArchive::clear_has_redo_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentSupportArchive::clear_redo_count() {
  redo_count_ = 0u;
  clear_has_redo_count();
}
inline ::google::protobuf::uint32 DocumentSupportArchive::redo_count() const {
  return redo_count_;
}
inline void DocumentSupportArchive::set_redo_count(::google::protobuf::uint32 value) {
  set_has_redo_count();
  redo_count_ = value;
}

// optional string undo_action_string = 6;
inline bool DocumentSupportArchive::has_undo_action_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentSupportArchive::set_has_undo_action_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentSupportArchive::clear_has_undo_action_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentSupportArchive::clear_undo_action_string() {
  if (undo_action_string_ != &::google::protobuf::internal::kEmptyString) {
    undo_action_string_->clear();
  }
  clear_has_undo_action_string();
}
inline const ::std::string& DocumentSupportArchive::undo_action_string() const {
  return *undo_action_string_;
}
inline void DocumentSupportArchive::set_undo_action_string(const ::std::string& value) {
  set_has_undo_action_string();
  if (undo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    undo_action_string_ = new ::std::string;
  }
  undo_action_string_->assign(value);
}
inline void DocumentSupportArchive::set_undo_action_string(const char* value) {
  set_has_undo_action_string();
  if (undo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    undo_action_string_ = new ::std::string;
  }
  undo_action_string_->assign(value);
}
inline void DocumentSupportArchive::set_undo_action_string(const char* value, size_t size) {
  set_has_undo_action_string();
  if (undo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    undo_action_string_ = new ::std::string;
  }
  undo_action_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentSupportArchive::mutable_undo_action_string() {
  set_has_undo_action_string();
  if (undo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    undo_action_string_ = new ::std::string;
  }
  return undo_action_string_;
}
inline ::std::string* DocumentSupportArchive::release_undo_action_string() {
  clear_has_undo_action_string();
  if (undo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = undo_action_string_;
    undo_action_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentSupportArchive::set_allocated_undo_action_string(::std::string* undo_action_string) {
  if (undo_action_string_ != &::google::protobuf::internal::kEmptyString) {
    delete undo_action_string_;
  }
  if (undo_action_string) {
    set_has_undo_action_string();
    undo_action_string_ = undo_action_string;
  } else {
    clear_has_undo_action_string();
    undo_action_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string redo_action_string = 7;
inline bool DocumentSupportArchive::has_redo_action_string() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentSupportArchive::set_has_redo_action_string() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DocumentSupportArchive::clear_has_redo_action_string() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DocumentSupportArchive::clear_redo_action_string() {
  if (redo_action_string_ != &::google::protobuf::internal::kEmptyString) {
    redo_action_string_->clear();
  }
  clear_has_redo_action_string();
}
inline const ::std::string& DocumentSupportArchive::redo_action_string() const {
  return *redo_action_string_;
}
inline void DocumentSupportArchive::set_redo_action_string(const ::std::string& value) {
  set_has_redo_action_string();
  if (redo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    redo_action_string_ = new ::std::string;
  }
  redo_action_string_->assign(value);
}
inline void DocumentSupportArchive::set_redo_action_string(const char* value) {
  set_has_redo_action_string();
  if (redo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    redo_action_string_ = new ::std::string;
  }
  redo_action_string_->assign(value);
}
inline void DocumentSupportArchive::set_redo_action_string(const char* value, size_t size) {
  set_has_redo_action_string();
  if (redo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    redo_action_string_ = new ::std::string;
  }
  redo_action_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentSupportArchive::mutable_redo_action_string() {
  set_has_redo_action_string();
  if (redo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    redo_action_string_ = new ::std::string;
  }
  return redo_action_string_;
}
inline ::std::string* DocumentSupportArchive::release_redo_action_string() {
  clear_has_redo_action_string();
  if (redo_action_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redo_action_string_;
    redo_action_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentSupportArchive::set_allocated_redo_action_string(::std::string* redo_action_string) {
  if (redo_action_string_ != &::google::protobuf::internal::kEmptyString) {
    delete redo_action_string_;
  }
  if (redo_action_string) {
    set_has_redo_action_string();
    redo_action_string_ = redo_action_string;
  } else {
    clear_has_redo_action_string();
    redo_action_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Reference web_state = 8;
inline bool DocumentSupportArchive::has_web_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentSupportArchive::set_has_web_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocumentSupportArchive::clear_has_web_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocumentSupportArchive::clear_web_state() {
  if (web_state_ != NULL) web_state_->::TSP::Reference::Clear();
  clear_has_web_state();
}
inline const ::TSP::Reference& DocumentSupportArchive::web_state() const {
  return web_state_ != NULL ? *web_state_ : *default_instance_->web_state_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_web_state() {
  set_has_web_state();
  if (web_state_ == NULL) web_state_ = new ::TSP::Reference;
  return web_state_;
}
inline ::TSP::Reference* DocumentSupportArchive::release_web_state() {
  clear_has_web_state();
  ::TSP::Reference* temp = web_state_;
  web_state_ = NULL;
  return temp;
}
inline void DocumentSupportArchive::set_allocated_web_state(::TSP::Reference* web_state) {
  delete web_state_;
  web_state_ = web_state;
  if (web_state) {
    set_has_web_state();
  } else {
    clear_has_web_state();
  }
}

// -------------------------------------------------------------------

// ViewStateArchive

// required .TSP.Reference view_state_root = 1;
inline bool ViewStateArchive::has_view_state_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ViewStateArchive::set_has_view_state_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ViewStateArchive::clear_has_view_state_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ViewStateArchive::clear_view_state_root() {
  if (view_state_root_ != NULL) view_state_root_->::TSP::Reference::Clear();
  clear_has_view_state_root();
}
inline const ::TSP::Reference& ViewStateArchive::view_state_root() const {
  return view_state_root_ != NULL ? *view_state_root_ : *default_instance_->view_state_root_;
}
inline ::TSP::Reference* ViewStateArchive::mutable_view_state_root() {
  set_has_view_state_root();
  if (view_state_root_ == NULL) view_state_root_ = new ::TSP::Reference;
  return view_state_root_;
}
inline ::TSP::Reference* ViewStateArchive::release_view_state_root() {
  clear_has_view_state_root();
  ::TSP::Reference* temp = view_state_root_;
  view_state_root_ = NULL;
  return temp;
}
inline void ViewStateArchive::set_allocated_view_state_root(::TSP::Reference* view_state_root) {
  delete view_state_root_;
  view_state_root_ = view_state_root;
  if (view_state_root) {
    set_has_view_state_root();
  } else {
    clear_has_view_state_root();
  }
}

// -------------------------------------------------------------------

// CommandArchive

// optional .TSP.Reference undoRedoState = 1;
inline bool CommandArchive::has_undoredostate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandArchive::set_has_undoredostate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandArchive::clear_has_undoredostate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandArchive::clear_undoredostate() {
  if (undoredostate_ != NULL) undoredostate_->::TSP::Reference::Clear();
  clear_has_undoredostate();
}
inline const ::TSP::Reference& CommandArchive::undoredostate() const {
  return undoredostate_ != NULL ? *undoredostate_ : *default_instance_->undoredostate_;
}
inline ::TSP::Reference* CommandArchive::mutable_undoredostate() {
  set_has_undoredostate();
  if (undoredostate_ == NULL) undoredostate_ = new ::TSP::Reference;
  return undoredostate_;
}
inline ::TSP::Reference* CommandArchive::release_undoredostate() {
  clear_has_undoredostate();
  ::TSP::Reference* temp = undoredostate_;
  undoredostate_ = NULL;
  return temp;
}
inline void CommandArchive::set_allocated_undoredostate(::TSP::Reference* undoredostate) {
  delete undoredostate_;
  undoredostate_ = undoredostate;
  if (undoredostate) {
    set_has_undoredostate();
  } else {
    clear_has_undoredostate();
  }
}

// optional .TSP.Reference undoCollection = 2;
inline bool CommandArchive::has_undocollection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandArchive::set_has_undocollection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandArchive::clear_has_undocollection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandArchive::clear_undocollection() {
  if (undocollection_ != NULL) undocollection_->::TSP::Reference::Clear();
  clear_has_undocollection();
}
inline const ::TSP::Reference& CommandArchive::undocollection() const {
  return undocollection_ != NULL ? *undocollection_ : *default_instance_->undocollection_;
}
inline ::TSP::Reference* CommandArchive::mutable_undocollection() {
  set_has_undocollection();
  if (undocollection_ == NULL) undocollection_ = new ::TSP::Reference;
  return undocollection_;
}
inline ::TSP::Reference* CommandArchive::release_undocollection() {
  clear_has_undocollection();
  ::TSP::Reference* temp = undocollection_;
  undocollection_ = NULL;
  return temp;
}
inline void CommandArchive::set_allocated_undocollection(::TSP::Reference* undocollection) {
  delete undocollection_;
  undocollection_ = undocollection;
  if (undocollection) {
    set_has_undocollection();
  } else {
    clear_has_undocollection();
  }
}

// -------------------------------------------------------------------

// CommandGroupArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandGroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandGroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandGroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandGroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CommandGroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CommandGroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CommandGroupArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CommandGroupArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference commands = 2;
inline int CommandGroupArchive::commands_size() const {
  return commands_.size();
}
inline void CommandGroupArchive::clear_commands() {
  commands_.Clear();
}
inline const ::TSP::Reference& CommandGroupArchive::commands(int index) const {
  return commands_.Get(index);
}
inline ::TSP::Reference* CommandGroupArchive::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::TSP::Reference* CommandGroupArchive::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandGroupArchive::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandGroupArchive::mutable_commands() {
  return &commands_;
}

// optional .TSP.IndexSet process_results = 3;
inline bool CommandGroupArchive::has_process_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandGroupArchive::set_has_process_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandGroupArchive::clear_has_process_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandGroupArchive::clear_process_results() {
  if (process_results_ != NULL) process_results_->::TSP::IndexSet::Clear();
  clear_has_process_results();
}
inline const ::TSP::IndexSet& CommandGroupArchive::process_results() const {
  return process_results_ != NULL ? *process_results_ : *default_instance_->process_results_;
}
inline ::TSP::IndexSet* CommandGroupArchive::mutable_process_results() {
  set_has_process_results();
  if (process_results_ == NULL) process_results_ = new ::TSP::IndexSet;
  return process_results_;
}
inline ::TSP::IndexSet* CommandGroupArchive::release_process_results() {
  clear_has_process_results();
  ::TSP::IndexSet* temp = process_results_;
  process_results_ = NULL;
  return temp;
}
inline void CommandGroupArchive::set_allocated_process_results(::TSP::IndexSet* process_results) {
  delete process_results_;
  process_results_ = process_results;
  if (process_results) {
    set_has_process_results();
  } else {
    clear_has_process_results();
  }
}

// -------------------------------------------------------------------

// CommandContainerArchive

// repeated .TSP.Reference commands = 1;
inline int CommandContainerArchive::commands_size() const {
  return commands_.size();
}
inline void CommandContainerArchive::clear_commands() {
  commands_.Clear();
}
inline const ::TSP::Reference& CommandContainerArchive::commands(int index) const {
  return commands_.Get(index);
}
inline ::TSP::Reference* CommandContainerArchive::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::TSP::Reference* CommandContainerArchive::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
CommandContainerArchive::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
CommandContainerArchive::mutable_commands() {
  return &commands_;
}

// -------------------------------------------------------------------

// ReplaceAllChildCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ReplaceAllChildCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceAllChildCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceAllChildCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceAllChildCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ReplaceAllChildCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReplaceAllChildCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ReplaceAllCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ReplaceAllCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceAllCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceAllCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceAllCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ReplaceAllCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReplaceAllCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// repeated .TSP.Reference commands = 2;
inline int ReplaceAllCommandArchive::commands_size() const {
  return commands_.size();
}
inline void ReplaceAllCommandArchive::clear_commands() {
  commands_.Clear();
}
inline const ::TSP::Reference& ReplaceAllCommandArchive::commands(int index) const {
  return commands_.Get(index);
}
inline ::TSP::Reference* ReplaceAllCommandArchive::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::TSP::Reference* ReplaceAllCommandArchive::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
ReplaceAllCommandArchive::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
ReplaceAllCommandArchive::mutable_commands() {
  return &commands_;
}

// required string find_string = 3;
inline bool ReplaceAllCommandArchive::has_find_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplaceAllCommandArchive::set_has_find_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplaceAllCommandArchive::clear_has_find_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplaceAllCommandArchive::clear_find_string() {
  if (find_string_ != &::google::protobuf::internal::kEmptyString) {
    find_string_->clear();
  }
  clear_has_find_string();
}
inline const ::std::string& ReplaceAllCommandArchive::find_string() const {
  return *find_string_;
}
inline void ReplaceAllCommandArchive::set_find_string(const ::std::string& value) {
  set_has_find_string();
  if (find_string_ == &::google::protobuf::internal::kEmptyString) {
    find_string_ = new ::std::string;
  }
  find_string_->assign(value);
}
inline void ReplaceAllCommandArchive::set_find_string(const char* value) {
  set_has_find_string();
  if (find_string_ == &::google::protobuf::internal::kEmptyString) {
    find_string_ = new ::std::string;
  }
  find_string_->assign(value);
}
inline void ReplaceAllCommandArchive::set_find_string(const char* value, size_t size) {
  set_has_find_string();
  if (find_string_ == &::google::protobuf::internal::kEmptyString) {
    find_string_ = new ::std::string;
  }
  find_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplaceAllCommandArchive::mutable_find_string() {
  set_has_find_string();
  if (find_string_ == &::google::protobuf::internal::kEmptyString) {
    find_string_ = new ::std::string;
  }
  return find_string_;
}
inline ::std::string* ReplaceAllCommandArchive::release_find_string() {
  clear_has_find_string();
  if (find_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = find_string_;
    find_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplaceAllCommandArchive::set_allocated_find_string(::std::string* find_string) {
  if (find_string_ != &::google::protobuf::internal::kEmptyString) {
    delete find_string_;
  }
  if (find_string) {
    set_has_find_string();
    find_string_ = find_string;
  } else {
    clear_has_find_string();
    find_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string replace_string = 4;
inline bool ReplaceAllCommandArchive::has_replace_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplaceAllCommandArchive::set_has_replace_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReplaceAllCommandArchive::clear_has_replace_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReplaceAllCommandArchive::clear_replace_string() {
  if (replace_string_ != &::google::protobuf::internal::kEmptyString) {
    replace_string_->clear();
  }
  clear_has_replace_string();
}
inline const ::std::string& ReplaceAllCommandArchive::replace_string() const {
  return *replace_string_;
}
inline void ReplaceAllCommandArchive::set_replace_string(const ::std::string& value) {
  set_has_replace_string();
  if (replace_string_ == &::google::protobuf::internal::kEmptyString) {
    replace_string_ = new ::std::string;
  }
  replace_string_->assign(value);
}
inline void ReplaceAllCommandArchive::set_replace_string(const char* value) {
  set_has_replace_string();
  if (replace_string_ == &::google::protobuf::internal::kEmptyString) {
    replace_string_ = new ::std::string;
  }
  replace_string_->assign(value);
}
inline void ReplaceAllCommandArchive::set_replace_string(const char* value, size_t size) {
  set_has_replace_string();
  if (replace_string_ == &::google::protobuf::internal::kEmptyString) {
    replace_string_ = new ::std::string;
  }
  replace_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplaceAllCommandArchive::mutable_replace_string() {
  set_has_replace_string();
  if (replace_string_ == &::google::protobuf::internal::kEmptyString) {
    replace_string_ = new ::std::string;
  }
  return replace_string_;
}
inline ::std::string* ReplaceAllCommandArchive::release_replace_string() {
  clear_has_replace_string();
  if (replace_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = replace_string_;
    replace_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplaceAllCommandArchive::set_allocated_replace_string(::std::string* replace_string) {
  if (replace_string_ != &::google::protobuf::internal::kEmptyString) {
    delete replace_string_;
  }
  if (replace_string) {
    set_has_replace_string();
    replace_string_ = replace_string;
  } else {
    clear_has_replace_string();
    replace_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 options = 5;
inline bool ReplaceAllCommandArchive::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReplaceAllCommandArchive::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReplaceAllCommandArchive::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReplaceAllCommandArchive::clear_options() {
  options_ = 0u;
  clear_has_options();
}
inline ::google::protobuf::uint32 ReplaceAllCommandArchive::options() const {
  return options_;
}
inline void ReplaceAllCommandArchive::set_options(::google::protobuf::uint32 value) {
  set_has_options();
  options_ = value;
}

// -------------------------------------------------------------------

// ShuffleMappingArchive_Entry

// required uint32 from = 1;
inline bool ShuffleMappingArchive_Entry::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShuffleMappingArchive_Entry::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShuffleMappingArchive_Entry::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShuffleMappingArchive_Entry::clear_from() {
  from_ = 0u;
  clear_has_from();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive_Entry::from() const {
  return from_;
}
inline void ShuffleMappingArchive_Entry::set_from(::google::protobuf::uint32 value) {
  set_has_from();
  from_ = value;
}

// required uint32 to = 2;
inline bool ShuffleMappingArchive_Entry::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShuffleMappingArchive_Entry::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShuffleMappingArchive_Entry::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShuffleMappingArchive_Entry::clear_to() {
  to_ = 0u;
  clear_has_to();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive_Entry::to() const {
  return to_;
}
inline void ShuffleMappingArchive_Entry::set_to(::google::protobuf::uint32 value) {
  set_has_to();
  to_ = value;
}

// -------------------------------------------------------------------

// ShuffleMappingArchive

// required uint32 start_index = 1;
inline bool ShuffleMappingArchive::has_start_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShuffleMappingArchive::set_has_start_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShuffleMappingArchive::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShuffleMappingArchive::clear_start_index() {
  start_index_ = 0u;
  clear_has_start_index();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive::start_index() const {
  return start_index_;
}
inline void ShuffleMappingArchive::set_start_index(::google::protobuf::uint32 value) {
  set_has_start_index();
  start_index_ = value;
}

// required uint32 end_index = 2;
inline bool ShuffleMappingArchive::has_end_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShuffleMappingArchive::set_has_end_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShuffleMappingArchive::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShuffleMappingArchive::clear_end_index() {
  end_index_ = 0u;
  clear_has_end_index();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive::end_index() const {
  return end_index_;
}
inline void ShuffleMappingArchive::set_end_index(::google::protobuf::uint32 value) {
  set_has_end_index();
  end_index_ = value;
}

// repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
inline int ShuffleMappingArchive::entries_size() const {
  return entries_.size();
}
inline void ShuffleMappingArchive::clear_entries() {
  entries_.Clear();
}
inline const ::TSK::ShuffleMappingArchive_Entry& ShuffleMappingArchive::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSK::ShuffleMappingArchive_Entry* ShuffleMappingArchive::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSK::ShuffleMappingArchive_Entry* ShuffleMappingArchive::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >&
ShuffleMappingArchive::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >*
ShuffleMappingArchive::mutable_entries() {
  return &entries_;
}

// optional bool is_vertical = 4 [default = true];
inline bool ShuffleMappingArchive::has_is_vertical() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShuffleMappingArchive::set_has_is_vertical() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShuffleMappingArchive::clear_has_is_vertical() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShuffleMappingArchive::clear_is_vertical() {
  is_vertical_ = true;
  clear_has_is_vertical();
}
inline bool ShuffleMappingArchive::is_vertical() const {
  return is_vertical_;
}
inline void ShuffleMappingArchive::set_is_vertical(bool value) {
  set_has_is_vertical();
  is_vertical_ = value;
}

// optional bool is_move_operation = 5 [default = false];
inline bool ShuffleMappingArchive::has_is_move_operation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShuffleMappingArchive::set_has_is_move_operation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShuffleMappingArchive::clear_has_is_move_operation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShuffleMappingArchive::clear_is_move_operation() {
  is_move_operation_ = false;
  clear_has_is_move_operation();
}
inline bool ShuffleMappingArchive::is_move_operation() const {
  return is_move_operation_;
}
inline void ShuffleMappingArchive::set_is_move_operation(bool value) {
  set_has_is_move_operation();
  is_move_operation_ = value;
}

// optional uint32 first_moved_index = 6 [default = 0];
inline bool ShuffleMappingArchive::has_first_moved_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShuffleMappingArchive::set_has_first_moved_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShuffleMappingArchive::clear_has_first_moved_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShuffleMappingArchive::clear_first_moved_index() {
  first_moved_index_ = 0u;
  clear_has_first_moved_index();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive::first_moved_index() const {
  return first_moved_index_;
}
inline void ShuffleMappingArchive::set_first_moved_index(::google::protobuf::uint32 value) {
  set_has_first_moved_index();
  first_moved_index_ = value;
}

// optional uint32 destination_index_for_move = 7 [default = 0];
inline bool ShuffleMappingArchive::has_destination_index_for_move() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ShuffleMappingArchive::set_has_destination_index_for_move() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ShuffleMappingArchive::clear_has_destination_index_for_move() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ShuffleMappingArchive::clear_destination_index_for_move() {
  destination_index_for_move_ = 0u;
  clear_has_destination_index_for_move();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive::destination_index_for_move() const {
  return destination_index_for_move_;
}
inline void ShuffleMappingArchive::set_destination_index_for_move(::google::protobuf::uint32 value) {
  set_has_destination_index_for_move();
  destination_index_for_move_ = value;
}

// optional uint32 number_of_indices_moved = 8 [default = 0];
inline bool ShuffleMappingArchive::has_number_of_indices_moved() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShuffleMappingArchive::set_has_number_of_indices_moved() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShuffleMappingArchive::clear_has_number_of_indices_moved() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShuffleMappingArchive::clear_number_of_indices_moved() {
  number_of_indices_moved_ = 0u;
  clear_has_number_of_indices_moved();
}
inline ::google::protobuf::uint32 ShuffleMappingArchive::number_of_indices_moved() const {
  return number_of_indices_moved_;
}
inline void ShuffleMappingArchive::set_number_of_indices_moved(::google::protobuf::uint32 value) {
  set_has_number_of_indices_moved();
  number_of_indices_moved_ = value;
}

// -------------------------------------------------------------------

// ProgressiveCommandGroupArchive

// required .TSK.CommandGroupArchive super = 1;
inline bool ProgressiveCommandGroupArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProgressiveCommandGroupArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProgressiveCommandGroupArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProgressiveCommandGroupArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandGroupArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandGroupArchive& ProgressiveCommandGroupArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandGroupArchive;
  return super_;
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::release_super() {
  clear_has_super();
  ::TSK::CommandGroupArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ProgressiveCommandGroupArchive::set_allocated_super(::TSK::CommandGroupArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// CommandSelectionBehaviorHistoryArchive_Entry

// required .TSP.Reference command = 1;
inline bool CommandSelectionBehaviorHistoryArchive_Entry::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::clear_command() {
  if (command_ != NULL) command_->::TSP::Reference::Clear();
  clear_has_command();
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::TSP::Reference;
  return command_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::release_command() {
  clear_has_command();
  ::TSP::Reference* temp = command_;
  command_ = NULL;
  return temp;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_allocated_command(::TSP::Reference* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// required .TSP.Reference command_selection_behavior = 2;
inline bool CommandSelectionBehaviorHistoryArchive_Entry::has_command_selection_behavior() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_has_command_selection_behavior() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::clear_has_command_selection_behavior() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::clear_command_selection_behavior() {
  if (command_selection_behavior_ != NULL) command_selection_behavior_->::TSP::Reference::Clear();
  clear_has_command_selection_behavior();
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::command_selection_behavior() const {
  return command_selection_behavior_ != NULL ? *command_selection_behavior_ : *default_instance_->command_selection_behavior_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::mutable_command_selection_behavior() {
  set_has_command_selection_behavior();
  if (command_selection_behavior_ == NULL) command_selection_behavior_ = new ::TSP::Reference;
  return command_selection_behavior_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::release_command_selection_behavior() {
  clear_has_command_selection_behavior();
  ::TSP::Reference* temp = command_selection_behavior_;
  command_selection_behavior_ = NULL;
  return temp;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_allocated_command_selection_behavior(::TSP::Reference* command_selection_behavior) {
  delete command_selection_behavior_;
  command_selection_behavior_ = command_selection_behavior;
  if (command_selection_behavior) {
    set_has_command_selection_behavior();
  } else {
    clear_has_command_selection_behavior();
  }
}

// -------------------------------------------------------------------

// CommandSelectionBehaviorHistoryArchive

// repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
inline int CommandSelectionBehaviorHistoryArchive::entries_size() const {
  return entries_.size();
}
inline void CommandSelectionBehaviorHistoryArchive::clear_entries() {
  entries_.Clear();
}
inline const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& CommandSelectionBehaviorHistoryArchive::entries(int index) const {
  return entries_.Get(index);
}
inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* CommandSelectionBehaviorHistoryArchive::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* CommandSelectionBehaviorHistoryArchive::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >&
CommandSelectionBehaviorHistoryArchive::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >*
CommandSelectionBehaviorHistoryArchive::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// UndoRedoStateCommandSelectionBehaviorArchive

// optional .TSP.Reference undo_redo_state = 2;
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_undo_redo_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_has_undo_redo_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_has_undo_redo_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::clear_undo_redo_state() {
  if (undo_redo_state_ != NULL) undo_redo_state_->::TSP::Reference::Clear();
  clear_has_undo_redo_state();
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::undo_redo_state() const {
  return undo_redo_state_ != NULL ? *undo_redo_state_ : *default_instance_->undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::mutable_undo_redo_state() {
  set_has_undo_redo_state();
  if (undo_redo_state_ == NULL) undo_redo_state_ = new ::TSP::Reference;
  return undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::release_undo_redo_state() {
  clear_has_undo_redo_state();
  ::TSP::Reference* temp = undo_redo_state_;
  undo_redo_state_ = NULL;
  return temp;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_undo_redo_state(::TSP::Reference* undo_redo_state) {
  delete undo_redo_state_;
  undo_redo_state_ = undo_redo_state;
  if (undo_redo_state) {
    set_has_undo_redo_state();
  } else {
    clear_has_undo_redo_state();
  }
}

// -------------------------------------------------------------------

// FormatStructArchive

// required uint32 format_type = 1;
inline bool FormatStructArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatStructArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatStructArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatStructArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 FormatStructArchive::format_type() const {
  return format_type_;
}
inline void FormatStructArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// optional uint32 decimal_places = 2;
inline bool FormatStructArchive::has_decimal_places() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatStructArchive::set_has_decimal_places() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatStructArchive::clear_has_decimal_places() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatStructArchive::clear_decimal_places() {
  decimal_places_ = 0u;
  clear_has_decimal_places();
}
inline ::google::protobuf::uint32 FormatStructArchive::decimal_places() const {
  return decimal_places_;
}
inline void FormatStructArchive::set_decimal_places(::google::protobuf::uint32 value) {
  set_has_decimal_places();
  decimal_places_ = value;
}

// optional string currency_code = 3;
inline bool FormatStructArchive::has_currency_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatStructArchive::set_has_currency_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatStructArchive::clear_has_currency_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormatStructArchive::clear_currency_code() {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    currency_code_->clear();
  }
  clear_has_currency_code();
}
inline const ::std::string& FormatStructArchive::currency_code() const {
  return *currency_code_;
}
inline void FormatStructArchive::set_currency_code(const ::std::string& value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void FormatStructArchive::set_currency_code(const char* value) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(value);
}
inline void FormatStructArchive::set_currency_code(const char* value, size_t size) {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  currency_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::mutable_currency_code() {
  set_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    currency_code_ = new ::std::string;
  }
  return currency_code_;
}
inline ::std::string* FormatStructArchive::release_currency_code() {
  clear_has_currency_code();
  if (currency_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_code_;
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FormatStructArchive::set_allocated_currency_code(::std::string* currency_code) {
  if (currency_code_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_code_;
  }
  if (currency_code) {
    set_has_currency_code();
    currency_code_ = currency_code;
  } else {
    clear_has_currency_code();
    currency_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 negative_style = 4;
inline bool FormatStructArchive::has_negative_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatStructArchive::set_has_negative_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatStructArchive::clear_has_negative_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatStructArchive::clear_negative_style() {
  negative_style_ = 0u;
  clear_has_negative_style();
}
inline ::google::protobuf::uint32 FormatStructArchive::negative_style() const {
  return negative_style_;
}
inline void FormatStructArchive::set_negative_style(::google::protobuf::uint32 value) {
  set_has_negative_style();
  negative_style_ = value;
}

// optional bool show_thousands_separator = 5;
inline bool FormatStructArchive::has_show_thousands_separator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormatStructArchive::set_has_show_thousands_separator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormatStructArchive::clear_has_show_thousands_separator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormatStructArchive::clear_show_thousands_separator() {
  show_thousands_separator_ = false;
  clear_has_show_thousands_separator();
}
inline bool FormatStructArchive::show_thousands_separator() const {
  return show_thousands_separator_;
}
inline void FormatStructArchive::set_show_thousands_separator(bool value) {
  set_has_show_thousands_separator();
  show_thousands_separator_ = value;
}

// optional bool use_accounting_style = 6;
inline bool FormatStructArchive::has_use_accounting_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormatStructArchive::set_has_use_accounting_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormatStructArchive::clear_has_use_accounting_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormatStructArchive::clear_use_accounting_style() {
  use_accounting_style_ = false;
  clear_has_use_accounting_style();
}
inline bool FormatStructArchive::use_accounting_style() const {
  return use_accounting_style_;
}
inline void FormatStructArchive::set_use_accounting_style(bool value) {
  set_has_use_accounting_style();
  use_accounting_style_ = value;
}

// optional uint32 duration_style = 7;
inline bool FormatStructArchive::has_duration_style() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FormatStructArchive::set_has_duration_style() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FormatStructArchive::clear_has_duration_style() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FormatStructArchive::clear_duration_style() {
  duration_style_ = 0u;
  clear_has_duration_style();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_style() const {
  return duration_style_;
}
inline void FormatStructArchive::set_duration_style(::google::protobuf::uint32 value) {
  set_has_duration_style();
  duration_style_ = value;
}

// optional uint32 base = 8;
inline bool FormatStructArchive::has_base() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FormatStructArchive::set_has_base() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FormatStructArchive::clear_has_base() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FormatStructArchive::clear_base() {
  base_ = 0u;
  clear_has_base();
}
inline ::google::protobuf::uint32 FormatStructArchive::base() const {
  return base_;
}
inline void FormatStructArchive::set_base(::google::protobuf::uint32 value) {
  set_has_base();
  base_ = value;
}

// optional uint32 base_places = 9;
inline bool FormatStructArchive::has_base_places() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FormatStructArchive::set_has_base_places() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FormatStructArchive::clear_has_base_places() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FormatStructArchive::clear_base_places() {
  base_places_ = 0u;
  clear_has_base_places();
}
inline ::google::protobuf::uint32 FormatStructArchive::base_places() const {
  return base_places_;
}
inline void FormatStructArchive::set_base_places(::google::protobuf::uint32 value) {
  set_has_base_places();
  base_places_ = value;
}

// optional bool base_use_minus_sign = 10;
inline bool FormatStructArchive::has_base_use_minus_sign() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FormatStructArchive::set_has_base_use_minus_sign() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FormatStructArchive::clear_has_base_use_minus_sign() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FormatStructArchive::clear_base_use_minus_sign() {
  base_use_minus_sign_ = false;
  clear_has_base_use_minus_sign();
}
inline bool FormatStructArchive::base_use_minus_sign() const {
  return base_use_minus_sign_;
}
inline void FormatStructArchive::set_base_use_minus_sign(bool value) {
  set_has_base_use_minus_sign();
  base_use_minus_sign_ = value;
}

// optional uint32 fraction_accuracy = 11;
inline bool FormatStructArchive::has_fraction_accuracy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FormatStructArchive::set_has_fraction_accuracy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FormatStructArchive::clear_has_fraction_accuracy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FormatStructArchive::clear_fraction_accuracy() {
  fraction_accuracy_ = 0u;
  clear_has_fraction_accuracy();
}
inline ::google::protobuf::uint32 FormatStructArchive::fraction_accuracy() const {
  return fraction_accuracy_;
}
inline void FormatStructArchive::set_fraction_accuracy(::google::protobuf::uint32 value) {
  set_has_fraction_accuracy();
  fraction_accuracy_ = value;
}

// optional bool suppress_date_format = 12;
inline bool FormatStructArchive::has_suppress_date_format() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FormatStructArchive::set_has_suppress_date_format() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FormatStructArchive::clear_has_suppress_date_format() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FormatStructArchive::clear_suppress_date_format() {
  suppress_date_format_ = false;
  clear_has_suppress_date_format();
}
inline bool FormatStructArchive::suppress_date_format() const {
  return suppress_date_format_;
}
inline void FormatStructArchive::set_suppress_date_format(bool value) {
  set_has_suppress_date_format();
  suppress_date_format_ = value;
}

// optional bool suppress_time_format = 13;
inline bool FormatStructArchive::has_suppress_time_format() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FormatStructArchive::set_has_suppress_time_format() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FormatStructArchive::clear_has_suppress_time_format() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FormatStructArchive::clear_suppress_time_format() {
  suppress_time_format_ = false;
  clear_has_suppress_time_format();
}
inline bool FormatStructArchive::suppress_time_format() const {
  return suppress_time_format_;
}
inline void FormatStructArchive::set_suppress_time_format(bool value) {
  set_has_suppress_time_format();
  suppress_time_format_ = value;
}

// optional string date_time_format = 14;
inline bool FormatStructArchive::has_date_time_format() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FormatStructArchive::set_has_date_time_format() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FormatStructArchive::clear_has_date_time_format() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FormatStructArchive::clear_date_time_format() {
  if (date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    date_time_format_->clear();
  }
  clear_has_date_time_format();
}
inline const ::std::string& FormatStructArchive::date_time_format() const {
  return *date_time_format_;
}
inline void FormatStructArchive::set_date_time_format(const ::std::string& value) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(value);
}
inline void FormatStructArchive::set_date_time_format(const char* value) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(value);
}
inline void FormatStructArchive::set_date_time_format(const char* value, size_t size) {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  date_time_format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::mutable_date_time_format() {
  set_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    date_time_format_ = new ::std::string;
  }
  return date_time_format_;
}
inline ::std::string* FormatStructArchive::release_date_time_format() {
  clear_has_date_time_format();
  if (date_time_format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_format_;
    date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FormatStructArchive::set_allocated_date_time_format(::std::string* date_time_format) {
  if (date_time_format_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_format_;
  }
  if (date_time_format) {
    set_has_date_time_format();
    date_time_format_ = date_time_format;
  } else {
    clear_has_date_time_format();
    date_time_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 duration_unit_largest = 15;
inline bool FormatStructArchive::has_duration_unit_largest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FormatStructArchive::set_has_duration_unit_largest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FormatStructArchive::clear_has_duration_unit_largest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FormatStructArchive::clear_duration_unit_largest() {
  duration_unit_largest_ = 0u;
  clear_has_duration_unit_largest();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_unit_largest() const {
  return duration_unit_largest_;
}
inline void FormatStructArchive::set_duration_unit_largest(::google::protobuf::uint32 value) {
  set_has_duration_unit_largest();
  duration_unit_largest_ = value;
}

// optional uint32 duration_unit_smallest = 16;
inline bool FormatStructArchive::has_duration_unit_smallest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FormatStructArchive::set_has_duration_unit_smallest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FormatStructArchive::clear_has_duration_unit_smallest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FormatStructArchive::clear_duration_unit_smallest() {
  duration_unit_smallest_ = 0u;
  clear_has_duration_unit_smallest();
}
inline ::google::protobuf::uint32 FormatStructArchive::duration_unit_smallest() const {
  return duration_unit_smallest_;
}
inline void FormatStructArchive::set_duration_unit_smallest(::google::protobuf::uint32 value) {
  set_has_duration_unit_smallest();
  duration_unit_smallest_ = value;
}

// optional uint32 custom_id = 17;
inline bool FormatStructArchive::has_custom_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FormatStructArchive::set_has_custom_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FormatStructArchive::clear_has_custom_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FormatStructArchive::clear_custom_id() {
  custom_id_ = 0u;
  clear_has_custom_id();
}
inline ::google::protobuf::uint32 FormatStructArchive::custom_id() const {
  return custom_id_;
}
inline void FormatStructArchive::set_custom_id(::google::protobuf::uint32 value) {
  set_has_custom_id();
  custom_id_ = value;
}

// optional string custom_format_string = 18;
inline bool FormatStructArchive::has_custom_format_string() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FormatStructArchive::set_has_custom_format_string() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FormatStructArchive::clear_has_custom_format_string() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FormatStructArchive::clear_custom_format_string() {
  if (custom_format_string_ != &::google::protobuf::internal::kEmptyString) {
    custom_format_string_->clear();
  }
  clear_has_custom_format_string();
}
inline const ::std::string& FormatStructArchive::custom_format_string() const {
  return *custom_format_string_;
}
inline void FormatStructArchive::set_custom_format_string(const ::std::string& value) {
  set_has_custom_format_string();
  if (custom_format_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_format_string_ = new ::std::string;
  }
  custom_format_string_->assign(value);
}
inline void FormatStructArchive::set_custom_format_string(const char* value) {
  set_has_custom_format_string();
  if (custom_format_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_format_string_ = new ::std::string;
  }
  custom_format_string_->assign(value);
}
inline void FormatStructArchive::set_custom_format_string(const char* value, size_t size) {
  set_has_custom_format_string();
  if (custom_format_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_format_string_ = new ::std::string;
  }
  custom_format_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::mutable_custom_format_string() {
  set_has_custom_format_string();
  if (custom_format_string_ == &::google::protobuf::internal::kEmptyString) {
    custom_format_string_ = new ::std::string;
  }
  return custom_format_string_;
}
inline ::std::string* FormatStructArchive::release_custom_format_string() {
  clear_has_custom_format_string();
  if (custom_format_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_format_string_;
    custom_format_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FormatStructArchive::set_allocated_custom_format_string(::std::string* custom_format_string) {
  if (custom_format_string_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_format_string_;
  }
  if (custom_format_string) {
    set_has_custom_format_string();
    custom_format_string_ = custom_format_string;
  } else {
    clear_has_custom_format_string();
    custom_format_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double scale_factor = 19;
inline bool FormatStructArchive::has_scale_factor() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FormatStructArchive::set_has_scale_factor() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FormatStructArchive::clear_has_scale_factor() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FormatStructArchive::clear_scale_factor() {
  scale_factor_ = 0;
  clear_has_scale_factor();
}
inline double FormatStructArchive::scale_factor() const {
  return scale_factor_;
}
inline void FormatStructArchive::set_scale_factor(double value) {
  set_has_scale_factor();
  scale_factor_ = value;
}

// optional bool requires_fraction_replacement = 20;
inline bool FormatStructArchive::has_requires_fraction_replacement() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void FormatStructArchive::set_has_requires_fraction_replacement() {
  _has_bits_[0] |= 0x00080000u;
}
inline void FormatStructArchive::clear_has_requires_fraction_replacement() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void FormatStructArchive::clear_requires_fraction_replacement() {
  requires_fraction_replacement_ = false;
  clear_has_requires_fraction_replacement();
}
inline bool FormatStructArchive::requires_fraction_replacement() const {
  return requires_fraction_replacement_;
}
inline void FormatStructArchive::set_requires_fraction_replacement(bool value) {
  set_has_requires_fraction_replacement();
  requires_fraction_replacement_ = value;
}

// optional double control_minimum = 21;
inline bool FormatStructArchive::has_control_minimum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void FormatStructArchive::set_has_control_minimum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void FormatStructArchive::clear_has_control_minimum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void FormatStructArchive::clear_control_minimum() {
  control_minimum_ = 0;
  clear_has_control_minimum();
}
inline double FormatStructArchive::control_minimum() const {
  return control_minimum_;
}
inline void FormatStructArchive::set_control_minimum(double value) {
  set_has_control_minimum();
  control_minimum_ = value;
}

// optional double control_maximum = 22;
inline bool FormatStructArchive::has_control_maximum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void FormatStructArchive::set_has_control_maximum() {
  _has_bits_[0] |= 0x00200000u;
}
inline void FormatStructArchive::clear_has_control_maximum() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void FormatStructArchive::clear_control_maximum() {
  control_maximum_ = 0;
  clear_has_control_maximum();
}
inline double FormatStructArchive::control_maximum() const {
  return control_maximum_;
}
inline void FormatStructArchive::set_control_maximum(double value) {
  set_has_control_maximum();
  control_maximum_ = value;
}

// optional double control_increment = 23;
inline bool FormatStructArchive::has_control_increment() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void FormatStructArchive::set_has_control_increment() {
  _has_bits_[0] |= 0x00400000u;
}
inline void FormatStructArchive::clear_has_control_increment() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void FormatStructArchive::clear_control_increment() {
  control_increment_ = 0;
  clear_has_control_increment();
}
inline double FormatStructArchive::control_increment() const {
  return control_increment_;
}
inline void FormatStructArchive::set_control_increment(double value) {
  set_has_control_increment();
  control_increment_ = value;
}

// optional uint32 control_format_type = 24;
inline bool FormatStructArchive::has_control_format_type() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void FormatStructArchive::set_has_control_format_type() {
  _has_bits_[0] |= 0x00800000u;
}
inline void FormatStructArchive::clear_has_control_format_type() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void FormatStructArchive::clear_control_format_type() {
  control_format_type_ = 0u;
  clear_has_control_format_type();
}
inline ::google::protobuf::uint32 FormatStructArchive::control_format_type() const {
  return control_format_type_;
}
inline void FormatStructArchive::set_control_format_type(::google::protobuf::uint32 value) {
  set_has_control_format_type();
  control_format_type_ = value;
}

// optional uint32 slider_orientation = 25;
inline bool FormatStructArchive::has_slider_orientation() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void FormatStructArchive::set_has_slider_orientation() {
  _has_bits_[0] |= 0x01000000u;
}
inline void FormatStructArchive::clear_has_slider_orientation() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void FormatStructArchive::clear_slider_orientation() {
  slider_orientation_ = 0u;
  clear_has_slider_orientation();
}
inline ::google::protobuf::uint32 FormatStructArchive::slider_orientation() const {
  return slider_orientation_;
}
inline void FormatStructArchive::set_slider_orientation(::google::protobuf::uint32 value) {
  set_has_slider_orientation();
  slider_orientation_ = value;
}

// optional uint32 slider_position = 26;
inline bool FormatStructArchive::has_slider_position() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void FormatStructArchive::set_has_slider_position() {
  _has_bits_[0] |= 0x02000000u;
}
inline void FormatStructArchive::clear_has_slider_position() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void FormatStructArchive::clear_slider_position() {
  slider_position_ = 0u;
  clear_has_slider_position();
}
inline ::google::protobuf::uint32 FormatStructArchive::slider_position() const {
  return slider_position_;
}
inline void FormatStructArchive::set_slider_position(::google::protobuf::uint32 value) {
  set_has_slider_position();
  slider_position_ = value;
}

// optional uint32 decimal_width = 27;
inline bool FormatStructArchive::has_decimal_width() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void FormatStructArchive::set_has_decimal_width() {
  _has_bits_[0] |= 0x04000000u;
}
inline void FormatStructArchive::clear_has_decimal_width() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void FormatStructArchive::clear_decimal_width() {
  decimal_width_ = 0u;
  clear_has_decimal_width();
}
inline ::google::protobuf::uint32 FormatStructArchive::decimal_width() const {
  return decimal_width_;
}
inline void FormatStructArchive::set_decimal_width(::google::protobuf::uint32 value) {
  set_has_decimal_width();
  decimal_width_ = value;
}

// optional uint32 min_integer_width = 28;
inline bool FormatStructArchive::has_min_integer_width() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void FormatStructArchive::set_has_min_integer_width() {
  _has_bits_[0] |= 0x08000000u;
}
inline void FormatStructArchive::clear_has_min_integer_width() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void FormatStructArchive::clear_min_integer_width() {
  min_integer_width_ = 0u;
  clear_has_min_integer_width();
}
inline ::google::protobuf::uint32 FormatStructArchive::min_integer_width() const {
  return min_integer_width_;
}
inline void FormatStructArchive::set_min_integer_width(::google::protobuf::uint32 value) {
  set_has_min_integer_width();
  min_integer_width_ = value;
}

// optional uint32 num_nonspace_integer_digits = 29;
inline bool FormatStructArchive::has_num_nonspace_integer_digits() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void FormatStructArchive::set_has_num_nonspace_integer_digits() {
  _has_bits_[0] |= 0x10000000u;
}
inline void FormatStructArchive::clear_has_num_nonspace_integer_digits() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void FormatStructArchive::clear_num_nonspace_integer_digits() {
  num_nonspace_integer_digits_ = 0u;
  clear_has_num_nonspace_integer_digits();
}
inline ::google::protobuf::uint32 FormatStructArchive::num_nonspace_integer_digits() const {
  return num_nonspace_integer_digits_;
}
inline void FormatStructArchive::set_num_nonspace_integer_digits(::google::protobuf::uint32 value) {
  set_has_num_nonspace_integer_digits();
  num_nonspace_integer_digits_ = value;
}

// optional uint32 num_nonspace_decimal_digits = 30;
inline bool FormatStructArchive::has_num_nonspace_decimal_digits() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void FormatStructArchive::set_has_num_nonspace_decimal_digits() {
  _has_bits_[0] |= 0x20000000u;
}
inline void FormatStructArchive::clear_has_num_nonspace_decimal_digits() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void FormatStructArchive::clear_num_nonspace_decimal_digits() {
  num_nonspace_decimal_digits_ = 0u;
  clear_has_num_nonspace_decimal_digits();
}
inline ::google::protobuf::uint32 FormatStructArchive::num_nonspace_decimal_digits() const {
  return num_nonspace_decimal_digits_;
}
inline void FormatStructArchive::set_num_nonspace_decimal_digits(::google::protobuf::uint32 value) {
  set_has_num_nonspace_decimal_digits();
  num_nonspace_decimal_digits_ = value;
}

// optional uint32 index_from_right_last_integer = 31;
inline bool FormatStructArchive::has_index_from_right_last_integer() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void FormatStructArchive::set_has_index_from_right_last_integer() {
  _has_bits_[0] |= 0x40000000u;
}
inline void FormatStructArchive::clear_has_index_from_right_last_integer() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void FormatStructArchive::clear_index_from_right_last_integer() {
  index_from_right_last_integer_ = 0u;
  clear_has_index_from_right_last_integer();
}
inline ::google::protobuf::uint32 FormatStructArchive::index_from_right_last_integer() const {
  return index_from_right_last_integer_;
}
inline void FormatStructArchive::set_index_from_right_last_integer(::google::protobuf::uint32 value) {
  set_has_index_from_right_last_integer();
  index_from_right_last_integer_ = value;
}

// repeated string interstitial_strings = 32;
inline int FormatStructArchive::interstitial_strings_size() const {
  return interstitial_strings_.size();
}
inline void FormatStructArchive::clear_interstitial_strings() {
  interstitial_strings_.Clear();
}
inline const ::std::string& FormatStructArchive::interstitial_strings(int index) const {
  return interstitial_strings_.Get(index);
}
inline ::std::string* FormatStructArchive::mutable_interstitial_strings(int index) {
  return interstitial_strings_.Mutable(index);
}
inline void FormatStructArchive::set_interstitial_strings(int index, const ::std::string& value) {
  interstitial_strings_.Mutable(index)->assign(value);
}
inline void FormatStructArchive::set_interstitial_strings(int index, const char* value) {
  interstitial_strings_.Mutable(index)->assign(value);
}
inline void FormatStructArchive::set_interstitial_strings(int index, const char* value, size_t size) {
  interstitial_strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FormatStructArchive::add_interstitial_strings() {
  return interstitial_strings_.Add();
}
inline void FormatStructArchive::add_interstitial_strings(const ::std::string& value) {
  interstitial_strings_.Add()->assign(value);
}
inline void FormatStructArchive::add_interstitial_strings(const char* value) {
  interstitial_strings_.Add()->assign(value);
}
inline void FormatStructArchive::add_interstitial_strings(const char* value, size_t size) {
  interstitial_strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FormatStructArchive::interstitial_strings() const {
  return interstitial_strings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FormatStructArchive::mutable_interstitial_strings() {
  return &interstitial_strings_;
}

// optional .TSP.IndexSet inters_str_insertion_indexes = 33;
inline bool FormatStructArchive::has_inters_str_insertion_indexes() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void FormatStructArchive::set_has_inters_str_insertion_indexes() {
  _has_bits_[1] |= 0x00000001u;
}
inline void FormatStructArchive::clear_has_inters_str_insertion_indexes() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void FormatStructArchive::clear_inters_str_insertion_indexes() {
  if (inters_str_insertion_indexes_ != NULL) inters_str_insertion_indexes_->::TSP::IndexSet::Clear();
  clear_has_inters_str_insertion_indexes();
}
inline const ::TSP::IndexSet& FormatStructArchive::inters_str_insertion_indexes() const {
  return inters_str_insertion_indexes_ != NULL ? *inters_str_insertion_indexes_ : *default_instance_->inters_str_insertion_indexes_;
}
inline ::TSP::IndexSet* FormatStructArchive::mutable_inters_str_insertion_indexes() {
  set_has_inters_str_insertion_indexes();
  if (inters_str_insertion_indexes_ == NULL) inters_str_insertion_indexes_ = new ::TSP::IndexSet;
  return inters_str_insertion_indexes_;
}
inline ::TSP::IndexSet* FormatStructArchive::release_inters_str_insertion_indexes() {
  clear_has_inters_str_insertion_indexes();
  ::TSP::IndexSet* temp = inters_str_insertion_indexes_;
  inters_str_insertion_indexes_ = NULL;
  return temp;
}
inline void FormatStructArchive::set_allocated_inters_str_insertion_indexes(::TSP::IndexSet* inters_str_insertion_indexes) {
  delete inters_str_insertion_indexes_;
  inters_str_insertion_indexes_ = inters_str_insertion_indexes;
  if (inters_str_insertion_indexes) {
    set_has_inters_str_insertion_indexes();
  } else {
    clear_has_inters_str_insertion_indexes();
  }
}

// optional uint32 num_hash_decimal_digits = 34;
inline bool FormatStructArchive::has_num_hash_decimal_digits() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void FormatStructArchive::set_has_num_hash_decimal_digits() {
  _has_bits_[1] |= 0x00000002u;
}
inline void FormatStructArchive::clear_has_num_hash_decimal_digits() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void FormatStructArchive::clear_num_hash_decimal_digits() {
  num_hash_decimal_digits_ = 0u;
  clear_has_num_hash_decimal_digits();
}
inline ::google::protobuf::uint32 FormatStructArchive::num_hash_decimal_digits() const {
  return num_hash_decimal_digits_;
}
inline void FormatStructArchive::set_num_hash_decimal_digits(::google::protobuf::uint32 value) {
  set_has_num_hash_decimal_digits();
  num_hash_decimal_digits_ = value;
}

// optional uint32 total_num_decimal_digits = 35;
inline bool FormatStructArchive::has_total_num_decimal_digits() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void FormatStructArchive::set_has_total_num_decimal_digits() {
  _has_bits_[1] |= 0x00000004u;
}
inline void FormatStructArchive::clear_has_total_num_decimal_digits() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void FormatStructArchive::clear_total_num_decimal_digits() {
  total_num_decimal_digits_ = 0u;
  clear_has_total_num_decimal_digits();
}
inline ::google::protobuf::uint32 FormatStructArchive::total_num_decimal_digits() const {
  return total_num_decimal_digits_;
}
inline void FormatStructArchive::set_total_num_decimal_digits(::google::protobuf::uint32 value) {
  set_has_total_num_decimal_digits();
  total_num_decimal_digits_ = value;
}

// optional bool is_complex = 36;
inline bool FormatStructArchive::has_is_complex() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void FormatStructArchive::set_has_is_complex() {
  _has_bits_[1] |= 0x00000008u;
}
inline void FormatStructArchive::clear_has_is_complex() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void FormatStructArchive::clear_is_complex() {
  is_complex_ = false;
  clear_has_is_complex();
}
inline bool FormatStructArchive::is_complex() const {
  return is_complex_;
}
inline void FormatStructArchive::set_is_complex(bool value) {
  set_has_is_complex();
  is_complex_ = value;
}

// optional bool contains_integer_token = 37;
inline bool FormatStructArchive::has_contains_integer_token() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void FormatStructArchive::set_has_contains_integer_token() {
  _has_bits_[1] |= 0x00000010u;
}
inline void FormatStructArchive::clear_has_contains_integer_token() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void FormatStructArchive::clear_contains_integer_token() {
  contains_integer_token_ = false;
  clear_has_contains_integer_token();
}
inline bool FormatStructArchive::contains_integer_token() const {
  return contains_integer_token_;
}
inline void FormatStructArchive::set_contains_integer_token(bool value) {
  set_has_contains_integer_token();
  contains_integer_token_ = value;
}

// optional uint32 multiple_choice_list_initial_value = 38;
inline bool FormatStructArchive::has_multiple_choice_list_initial_value() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void FormatStructArchive::set_has_multiple_choice_list_initial_value() {
  _has_bits_[1] |= 0x00000020u;
}
inline void FormatStructArchive::clear_has_multiple_choice_list_initial_value() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void FormatStructArchive::clear_multiple_choice_list_initial_value() {
  multiple_choice_list_initial_value_ = 0u;
  clear_has_multiple_choice_list_initial_value();
}
inline ::google::protobuf::uint32 FormatStructArchive::multiple_choice_list_initial_value() const {
  return multiple_choice_list_initial_value_;
}
inline void FormatStructArchive::set_multiple_choice_list_initial_value(::google::protobuf::uint32 value) {
  set_has_multiple_choice_list_initial_value();
  multiple_choice_list_initial_value_ = value;
}

// optional uint32 multiple_choice_list_id = 39;
inline bool FormatStructArchive::has_multiple_choice_list_id() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void FormatStructArchive::set_has_multiple_choice_list_id() {
  _has_bits_[1] |= 0x00000040u;
}
inline void FormatStructArchive::clear_has_multiple_choice_list_id() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void FormatStructArchive::clear_multiple_choice_list_id() {
  multiple_choice_list_id_ = 0u;
  clear_has_multiple_choice_list_id();
}
inline ::google::protobuf::uint32 FormatStructArchive::multiple_choice_list_id() const {
  return multiple_choice_list_id_;
}
inline void FormatStructArchive::set_multiple_choice_list_id(::google::protobuf::uint32 value) {
  set_has_multiple_choice_list_id();
  multiple_choice_list_id_ = value;
}

// optional bool use_automatic_duration_units = 40;
inline bool FormatStructArchive::has_use_automatic_duration_units() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void FormatStructArchive::set_has_use_automatic_duration_units() {
  _has_bits_[1] |= 0x00000080u;
}
inline void FormatStructArchive::clear_has_use_automatic_duration_units() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void FormatStructArchive::clear_use_automatic_duration_units() {
  use_automatic_duration_units_ = false;
  clear_has_use_automatic_duration_units();
}
inline bool FormatStructArchive::use_automatic_duration_units() const {
  return use_automatic_duration_units_;
}
inline void FormatStructArchive::set_use_automatic_duration_units(bool value) {
  set_has_use_automatic_duration_units();
  use_automatic_duration_units_ = value;
}

// -------------------------------------------------------------------

// CustomFormatArchive_Condition

// required uint32 condition_type = 1;
inline bool CustomFormatArchive_Condition::has_condition_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomFormatArchive_Condition::set_has_condition_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomFormatArchive_Condition::clear_has_condition_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomFormatArchive_Condition::clear_condition_type() {
  condition_type_ = 0u;
  clear_has_condition_type();
}
inline ::google::protobuf::uint32 CustomFormatArchive_Condition::condition_type() const {
  return condition_type_;
}
inline void CustomFormatArchive_Condition::set_condition_type(::google::protobuf::uint32 value) {
  set_has_condition_type();
  condition_type_ = value;
}

// optional float condition_value = 2;
inline bool CustomFormatArchive_Condition::has_condition_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomFormatArchive_Condition::set_has_condition_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomFormatArchive_Condition::clear_has_condition_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomFormatArchive_Condition::clear_condition_value() {
  condition_value_ = 0;
  clear_has_condition_value();
}
inline float CustomFormatArchive_Condition::condition_value() const {
  return condition_value_;
}
inline void CustomFormatArchive_Condition::set_condition_value(float value) {
  set_has_condition_value();
  condition_value_ = value;
}

// required .TSK.FormatStructArchive condition_format = 3;
inline bool CustomFormatArchive_Condition::has_condition_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CustomFormatArchive_Condition::set_has_condition_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CustomFormatArchive_Condition::clear_has_condition_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CustomFormatArchive_Condition::clear_condition_format() {
  if (condition_format_ != NULL) condition_format_->::TSK::FormatStructArchive::Clear();
  clear_has_condition_format();
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive_Condition::condition_format() const {
  return condition_format_ != NULL ? *condition_format_ : *default_instance_->condition_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::mutable_condition_format() {
  set_has_condition_format();
  if (condition_format_ == NULL) condition_format_ = new ::TSK::FormatStructArchive;
  return condition_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::release_condition_format() {
  clear_has_condition_format();
  ::TSK::FormatStructArchive* temp = condition_format_;
  condition_format_ = NULL;
  return temp;
}
inline void CustomFormatArchive_Condition::set_allocated_condition_format(::TSK::FormatStructArchive* condition_format) {
  delete condition_format_;
  condition_format_ = condition_format;
  if (condition_format) {
    set_has_condition_format();
  } else {
    clear_has_condition_format();
  }
}

// optional double condition_value_dbl = 4;
inline bool CustomFormatArchive_Condition::has_condition_value_dbl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustomFormatArchive_Condition::set_has_condition_value_dbl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustomFormatArchive_Condition::clear_has_condition_value_dbl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustomFormatArchive_Condition::clear_condition_value_dbl() {
  condition_value_dbl_ = 0;
  clear_has_condition_value_dbl();
}
inline double CustomFormatArchive_Condition::condition_value_dbl() const {
  return condition_value_dbl_;
}
inline void CustomFormatArchive_Condition::set_condition_value_dbl(double value) {
  set_has_condition_value_dbl();
  condition_value_dbl_ = value;
}

// -------------------------------------------------------------------

// CustomFormatArchive

// required string name = 1;
inline bool CustomFormatArchive::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomFormatArchive::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomFormatArchive::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomFormatArchive::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CustomFormatArchive::name() const {
  return *name_;
}
inline void CustomFormatArchive::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CustomFormatArchive::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CustomFormatArchive::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustomFormatArchive::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CustomFormatArchive::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustomFormatArchive::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 format_type = 2;
inline bool CustomFormatArchive::has_format_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomFormatArchive::set_has_format_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomFormatArchive::clear_has_format_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomFormatArchive::clear_format_type() {
  format_type_ = 0u;
  clear_has_format_type();
}
inline ::google::protobuf::uint32 CustomFormatArchive::format_type() const {
  return format_type_;
}
inline void CustomFormatArchive::set_format_type(::google::protobuf::uint32 value) {
  set_has_format_type();
  format_type_ = value;
}

// required .TSK.FormatStructArchive default_format = 3;
inline bool CustomFormatArchive::has_default_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CustomFormatArchive::set_has_default_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CustomFormatArchive::clear_has_default_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CustomFormatArchive::clear_default_format() {
  if (default_format_ != NULL) default_format_->::TSK::FormatStructArchive::Clear();
  clear_has_default_format();
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive::default_format() const {
  return default_format_ != NULL ? *default_format_ : *default_instance_->default_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::mutable_default_format() {
  set_has_default_format();
  if (default_format_ == NULL) default_format_ = new ::TSK::FormatStructArchive;
  return default_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::release_default_format() {
  clear_has_default_format();
  ::TSK::FormatStructArchive* temp = default_format_;
  default_format_ = NULL;
  return temp;
}
inline void CustomFormatArchive::set_allocated_default_format(::TSK::FormatStructArchive* default_format) {
  delete default_format_;
  default_format_ = default_format;
  if (default_format) {
    set_has_default_format();
  } else {
    clear_has_default_format();
  }
}

// repeated .TSK.CustomFormatArchive.Condition conditions = 4;
inline int CustomFormatArchive::conditions_size() const {
  return conditions_.size();
}
inline void CustomFormatArchive::clear_conditions() {
  conditions_.Clear();
}
inline const ::TSK::CustomFormatArchive_Condition& CustomFormatArchive::conditions(int index) const {
  return conditions_.Get(index);
}
inline ::TSK::CustomFormatArchive_Condition* CustomFormatArchive::mutable_conditions(int index) {
  return conditions_.Mutable(index);
}
inline ::TSK::CustomFormatArchive_Condition* CustomFormatArchive::add_conditions() {
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >&
CustomFormatArchive::conditions() const {
  return conditions_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >*
CustomFormatArchive::mutable_conditions() {
  return &conditions_;
}

// -------------------------------------------------------------------

// AnnotationAuthorArchive

// optional string name = 1;
inline bool AnnotationAuthorArchive::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnotationAuthorArchive::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnnotationAuthorArchive::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnnotationAuthorArchive::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AnnotationAuthorArchive::name() const {
  return *name_;
}
inline void AnnotationAuthorArchive::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AnnotationAuthorArchive::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AnnotationAuthorArchive::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AnnotationAuthorArchive::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AnnotationAuthorArchive::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AnnotationAuthorArchive::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Color color = 2;
inline bool AnnotationAuthorArchive::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnotationAuthorArchive::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnnotationAuthorArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnnotationAuthorArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& AnnotationAuthorArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* AnnotationAuthorArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* AnnotationAuthorArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void AnnotationAuthorArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// -------------------------------------------------------------------

// DeprecatedChangeAuthorArchive

// optional string name = 1;
inline bool DeprecatedChangeAuthorArchive::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeprecatedChangeAuthorArchive::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeprecatedChangeAuthorArchive::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeprecatedChangeAuthorArchive::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DeprecatedChangeAuthorArchive::name() const {
  return *name_;
}
inline void DeprecatedChangeAuthorArchive::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DeprecatedChangeAuthorArchive::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DeprecatedChangeAuthorArchive::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeprecatedChangeAuthorArchive::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DeprecatedChangeAuthorArchive::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeprecatedChangeAuthorArchive::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSP.Color change_color = 2;
inline bool DeprecatedChangeAuthorArchive::has_change_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeprecatedChangeAuthorArchive::set_has_change_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeprecatedChangeAuthorArchive::clear_has_change_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeprecatedChangeAuthorArchive::clear_change_color() {
  if (change_color_ != NULL) change_color_->::TSP::Color::Clear();
  clear_has_change_color();
}
inline const ::TSP::Color& DeprecatedChangeAuthorArchive::change_color() const {
  return change_color_ != NULL ? *change_color_ : *default_instance_->change_color_;
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::mutable_change_color() {
  set_has_change_color();
  if (change_color_ == NULL) change_color_ = new ::TSP::Color;
  return change_color_;
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::release_change_color() {
  clear_has_change_color();
  ::TSP::Color* temp = change_color_;
  change_color_ = NULL;
  return temp;
}
inline void DeprecatedChangeAuthorArchive::set_allocated_change_color(::TSP::Color* change_color) {
  delete change_color_;
  change_color_ = change_color;
  if (change_color) {
    set_has_change_color();
  } else {
    clear_has_change_color();
  }
}

// -------------------------------------------------------------------

// AnnotationAuthorStorageArchive

// repeated .TSP.Reference annotation_author = 1;
inline int AnnotationAuthorStorageArchive::annotation_author_size() const {
  return annotation_author_.size();
}
inline void AnnotationAuthorStorageArchive::clear_annotation_author() {
  annotation_author_.Clear();
}
inline const ::TSP::Reference& AnnotationAuthorStorageArchive::annotation_author(int index) const {
  return annotation_author_.Get(index);
}
inline ::TSP::Reference* AnnotationAuthorStorageArchive::mutable_annotation_author(int index) {
  return annotation_author_.Mutable(index);
}
inline ::TSP::Reference* AnnotationAuthorStorageArchive::add_annotation_author() {
  return annotation_author_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TSP::Reference >&
AnnotationAuthorStorageArchive::annotation_author() const {
  return annotation_author_;
}
inline ::google::protobuf::RepeatedPtrField< ::TSP::Reference >*
AnnotationAuthorStorageArchive::mutable_annotation_author() {
  return &annotation_author_;
}

// -------------------------------------------------------------------

// AddAnnotationAuthorCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool AddAnnotationAuthorCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddAnnotationAuthorCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddAnnotationAuthorCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddAnnotationAuthorCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& AddAnnotationAuthorCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference document_root = 2;
inline bool AddAnnotationAuthorCommandArchive::has_document_root() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddAnnotationAuthorCommandArchive::set_has_document_root() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddAnnotationAuthorCommandArchive::clear_has_document_root() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddAnnotationAuthorCommandArchive::clear_document_root() {
  if (document_root_ != NULL) document_root_->::TSP::Reference::Clear();
  clear_has_document_root();
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::document_root() const {
  return document_root_ != NULL ? *document_root_ : *default_instance_->document_root_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::mutable_document_root() {
  set_has_document_root();
  if (document_root_ == NULL) document_root_ = new ::TSP::Reference;
  return document_root_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::release_document_root() {
  clear_has_document_root();
  ::TSP::Reference* temp = document_root_;
  document_root_ = NULL;
  return temp;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_document_root(::TSP::Reference* document_root) {
  delete document_root_;
  document_root_ = document_root;
  if (document_root) {
    set_has_document_root();
  } else {
    clear_has_document_root();
  }
}

// optional .TSP.Reference annotation_author = 3;
inline bool AddAnnotationAuthorCommandArchive::has_annotation_author() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddAnnotationAuthorCommandArchive::set_has_annotation_author() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddAnnotationAuthorCommandArchive::clear_has_annotation_author() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddAnnotationAuthorCommandArchive::clear_annotation_author() {
  if (annotation_author_ != NULL) annotation_author_->::TSP::Reference::Clear();
  clear_has_annotation_author();
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::annotation_author() const {
  return annotation_author_ != NULL ? *annotation_author_ : *default_instance_->annotation_author_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::mutable_annotation_author() {
  set_has_annotation_author();
  if (annotation_author_ == NULL) annotation_author_ = new ::TSP::Reference;
  return annotation_author_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::release_annotation_author() {
  clear_has_annotation_author();
  ::TSP::Reference* temp = annotation_author_;
  annotation_author_ = NULL;
  return temp;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_annotation_author(::TSP::Reference* annotation_author) {
  delete annotation_author_;
  annotation_author_ = annotation_author;
  if (annotation_author) {
    set_has_annotation_author();
  } else {
    clear_has_annotation_author();
  }
}

// -------------------------------------------------------------------

// SetAnnotationAuthorColorCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool SetAnnotationAuthorColorCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAnnotationAuthorColorCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& SetAnnotationAuthorColorCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference annotation_author = 2;
inline bool SetAnnotationAuthorColorCommandArchive::has_annotation_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAnnotationAuthorColorCommandArchive::set_has_annotation_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_has_annotation_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_annotation_author() {
  if (annotation_author_ != NULL) annotation_author_->::TSP::Reference::Clear();
  clear_has_annotation_author();
}
inline const ::TSP::Reference& SetAnnotationAuthorColorCommandArchive::annotation_author() const {
  return annotation_author_ != NULL ? *annotation_author_ : *default_instance_->annotation_author_;
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::mutable_annotation_author() {
  set_has_annotation_author();
  if (annotation_author_ == NULL) annotation_author_ = new ::TSP::Reference;
  return annotation_author_;
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::release_annotation_author() {
  clear_has_annotation_author();
  ::TSP::Reference* temp = annotation_author_;
  annotation_author_ = NULL;
  return temp;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_annotation_author(::TSP::Reference* annotation_author) {
  delete annotation_author_;
  annotation_author_ = annotation_author;
  if (annotation_author) {
    set_has_annotation_author();
  } else {
    clear_has_annotation_author();
  }
}

// optional .TSP.Color color = 3;
inline bool SetAnnotationAuthorColorCommandArchive::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAnnotationAuthorColorCommandArchive::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAnnotationAuthorColorCommandArchive::clear_color() {
  if (color_ != NULL) color_->::TSP::Color::Clear();
  clear_has_color();
}
inline const ::TSP::Color& SetAnnotationAuthorColorCommandArchive::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::TSP::Color;
  return color_;
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::release_color() {
  clear_has_color();
  ::TSP::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_color(::TSP::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSK

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSKArchives_2eproto__INCLUDED
