// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSWPCommandArchives.proto

#ifndef PROTOBUF_TSWPCommandArchives_2eproto__INCLUDED
#define PROTOBUF_TSWPCommandArchives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSSArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSDCommandArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSWPArchives.pb.h"
// @@protoc_insertion_point(includes)

namespace TSWP {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

class DummyCommandArchive;
class TextCommandArchive;
class ReplaceAllTextCommandArchive;
class FormatTextCommandArchive;
class SetColumnStyleCommandArchive;
class ReplaceAllUsesOfStyleCommandArchive;
class InsertAttachmentCommandArchive;
class InsertColumnsCommandArchive;
class InsertRowsCommandArchive;
class RemoveColumnsCommandArchive;
class RemoveRowsCommandArchive;
class MergeCellsCommandArchive;
class ApplyPlaceholderTextCommandArchive;
class ApplyHighlightTextCommandArchive;
class CreateHyperlinkCommandArchive;
class RemoveHyperlinkCommandArchive;
class ModifyHyperlinkCommandArchive;
class UpdateDateTimeFieldCommandArchive;
class ApplyRubyTextCommandArchive;
class RemoveRubyTextCommandArchive;
class ModifyRubyTextCommandArchive;
class ModifyTOCSettingsBaseCommandArchive;
class ModifyTOCSettingsForTOCInfoCommandArchive;
class ModifyTOCSettingsPresetForThemeCommandArchive;
class AnchorAttachmentCommandArchive;
class TextApplyThemeCommandArchive;
class MoveColumnsCommandArchive;
class MoveRowsCommandArchive;
class ShapeApplyPresetCommandArchive;
class ShapePasteStyleCommandArchive;
class StyleBaseCommandArchive;
class StyleCreateCommandArchive;
class StyleRenameCommandArchive;
class StyleUpdateCommandArchive;
class StyleDeleteCommandArchive;
class StyleReorderCommandArchive;
class StyleUpdatePropertyMapCommandArchive;

enum TextCommandArchive_Kind {
  TextCommandArchive_Kind_kKindContained = 0,
  TextCommandArchive_Kind_kKindReplaceText = 1,
  TextCommandArchive_Kind_kKindPaste = 2,
  TextCommandArchive_Kind_kKindParagraphStyle = 3,
  TextCommandArchive_Kind_kKindListStyle = 4,
  TextCommandArchive_Kind_kKindIndentParagraphLevel = 5,
  TextCommandArchive_Kind_kKindDragText = 6,
  TextCommandArchive_Kind_kKindPasteStyle = 7,
  TextCommandArchive_Kind_kKindApplyChangesInRange = 8,
  TextCommandArchive_Kind_kKindSetParagraphLevel = 9,
  TextCommandArchive_Kind_kKindInsertCitationField = 10,
  TextCommandArchive_Kind_kKindInsertBibliographyEntry = 11,
  TextCommandArchive_Kind_kKindFormatCitationFields = 12,
  TextCommandArchive_Kind_kKindInsertTOCSmartField = 13,
  TextCommandArchive_Kind_kKindInsertDateTimeField = 14,
  TextCommandArchive_Kind_kKindUpdateDateTimeField = 15,
  TextCommandArchive_Kind_kKindSetParagraphFirstTopicNumber = 16,
  TextCommandArchive_Kind_kKindCharacterStyle = 17,
  TextCommandArchive_Kind_kKindRevertStyles = 18,
  TextCommandArchive_Kind_kKindSetParagraphBidi = 19
};
bool TextCommandArchive_Kind_IsValid(int value);
const TextCommandArchive_Kind TextCommandArchive_Kind_Kind_MIN = TextCommandArchive_Kind_kKindContained;
const TextCommandArchive_Kind TextCommandArchive_Kind_Kind_MAX = TextCommandArchive_Kind_kKindSetParagraphBidi;
const int TextCommandArchive_Kind_Kind_ARRAYSIZE = TextCommandArchive_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TextCommandArchive_Kind_descriptor();
inline const ::std::string& TextCommandArchive_Kind_Name(TextCommandArchive_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TextCommandArchive_Kind_descriptor(), value);
}
inline bool TextCommandArchive_Kind_Parse(
    const ::std::string& name, TextCommandArchive_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TextCommandArchive_Kind>(
    TextCommandArchive_Kind_descriptor(), name, value);
}
// ===================================================================

class DummyCommandArchive : public ::google::protobuf::Message {
 public:
  DummyCommandArchive();
  virtual ~DummyCommandArchive();

  DummyCommandArchive(const DummyCommandArchive& from);

  inline DummyCommandArchive& operator=(const DummyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyCommandArchive& default_instance();

  void Swap(DummyCommandArchive* other);

  // implements Message ----------------------------------------------

  DummyCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DummyCommandArchive& from);
  void MergeFrom(const DummyCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 foo = 1;
  inline bool has_foo() const;
  inline void clear_foo();
  static const int kFooFieldNumber = 1;
  inline ::google::protobuf::uint32 foo() const;
  inline void set_foo(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.DummyCommandArchive)
 private:
  inline void set_has_foo();
  inline void clear_has_foo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 foo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static DummyCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class TextCommandArchive : public ::google::protobuf::Message {
 public:
  TextCommandArchive();
  virtual ~TextCommandArchive();

  TextCommandArchive(const TextCommandArchive& from);

  inline TextCommandArchive& operator=(const TextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextCommandArchive& default_instance();

  void Swap(TextCommandArchive* other);

  // implements Message ----------------------------------------------

  TextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextCommandArchive& from);
  void MergeFrom(const TextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TextCommandArchive_Kind Kind;
  static const Kind kKindContained = TextCommandArchive_Kind_kKindContained;
  static const Kind kKindReplaceText = TextCommandArchive_Kind_kKindReplaceText;
  static const Kind kKindPaste = TextCommandArchive_Kind_kKindPaste;
  static const Kind kKindParagraphStyle = TextCommandArchive_Kind_kKindParagraphStyle;
  static const Kind kKindListStyle = TextCommandArchive_Kind_kKindListStyle;
  static const Kind kKindIndentParagraphLevel = TextCommandArchive_Kind_kKindIndentParagraphLevel;
  static const Kind kKindDragText = TextCommandArchive_Kind_kKindDragText;
  static const Kind kKindPasteStyle = TextCommandArchive_Kind_kKindPasteStyle;
  static const Kind kKindApplyChangesInRange = TextCommandArchive_Kind_kKindApplyChangesInRange;
  static const Kind kKindSetParagraphLevel = TextCommandArchive_Kind_kKindSetParagraphLevel;
  static const Kind kKindInsertCitationField = TextCommandArchive_Kind_kKindInsertCitationField;
  static const Kind kKindInsertBibliographyEntry = TextCommandArchive_Kind_kKindInsertBibliographyEntry;
  static const Kind kKindFormatCitationFields = TextCommandArchive_Kind_kKindFormatCitationFields;
  static const Kind kKindInsertTOCSmartField = TextCommandArchive_Kind_kKindInsertTOCSmartField;
  static const Kind kKindInsertDateTimeField = TextCommandArchive_Kind_kKindInsertDateTimeField;
  static const Kind kKindUpdateDateTimeField = TextCommandArchive_Kind_kKindUpdateDateTimeField;
  static const Kind kKindSetParagraphFirstTopicNumber = TextCommandArchive_Kind_kKindSetParagraphFirstTopicNumber;
  static const Kind kKindCharacterStyle = TextCommandArchive_Kind_kKindCharacterStyle;
  static const Kind kKindRevertStyles = TextCommandArchive_Kind_kKindRevertStyles;
  static const Kind kKindSetParagraphBidi = TextCommandArchive_Kind_kKindSetParagraphBidi;
  static inline bool Kind_IsValid(int value) {
    return TextCommandArchive_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    TextCommandArchive_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    TextCommandArchive_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    TextCommandArchive_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return TextCommandArchive_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return TextCommandArchive_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return TextCommandArchive_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional uint32 restore_range_location = 4;
  inline bool has_restore_range_location() const;
  inline void clear_restore_range_location();
  static const int kRestoreRangeLocationFieldNumber = 4;
  inline ::google::protobuf::uint32 restore_range_location() const;
  inline void set_restore_range_location(::google::protobuf::uint32 value);

  // optional uint32 restore_range_length = 5;
  inline bool has_restore_range_length() const;
  inline void clear_restore_range_length();
  static const int kRestoreRangeLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 restore_range_length() const;
  inline void set_restore_range_length(::google::protobuf::uint32 value);

  // optional uint32 redo_restore_range_location = 6;
  inline bool has_redo_restore_range_location() const;
  inline void clear_redo_restore_range_location();
  static const int kRedoRestoreRangeLocationFieldNumber = 6;
  inline ::google::protobuf::uint32 redo_restore_range_location() const;
  inline void set_redo_restore_range_location(::google::protobuf::uint32 value);

  // optional uint32 redo_restore_range_length = 7;
  inline bool has_redo_restore_range_length() const;
  inline void clear_redo_restore_range_length();
  static const int kRedoRestoreRangeLengthFieldNumber = 7;
  inline ::google::protobuf::uint32 redo_restore_range_length() const;
  inline void set_redo_restore_range_length(::google::protobuf::uint32 value);

  // optional uint32 text_command_flags = 9;
  inline bool has_text_command_flags() const;
  inline void clear_text_command_flags();
  static const int kTextCommandFlagsFieldNumber = 9;
  inline ::google::protobuf::uint32 text_command_flags() const;
  inline void set_text_command_flags(::google::protobuf::uint32 value);

  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 10;
  inline ::TSWP::TextCommandArchive_Kind kind() const;
  inline void set_kind(::TSWP::TextCommandArchive_Kind value);

  // @@protoc_insertion_point(class_scope:TSWP.TextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_restore_range_location();
  inline void clear_has_restore_range_location();
  inline void set_has_restore_range_length();
  inline void clear_has_restore_range_length();
  inline void set_has_redo_restore_range_location();
  inline void clear_has_redo_restore_range_location();
  inline void set_has_redo_restore_range_length();
  inline void clear_has_redo_restore_range_length();
  inline void set_has_text_command_flags();
  inline void clear_has_text_command_flags();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::uint32 restore_range_location_;
  ::google::protobuf::uint32 restore_range_length_;
  ::google::protobuf::uint32 redo_restore_range_location_;
  ::google::protobuf::uint32 redo_restore_range_length_;
  ::google::protobuf::uint32 text_command_flags_;
  int kind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceAllTextCommandArchive : public ::google::protobuf::Message {
 public:
  ReplaceAllTextCommandArchive();
  virtual ~ReplaceAllTextCommandArchive();

  ReplaceAllTextCommandArchive(const ReplaceAllTextCommandArchive& from);

  inline ReplaceAllTextCommandArchive& operator=(const ReplaceAllTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceAllTextCommandArchive& default_instance();

  void Swap(ReplaceAllTextCommandArchive* other);

  // implements Message ----------------------------------------------

  ReplaceAllTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceAllTextCommandArchive& from);
  void MergeFrom(const ReplaceAllTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.ReplaceAllChildCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::ReplaceAllChildCommandArchive& super() const;
  inline ::TSK::ReplaceAllChildCommandArchive* mutable_super();
  inline ::TSK::ReplaceAllChildCommandArchive* release_super();
  inline void set_allocated_super(::TSK::ReplaceAllChildCommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ReplaceAllTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::ReplaceAllChildCommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ReplaceAllTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class FormatTextCommandArchive : public ::google::protobuf::Message {
 public:
  FormatTextCommandArchive();
  virtual ~FormatTextCommandArchive();

  FormatTextCommandArchive(const FormatTextCommandArchive& from);

  inline FormatTextCommandArchive& operator=(const FormatTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormatTextCommandArchive& default_instance();

  void Swap(FormatTextCommandArchive* other);

  // implements Message ----------------------------------------------

  FormatTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FormatTextCommandArchive& from);
  void MergeFrom(const FormatTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional uint32 selection_range_location = 8;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 8;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 9;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 9;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional uint32 text_command_flags = 11;
  inline bool has_text_command_flags() const;
  inline void clear_text_command_flags();
  static const int kTextCommandFlagsFieldNumber = 11;
  inline ::google::protobuf::uint32 text_command_flags() const;
  inline void set_text_command_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.FormatTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_text_command_flags();
  inline void clear_has_text_command_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::google::protobuf::uint32 text_command_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static FormatTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class SetColumnStyleCommandArchive : public ::google::protobuf::Message {
 public:
  SetColumnStyleCommandArchive();
  virtual ~SetColumnStyleCommandArchive();

  SetColumnStyleCommandArchive(const SetColumnStyleCommandArchive& from);

  inline SetColumnStyleCommandArchive& operator=(const SetColumnStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetColumnStyleCommandArchive& default_instance();

  void Swap(SetColumnStyleCommandArchive* other);

  // implements Message ----------------------------------------------

  SetColumnStyleCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetColumnStyleCommandArchive& from);
  void MergeFrom(const SetColumnStyleCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.SetColumnStyleCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static SetColumnStyleCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceAllUsesOfStyleCommandArchive : public ::google::protobuf::Message {
 public:
  ReplaceAllUsesOfStyleCommandArchive();
  virtual ~ReplaceAllUsesOfStyleCommandArchive();

  ReplaceAllUsesOfStyleCommandArchive(const ReplaceAllUsesOfStyleCommandArchive& from);

  inline ReplaceAllUsesOfStyleCommandArchive& operator=(const ReplaceAllUsesOfStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceAllUsesOfStyleCommandArchive& default_instance();

  void Swap(ReplaceAllUsesOfStyleCommandArchive* other);

  // implements Message ----------------------------------------------

  ReplaceAllUsesOfStyleCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceAllUsesOfStyleCommandArchive& from);
  void MergeFrom(const ReplaceAllUsesOfStyleCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 3;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ReplaceAllUsesOfStyleCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ReplaceAllUsesOfStyleCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertAttachmentCommandArchive : public ::google::protobuf::Message {
 public:
  InsertAttachmentCommandArchive();
  virtual ~InsertAttachmentCommandArchive();

  InsertAttachmentCommandArchive(const InsertAttachmentCommandArchive& from);

  inline InsertAttachmentCommandArchive& operator=(const InsertAttachmentCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertAttachmentCommandArchive& default_instance();

  void Swap(InsertAttachmentCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertAttachmentCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertAttachmentCommandArchive& from);
  void MergeFrom(const InsertAttachmentCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional .TSP.Reference attachment = 5;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 5;
  inline const ::TSP::Reference& attachment() const;
  inline ::TSP::Reference* mutable_attachment();
  inline ::TSP::Reference* release_attachment();
  inline void set_allocated_attachment(::TSP::Reference* attachment);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional uint32 text_command_flags = 7;
  inline bool has_text_command_flags() const;
  inline void clear_text_command_flags();
  static const int kTextCommandFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 text_command_flags() const;
  inline void set_text_command_flags(::google::protobuf::uint32 value);

  // optional uint32 redo_restore_range_location = 8;
  inline bool has_redo_restore_range_location() const;
  inline void clear_redo_restore_range_location();
  static const int kRedoRestoreRangeLocationFieldNumber = 8;
  inline ::google::protobuf::uint32 redo_restore_range_location() const;
  inline void set_redo_restore_range_location(::google::protobuf::uint32 value);

  // optional uint32 redo_restore_range_length = 9;
  inline bool has_redo_restore_range_length() const;
  inline void clear_redo_restore_range_length();
  static const int kRedoRestoreRangeLengthFieldNumber = 9;
  inline ::google::protobuf::uint32 redo_restore_range_length() const;
  inline void set_redo_restore_range_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.InsertAttachmentCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_text_command_flags();
  inline void clear_has_text_command_flags();
  inline void set_has_redo_restore_range_location();
  inline void clear_has_redo_restore_range_location();
  inline void set_has_redo_restore_range_length();
  inline void clear_has_redo_restore_range_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::TSP::Reference* attachment_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::uint32 text_command_flags_;
  ::google::protobuf::uint32 redo_restore_range_location_;
  ::google::protobuf::uint32 redo_restore_range_length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertAttachmentCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertColumnsCommandArchive : public ::google::protobuf::Message {
 public:
  InsertColumnsCommandArchive();
  virtual ~InsertColumnsCommandArchive();

  InsertColumnsCommandArchive(const InsertColumnsCommandArchive& from);

  inline InsertColumnsCommandArchive& operator=(const InsertColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertColumnsCommandArchive& default_instance();

  void Swap(InsertColumnsCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertColumnsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertColumnsCommandArchive& from);
  void MergeFrom(const InsertColumnsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 column_index = 3;
  inline bool has_column_index() const;
  inline void clear_column_index();
  static const int kColumnIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 column_index() const;
  inline void set_column_index(::google::protobuf::uint32 value);

  // optional uint32 column_count = 4;
  inline bool has_column_count() const;
  inline void clear_column_count();
  static const int kColumnCountFieldNumber = 4;
  inline ::google::protobuf::uint32 column_count() const;
  inline void set_column_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.InsertColumnsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_column_index();
  inline void clear_has_column_index();
  inline void set_has_column_count();
  inline void clear_has_column_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 column_index_;
  ::google::protobuf::uint32 column_count_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertColumnsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class InsertRowsCommandArchive : public ::google::protobuf::Message {
 public:
  InsertRowsCommandArchive();
  virtual ~InsertRowsCommandArchive();

  InsertRowsCommandArchive(const InsertRowsCommandArchive& from);

  inline InsertRowsCommandArchive& operator=(const InsertRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertRowsCommandArchive& default_instance();

  void Swap(InsertRowsCommandArchive* other);

  // implements Message ----------------------------------------------

  InsertRowsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertRowsCommandArchive& from);
  void MergeFrom(const InsertRowsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 row_index = 3;
  inline bool has_row_index() const;
  inline void clear_row_index();
  static const int kRowIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 row_index() const;
  inline void set_row_index(::google::protobuf::uint32 value);

  // optional uint32 row_count = 4;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 4;
  inline ::google::protobuf::uint32 row_count() const;
  inline void set_row_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.InsertRowsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_row_index();
  inline void clear_has_row_index();
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 row_index_;
  ::google::protobuf::uint32 row_count_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static InsertRowsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveColumnsCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveColumnsCommandArchive();
  virtual ~RemoveColumnsCommandArchive();

  RemoveColumnsCommandArchive(const RemoveColumnsCommandArchive& from);

  inline RemoveColumnsCommandArchive& operator=(const RemoveColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveColumnsCommandArchive& default_instance();

  void Swap(RemoveColumnsCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveColumnsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveColumnsCommandArchive& from);
  void MergeFrom(const RemoveColumnsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 column_index = 3;
  inline bool has_column_index() const;
  inline void clear_column_index();
  static const int kColumnIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 column_index() const;
  inline void set_column_index(::google::protobuf::uint32 value);

  // optional uint32 column_count = 4;
  inline bool has_column_count() const;
  inline void clear_column_count();
  static const int kColumnCountFieldNumber = 4;
  inline ::google::protobuf::uint32 column_count() const;
  inline void set_column_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.RemoveColumnsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_column_index();
  inline void clear_has_column_index();
  inline void set_has_column_count();
  inline void clear_has_column_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 column_index_;
  ::google::protobuf::uint32 column_count_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveColumnsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveRowsCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveRowsCommandArchive();
  virtual ~RemoveRowsCommandArchive();

  RemoveRowsCommandArchive(const RemoveRowsCommandArchive& from);

  inline RemoveRowsCommandArchive& operator=(const RemoveRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveRowsCommandArchive& default_instance();

  void Swap(RemoveRowsCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveRowsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveRowsCommandArchive& from);
  void MergeFrom(const RemoveRowsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 row_index = 3;
  inline bool has_row_index() const;
  inline void clear_row_index();
  static const int kRowIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 row_index() const;
  inline void set_row_index(::google::protobuf::uint32 value);

  // optional uint32 row_count = 4;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 4;
  inline ::google::protobuf::uint32 row_count() const;
  inline void set_row_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.RemoveRowsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_row_index();
  inline void clear_has_row_index();
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 row_index_;
  ::google::protobuf::uint32 row_count_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveRowsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MergeCellsCommandArchive : public ::google::protobuf::Message {
 public:
  MergeCellsCommandArchive();
  virtual ~MergeCellsCommandArchive();

  MergeCellsCommandArchive(const MergeCellsCommandArchive& from);

  inline MergeCellsCommandArchive& operator=(const MergeCellsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeCellsCommandArchive& default_instance();

  void Swap(MergeCellsCommandArchive* other);

  // implements Message ----------------------------------------------

  MergeCellsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeCellsCommandArchive& from);
  void MergeFrom(const MergeCellsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 row = 3;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 3;
  inline ::google::protobuf::uint32 row() const;
  inline void set_row(::google::protobuf::uint32 value);

  // optional uint32 column = 4;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 4;
  inline ::google::protobuf::uint32 column() const;
  inline void set_column(::google::protobuf::uint32 value);

  // optional uint32 row_count = 5;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 5;
  inline ::google::protobuf::uint32 row_count() const;
  inline void set_row_count(::google::protobuf::uint32 value);

  // optional uint32 column_count = 6;
  inline bool has_column_count() const;
  inline void clear_column_count();
  static const int kColumnCountFieldNumber = 6;
  inline ::google::protobuf::uint32 column_count() const;
  inline void set_column_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 7;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 7;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.MergeCellsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_column_count();
  inline void clear_has_column_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 row_;
  ::google::protobuf::uint32 column_;
  ::google::protobuf::uint32 row_count_;
  ::google::protobuf::uint32 column_count_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MergeCellsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ApplyPlaceholderTextCommandArchive : public ::google::protobuf::Message {
 public:
  ApplyPlaceholderTextCommandArchive();
  virtual ~ApplyPlaceholderTextCommandArchive();

  ApplyPlaceholderTextCommandArchive(const ApplyPlaceholderTextCommandArchive& from);

  inline ApplyPlaceholderTextCommandArchive& operator=(const ApplyPlaceholderTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyPlaceholderTextCommandArchive& default_instance();

  void Swap(ApplyPlaceholderTextCommandArchive* other);

  // implements Message ----------------------------------------------

  ApplyPlaceholderTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyPlaceholderTextCommandArchive& from);
  void MergeFrom(const ApplyPlaceholderTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ApplyPlaceholderTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ApplyPlaceholderTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ApplyHighlightTextCommandArchive : public ::google::protobuf::Message {
 public:
  ApplyHighlightTextCommandArchive();
  virtual ~ApplyHighlightTextCommandArchive();

  ApplyHighlightTextCommandArchive(const ApplyHighlightTextCommandArchive& from);

  inline ApplyHighlightTextCommandArchive& operator=(const ApplyHighlightTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyHighlightTextCommandArchive& default_instance();

  void Swap(ApplyHighlightTextCommandArchive* other);

  // implements Message ----------------------------------------------

  ApplyHighlightTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyHighlightTextCommandArchive& from);
  void MergeFrom(const ApplyHighlightTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional bool remove = 6;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 6;
  inline bool remove() const;
  inline void set_remove(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.ApplyHighlightTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_remove();
  inline void clear_has_remove();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::TSWP::UndoTransaction* undo_transaction_;
  bool remove_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ApplyHighlightTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class CreateHyperlinkCommandArchive : public ::google::protobuf::Message {
 public:
  CreateHyperlinkCommandArchive();
  virtual ~CreateHyperlinkCommandArchive();

  CreateHyperlinkCommandArchive(const CreateHyperlinkCommandArchive& from);

  inline CreateHyperlinkCommandArchive& operator=(const CreateHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateHyperlinkCommandArchive& default_instance();

  void Swap(CreateHyperlinkCommandArchive* other);

  // implements Message ----------------------------------------------

  CreateHyperlinkCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateHyperlinkCommandArchive& from);
  void MergeFrom(const CreateHyperlinkCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional string url_ref = 5;
  inline bool has_url_ref() const;
  inline void clear_url_ref();
  static const int kUrlRefFieldNumber = 5;
  inline const ::std::string& url_ref() const;
  inline void set_url_ref(const ::std::string& value);
  inline void set_url_ref(const char* value);
  inline void set_url_ref(const char* value, size_t size);
  inline ::std::string* mutable_url_ref();
  inline ::std::string* release_url_ref();
  inline void set_allocated_url_ref(::std::string* url_ref);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.CreateHyperlinkCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_url_ref();
  inline void clear_has_url_ref();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::std::string* url_ref_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static CreateHyperlinkCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveHyperlinkCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveHyperlinkCommandArchive();
  virtual ~RemoveHyperlinkCommandArchive();

  RemoveHyperlinkCommandArchive(const RemoveHyperlinkCommandArchive& from);

  inline RemoveHyperlinkCommandArchive& operator=(const RemoveHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveHyperlinkCommandArchive& default_instance();

  void Swap(RemoveHyperlinkCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveHyperlinkCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveHyperlinkCommandArchive& from);
  void MergeFrom(const RemoveHyperlinkCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional bool is_remove_character_style = 6 [default = true];
  inline bool has_is_remove_character_style() const;
  inline void clear_is_remove_character_style();
  static const int kIsRemoveCharacterStyleFieldNumber = 6;
  inline bool is_remove_character_style() const;
  inline void set_is_remove_character_style(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.RemoveHyperlinkCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_is_remove_character_style();
  inline void clear_has_is_remove_character_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::TSWP::UndoTransaction* undo_transaction_;
  bool is_remove_character_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveHyperlinkCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ModifyHyperlinkCommandArchive : public ::google::protobuf::Message {
 public:
  ModifyHyperlinkCommandArchive();
  virtual ~ModifyHyperlinkCommandArchive();

  ModifyHyperlinkCommandArchive(const ModifyHyperlinkCommandArchive& from);

  inline ModifyHyperlinkCommandArchive& operator=(const ModifyHyperlinkCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyHyperlinkCommandArchive& default_instance();

  void Swap(ModifyHyperlinkCommandArchive* other);

  // implements Message ----------------------------------------------

  ModifyHyperlinkCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyHyperlinkCommandArchive& from);
  void MergeFrom(const ModifyHyperlinkCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference hyperlink = 2;
  inline bool has_hyperlink() const;
  inline void clear_hyperlink();
  static const int kHyperlinkFieldNumber = 2;
  inline const ::TSP::Reference& hyperlink() const;
  inline ::TSP::Reference* mutable_hyperlink();
  inline ::TSP::Reference* release_hyperlink();
  inline void set_allocated_hyperlink(::TSP::Reference* hyperlink);

  // optional string display_text = 3;
  inline bool has_display_text() const;
  inline void clear_display_text();
  static const int kDisplayTextFieldNumber = 3;
  inline const ::std::string& display_text() const;
  inline void set_display_text(const ::std::string& value);
  inline void set_display_text(const char* value);
  inline void set_display_text(const char* value, size_t size);
  inline ::std::string* mutable_display_text();
  inline ::std::string* release_display_text();
  inline void set_allocated_display_text(::std::string* display_text);

  // optional string url_ref = 4;
  inline bool has_url_ref() const;
  inline void clear_url_ref();
  static const int kUrlRefFieldNumber = 4;
  inline const ::std::string& url_ref() const;
  inline void set_url_ref(const ::std::string& value);
  inline void set_url_ref(const char* value);
  inline void set_url_ref(const char* value, size_t size);
  inline ::std::string* mutable_url_ref();
  inline ::std::string* release_url_ref();
  inline void set_allocated_url_ref(::std::string* url_ref);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ModifyHyperlinkCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_hyperlink();
  inline void clear_has_hyperlink();
  inline void set_has_display_text();
  inline void clear_has_display_text();
  inline void set_has_url_ref();
  inline void clear_has_url_ref();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* hyperlink_;
  ::std::string* display_text_;
  ::std::string* url_ref_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ModifyHyperlinkCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class UpdateDateTimeFieldCommandArchive : public ::google::protobuf::Message {
 public:
  UpdateDateTimeFieldCommandArchive();
  virtual ~UpdateDateTimeFieldCommandArchive();

  UpdateDateTimeFieldCommandArchive(const UpdateDateTimeFieldCommandArchive& from);

  inline UpdateDateTimeFieldCommandArchive& operator=(const UpdateDateTimeFieldCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateDateTimeFieldCommandArchive& default_instance();

  void Swap(UpdateDateTimeFieldCommandArchive* other);

  // implements Message ----------------------------------------------

  UpdateDateTimeFieldCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateDateTimeFieldCommandArchive& from);
  void MergeFrom(const UpdateDateTimeFieldCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.TextCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::TextCommandArchive& super() const;
  inline ::TSWP::TextCommandArchive* mutable_super();
  inline ::TSWP::TextCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::TextCommandArchive* super);

  // optional .TSP.Reference date_time_field = 2;
  inline bool has_date_time_field() const;
  inline void clear_date_time_field();
  static const int kDateTimeFieldFieldNumber = 2;
  inline const ::TSP::Reference& date_time_field() const;
  inline ::TSP::Reference* mutable_date_time_field();
  inline ::TSP::Reference* release_date_time_field();
  inline void set_allocated_date_time_field(::TSP::Reference* date_time_field);

  // optional .TSP.Date date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::TSP::Date& date() const;
  inline ::TSP::Date* mutable_date();
  inline ::TSP::Date* release_date();
  inline void set_allocated_date(::TSP::Date* date);

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
  inline bool has_date_style() const;
  inline void clear_date_style();
  static const int kDateStyleFieldNumber = 4;
  inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle date_style() const;
  inline void set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
  inline bool has_time_style() const;
  inline void clear_time_style();
  static const int kTimeStyleFieldNumber = 5;
  inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle time_style() const;
  inline void set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value);

  // @@protoc_insertion_point(class_scope:TSWP.UpdateDateTimeFieldCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_date_time_field();
  inline void clear_has_date_time_field();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_date_style();
  inline void clear_has_date_style();
  inline void set_has_time_style();
  inline void clear_has_time_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::TextCommandArchive* super_;
  ::TSP::Reference* date_time_field_;
  ::TSP::Date* date_;
  int date_style_;
  int time_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static UpdateDateTimeFieldCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ApplyRubyTextCommandArchive : public ::google::protobuf::Message {
 public:
  ApplyRubyTextCommandArchive();
  virtual ~ApplyRubyTextCommandArchive();

  ApplyRubyTextCommandArchive(const ApplyRubyTextCommandArchive& from);

  inline ApplyRubyTextCommandArchive& operator=(const ApplyRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyRubyTextCommandArchive& default_instance();

  void Swap(ApplyRubyTextCommandArchive* other);

  // implements Message ----------------------------------------------

  ApplyRubyTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyRubyTextCommandArchive& from);
  void MergeFrom(const ApplyRubyTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional string ruby_text = 5;
  inline bool has_ruby_text() const;
  inline void clear_ruby_text();
  static const int kRubyTextFieldNumber = 5;
  inline const ::std::string& ruby_text() const;
  inline void set_ruby_text(const ::std::string& value);
  inline void set_ruby_text(const char* value);
  inline void set_ruby_text(const char* value, size_t size);
  inline ::std::string* mutable_ruby_text();
  inline ::std::string* release_ruby_text();
  inline void set_allocated_ruby_text(::std::string* ruby_text);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ApplyRubyTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_ruby_text();
  inline void clear_has_ruby_text();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::std::string* ruby_text_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ApplyRubyTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class RemoveRubyTextCommandArchive : public ::google::protobuf::Message {
 public:
  RemoveRubyTextCommandArchive();
  virtual ~RemoveRubyTextCommandArchive();

  RemoveRubyTextCommandArchive(const RemoveRubyTextCommandArchive& from);

  inline RemoveRubyTextCommandArchive& operator=(const RemoveRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveRubyTextCommandArchive& default_instance();

  void Swap(RemoveRubyTextCommandArchive* other);

  // implements Message ----------------------------------------------

  RemoveRubyTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveRubyTextCommandArchive& from);
  void MergeFrom(const RemoveRubyTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 selection_range_location = 3;
  inline bool has_selection_range_location() const;
  inline void clear_selection_range_location();
  static const int kSelectionRangeLocationFieldNumber = 3;
  inline ::google::protobuf::uint32 selection_range_location() const;
  inline void set_selection_range_location(::google::protobuf::uint32 value);

  // optional uint32 selection_range_length = 4;
  inline bool has_selection_range_length() const;
  inline void clear_selection_range_length();
  static const int kSelectionRangeLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 selection_range_length() const;
  inline void set_selection_range_length(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.RemoveRubyTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_selection_range_location();
  inline void clear_has_selection_range_location();
  inline void set_has_selection_range_length();
  inline void clear_has_selection_range_length();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 selection_range_location_;
  ::google::protobuf::uint32 selection_range_length_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static RemoveRubyTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRubyTextCommandArchive : public ::google::protobuf::Message {
 public:
  ModifyRubyTextCommandArchive();
  virtual ~ModifyRubyTextCommandArchive();

  ModifyRubyTextCommandArchive(const ModifyRubyTextCommandArchive& from);

  inline ModifyRubyTextCommandArchive& operator=(const ModifyRubyTextCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRubyTextCommandArchive& default_instance();

  void Swap(ModifyRubyTextCommandArchive* other);

  // implements Message ----------------------------------------------

  ModifyRubyTextCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRubyTextCommandArchive& from);
  void MergeFrom(const ModifyRubyTextCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference ruby_field = 2;
  inline bool has_ruby_field() const;
  inline void clear_ruby_field();
  static const int kRubyFieldFieldNumber = 2;
  inline const ::TSP::Reference& ruby_field() const;
  inline ::TSP::Reference* mutable_ruby_field();
  inline ::TSP::Reference* release_ruby_field();
  inline void set_allocated_ruby_field(::TSP::Reference* ruby_field);

  // optional string ruby_text = 3;
  inline bool has_ruby_text() const;
  inline void clear_ruby_text();
  static const int kRubyTextFieldNumber = 3;
  inline const ::std::string& ruby_text() const;
  inline void set_ruby_text(const ::std::string& value);
  inline void set_ruby_text(const char* value);
  inline void set_ruby_text(const char* value, size_t size);
  inline ::std::string* mutable_ruby_text();
  inline ::std::string* release_ruby_text();
  inline void set_allocated_ruby_text(::std::string* ruby_text);

  // optional string base_text = 4;
  inline bool has_base_text() const;
  inline void clear_base_text();
  static const int kBaseTextFieldNumber = 4;
  inline const ::std::string& base_text() const;
  inline void set_base_text(const ::std::string& value);
  inline void set_base_text(const char* value);
  inline void set_base_text(const char* value, size_t size);
  inline ::std::string* mutable_base_text();
  inline ::std::string* release_base_text();
  inline void set_allocated_base_text(::std::string* base_text);

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 5;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.ModifyRubyTextCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_ruby_field();
  inline void clear_has_ruby_field();
  inline void set_has_ruby_text();
  inline void clear_has_ruby_text();
  inline void set_has_base_text();
  inline void clear_has_base_text();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* ruby_field_;
  ::std::string* ruby_text_;
  ::std::string* base_text_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ModifyRubyTextCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsBaseCommandArchive : public ::google::protobuf::Message {
 public:
  ModifyTOCSettingsBaseCommandArchive();
  virtual ~ModifyTOCSettingsBaseCommandArchive();

  ModifyTOCSettingsBaseCommandArchive(const ModifyTOCSettingsBaseCommandArchive& from);

  inline ModifyTOCSettingsBaseCommandArchive& operator=(const ModifyTOCSettingsBaseCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyTOCSettingsBaseCommandArchive& default_instance();

  void Swap(ModifyTOCSettingsBaseCommandArchive* other);

  // implements Message ----------------------------------------------

  ModifyTOCSettingsBaseCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyTOCSettingsBaseCommandArchive& from);
  void MergeFrom(const ModifyTOCSettingsBaseCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference old_toc_settings = 2;
  inline bool has_old_toc_settings() const;
  inline void clear_old_toc_settings();
  static const int kOldTocSettingsFieldNumber = 2;
  inline const ::TSP::Reference& old_toc_settings() const;
  inline ::TSP::Reference* mutable_old_toc_settings();
  inline ::TSP::Reference* release_old_toc_settings();
  inline void set_allocated_old_toc_settings(::TSP::Reference* old_toc_settings);

  // optional .TSP.Reference new_toc_settings = 3;
  inline bool has_new_toc_settings() const;
  inline void clear_new_toc_settings();
  static const int kNewTocSettingsFieldNumber = 3;
  inline const ::TSP::Reference& new_toc_settings() const;
  inline ::TSP::Reference* mutable_new_toc_settings();
  inline ::TSP::Reference* release_new_toc_settings();
  inline void set_allocated_new_toc_settings(::TSP::Reference* new_toc_settings);

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsBaseCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_toc_settings();
  inline void clear_has_old_toc_settings();
  inline void set_has_new_toc_settings();
  inline void clear_has_new_toc_settings();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* old_toc_settings_;
  ::TSP::Reference* new_toc_settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ModifyTOCSettingsBaseCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsForTOCInfoCommandArchive : public ::google::protobuf::Message {
 public:
  ModifyTOCSettingsForTOCInfoCommandArchive();
  virtual ~ModifyTOCSettingsForTOCInfoCommandArchive();

  ModifyTOCSettingsForTOCInfoCommandArchive(const ModifyTOCSettingsForTOCInfoCommandArchive& from);

  inline ModifyTOCSettingsForTOCInfoCommandArchive& operator=(const ModifyTOCSettingsForTOCInfoCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyTOCSettingsForTOCInfoCommandArchive& default_instance();

  void Swap(ModifyTOCSettingsForTOCInfoCommandArchive* other);

  // implements Message ----------------------------------------------

  ModifyTOCSettingsForTOCInfoCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyTOCSettingsForTOCInfoCommandArchive& from);
  void MergeFrom(const ModifyTOCSettingsForTOCInfoCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super() const;
  inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* mutable_super();
  inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super);

  // optional .TSP.Reference toc_info = 2;
  inline bool has_toc_info() const;
  inline void clear_toc_info();
  static const int kTocInfoFieldNumber = 2;
  inline const ::TSP::Reference& toc_info() const;
  inline ::TSP::Reference* mutable_toc_info();
  inline ::TSP::Reference* release_toc_info();
  inline void set_allocated_toc_info(::TSP::Reference* toc_info);

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_toc_info();
  inline void clear_has_toc_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ModifyTOCSettingsBaseCommandArchive* super_;
  ::TSP::Reference* toc_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ModifyTOCSettingsForTOCInfoCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ModifyTOCSettingsPresetForThemeCommandArchive : public ::google::protobuf::Message {
 public:
  ModifyTOCSettingsPresetForThemeCommandArchive();
  virtual ~ModifyTOCSettingsPresetForThemeCommandArchive();

  ModifyTOCSettingsPresetForThemeCommandArchive(const ModifyTOCSettingsPresetForThemeCommandArchive& from);

  inline ModifyTOCSettingsPresetForThemeCommandArchive& operator=(const ModifyTOCSettingsPresetForThemeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyTOCSettingsPresetForThemeCommandArchive& default_instance();

  void Swap(ModifyTOCSettingsPresetForThemeCommandArchive* other);

  // implements Message ----------------------------------------------

  ModifyTOCSettingsPresetForThemeCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyTOCSettingsPresetForThemeCommandArchive& from);
  void MergeFrom(const ModifyTOCSettingsPresetForThemeCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super() const;
  inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* mutable_super();
  inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super);

  // optional .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // optional uint32 preset_index = 3;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 preset_index() const;
  inline void set_preset_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::ModifyTOCSettingsBaseCommandArchive* super_;
  ::TSP::Reference* theme_;
  ::google::protobuf::uint32 preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ModifyTOCSettingsPresetForThemeCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class AnchorAttachmentCommandArchive : public ::google::protobuf::Message {
 public:
  AnchorAttachmentCommandArchive();
  virtual ~AnchorAttachmentCommandArchive();

  AnchorAttachmentCommandArchive(const AnchorAttachmentCommandArchive& from);

  inline AnchorAttachmentCommandArchive& operator=(const AnchorAttachmentCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnchorAttachmentCommandArchive& default_instance();

  void Swap(AnchorAttachmentCommandArchive* other);

  // implements Message ----------------------------------------------

  AnchorAttachmentCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnchorAttachmentCommandArchive& from);
  void MergeFrom(const AnchorAttachmentCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSP.Reference attachment = 3;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 3;
  inline const ::TSP::Reference& attachment() const;
  inline ::TSP::Reference* mutable_attachment();
  inline ::TSP::Reference* release_attachment();
  inline void set_allocated_attachment(::TSP::Reference* attachment);

  // optional uint32 h_offset_type = 4;
  inline bool has_h_offset_type() const;
  inline void clear_h_offset_type();
  static const int kHOffsetTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 h_offset_type() const;
  inline void set_h_offset_type(::google::protobuf::uint32 value);

  // optional float h_offset = 5;
  inline bool has_h_offset() const;
  inline void clear_h_offset();
  static const int kHOffsetFieldNumber = 5;
  inline float h_offset() const;
  inline void set_h_offset(float value);

  // optional uint32 v_offset_type = 6;
  inline bool has_v_offset_type() const;
  inline void clear_v_offset_type();
  static const int kVOffsetTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 v_offset_type() const;
  inline void set_v_offset_type(::google::protobuf::uint32 value);

  // optional float v_offset = 7;
  inline bool has_v_offset() const;
  inline void clear_v_offset();
  static const int kVOffsetFieldNumber = 7;
  inline float v_offset() const;
  inline void set_v_offset(float value);

  // optional .TSWP.UndoTransaction undo_transaction = 8;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 8;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // optional bool is_html_wrap = 9;
  inline bool has_is_html_wrap() const;
  inline void clear_is_html_wrap();
  static const int kIsHtmlWrapFieldNumber = 9;
  inline bool is_html_wrap() const;
  inline void set_is_html_wrap(bool value);

  // @@protoc_insertion_point(class_scope:TSWP.AnchorAttachmentCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_h_offset_type();
  inline void clear_has_h_offset_type();
  inline void set_has_h_offset();
  inline void clear_has_h_offset();
  inline void set_has_v_offset_type();
  inline void clear_has_v_offset_type();
  inline void set_has_v_offset();
  inline void clear_has_v_offset();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();
  inline void set_has_is_html_wrap();
  inline void clear_has_is_html_wrap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSP::Reference* attachment_;
  ::google::protobuf::uint32 h_offset_type_;
  float h_offset_;
  ::google::protobuf::uint32 v_offset_type_;
  float v_offset_;
  ::TSWP::UndoTransaction* undo_transaction_;
  bool is_html_wrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static AnchorAttachmentCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class TextApplyThemeCommandArchive : public ::google::protobuf::Message {
 public:
  TextApplyThemeCommandArchive();
  virtual ~TextApplyThemeCommandArchive();

  TextApplyThemeCommandArchive(const TextApplyThemeCommandArchive& from);

  inline TextApplyThemeCommandArchive& operator=(const TextApplyThemeCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextApplyThemeCommandArchive& default_instance();

  void Swap(TextApplyThemeCommandArchive* other);

  // implements Message ----------------------------------------------

  TextApplyThemeCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextApplyThemeCommandArchive& from);
  void MergeFrom(const TextApplyThemeCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSS.ApplyThemeChildCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::ApplyThemeChildCommandArchive& super() const;
  inline ::TSS::ApplyThemeChildCommandArchive* mutable_super();
  inline ::TSS::ApplyThemeChildCommandArchive* release_super();
  inline void set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.TextApplyThemeCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::ApplyThemeChildCommandArchive* super_;
  ::TSP::Reference* storage_;
  ::TSWP::UndoTransaction* undo_transaction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static TextApplyThemeCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveColumnsCommandArchive : public ::google::protobuf::Message {
 public:
  MoveColumnsCommandArchive();
  virtual ~MoveColumnsCommandArchive();

  MoveColumnsCommandArchive(const MoveColumnsCommandArchive& from);

  inline MoveColumnsCommandArchive& operator=(const MoveColumnsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveColumnsCommandArchive& default_instance();

  void Swap(MoveColumnsCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveColumnsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveColumnsCommandArchive& from);
  void MergeFrom(const MoveColumnsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 src_index = 3;
  inline bool has_src_index() const;
  inline void clear_src_index();
  static const int kSrcIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 src_index() const;
  inline void set_src_index(::google::protobuf::uint32 value);

  // optional uint32 dst_index = 4;
  inline bool has_dst_index() const;
  inline void clear_dst_index();
  static const int kDstIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 dst_index() const;
  inline void set_dst_index(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.MoveColumnsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_src_index();
  inline void clear_has_src_index();
  inline void set_has_dst_index();
  inline void clear_has_dst_index();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 src_index_;
  ::google::protobuf::uint32 dst_index_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveColumnsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class MoveRowsCommandArchive : public ::google::protobuf::Message {
 public:
  MoveRowsCommandArchive();
  virtual ~MoveRowsCommandArchive();

  MoveRowsCommandArchive(const MoveRowsCommandArchive& from);

  inline MoveRowsCommandArchive& operator=(const MoveRowsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveRowsCommandArchive& default_instance();

  void Swap(MoveRowsCommandArchive* other);

  // implements Message ----------------------------------------------

  MoveRowsCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveRowsCommandArchive& from);
  void MergeFrom(const MoveRowsCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference storage = 2;
  inline bool has_storage() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 2;
  inline const ::TSP::Reference& storage() const;
  inline ::TSP::Reference* mutable_storage();
  inline ::TSP::Reference* release_storage();
  inline void set_allocated_storage(::TSP::Reference* storage);

  // optional uint32 src_index = 3;
  inline bool has_src_index() const;
  inline void clear_src_index();
  static const int kSrcIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 src_index() const;
  inline void set_src_index(::google::protobuf::uint32 value);

  // optional uint32 dst_index = 4;
  inline bool has_dst_index() const;
  inline void clear_dst_index();
  static const int kDstIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 dst_index() const;
  inline void set_dst_index(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  inline bool has_undo_transaction() const;
  inline void clear_undo_transaction();
  static const int kUndoTransactionFieldNumber = 6;
  inline const ::TSWP::UndoTransaction& undo_transaction() const;
  inline ::TSWP::UndoTransaction* mutable_undo_transaction();
  inline ::TSWP::UndoTransaction* release_undo_transaction();
  inline void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);

  // @@protoc_insertion_point(class_scope:TSWP.MoveRowsCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_storage();
  inline void clear_has_storage();
  inline void set_has_src_index();
  inline void clear_has_src_index();
  inline void set_has_dst_index();
  inline void clear_has_dst_index();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_undo_transaction();
  inline void clear_has_undo_transaction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* storage_;
  ::google::protobuf::uint32 src_index_;
  ::google::protobuf::uint32 dst_index_;
  ::TSWP::UndoTransaction* undo_transaction_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static MoveRowsCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapeApplyPresetCommandArchive : public ::google::protobuf::Message {
 public:
  ShapeApplyPresetCommandArchive();
  virtual ~ShapeApplyPresetCommandArchive();

  ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from);

  inline ShapeApplyPresetCommandArchive& operator=(const ShapeApplyPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeApplyPresetCommandArchive& default_instance();

  void Swap(ShapeApplyPresetCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapeApplyPresetCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeApplyPresetCommandArchive& from);
  void MergeFrom(const ShapeApplyPresetCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.ShapeApplyPresetCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::ShapeApplyPresetCommandArchive& super() const;
  inline ::TSD::ShapeApplyPresetCommandArchive* mutable_super();
  inline ::TSD::ShapeApplyPresetCommandArchive* release_super();
  inline void set_allocated_super(::TSD::ShapeApplyPresetCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSWP.ShapeApplyPresetCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::ShapeApplyPresetCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapeApplyPresetCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class ShapePasteStyleCommandArchive : public ::google::protobuf::Message {
 public:
  ShapePasteStyleCommandArchive();
  virtual ~ShapePasteStyleCommandArchive();

  ShapePasteStyleCommandArchive(const ShapePasteStyleCommandArchive& from);

  inline ShapePasteStyleCommandArchive& operator=(const ShapePasteStyleCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapePasteStyleCommandArchive& default_instance();

  void Swap(ShapePasteStyleCommandArchive* other);

  // implements Message ----------------------------------------------

  ShapePasteStyleCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapePasteStyleCommandArchive& from);
  void MergeFrom(const ShapePasteStyleCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSD.PasteStyleCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSD::PasteStyleCommandArchive& super() const;
  inline ::TSD::PasteStyleCommandArchive* mutable_super();
  inline ::TSD::PasteStyleCommandArchive* release_super();
  inline void set_allocated_super(::TSD::PasteStyleCommandArchive* super);

  // optional .TSP.Reference paragraph_style = 2;
  inline bool has_paragraph_style() const;
  inline void clear_paragraph_style();
  static const int kParagraphStyleFieldNumber = 2;
  inline const ::TSP::Reference& paragraph_style() const;
  inline ::TSP::Reference* mutable_paragraph_style();
  inline ::TSP::Reference* release_paragraph_style();
  inline void set_allocated_paragraph_style(::TSP::Reference* paragraph_style);

  // optional .TSP.Reference list_style = 3;
  inline bool has_list_style() const;
  inline void clear_list_style();
  static const int kListStyleFieldNumber = 3;
  inline const ::TSP::Reference& list_style() const;
  inline ::TSP::Reference* mutable_list_style();
  inline ::TSP::Reference* release_list_style();
  inline void set_allocated_list_style(::TSP::Reference* list_style);

  // optional .TSP.Reference character_style = 4;
  inline bool has_character_style() const;
  inline void clear_character_style();
  static const int kCharacterStyleFieldNumber = 4;
  inline const ::TSP::Reference& character_style() const;
  inline ::TSP::Reference* mutable_character_style();
  inline ::TSP::Reference* release_character_style();
  inline void set_allocated_character_style(::TSP::Reference* character_style);

  // @@protoc_insertion_point(class_scope:TSWP.ShapePasteStyleCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_paragraph_style();
  inline void clear_has_paragraph_style();
  inline void set_has_list_style();
  inline void clear_has_list_style();
  inline void set_has_character_style();
  inline void clear_has_character_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSD::PasteStyleCommandArchive* super_;
  ::TSP::Reference* paragraph_style_;
  ::TSP::Reference* list_style_;
  ::TSP::Reference* character_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static ShapePasteStyleCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleBaseCommandArchive : public ::google::protobuf::Message {
 public:
  StyleBaseCommandArchive();
  virtual ~StyleBaseCommandArchive();

  StyleBaseCommandArchive(const StyleBaseCommandArchive& from);

  inline StyleBaseCommandArchive& operator=(const StyleBaseCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleBaseCommandArchive& default_instance();

  void Swap(StyleBaseCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleBaseCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleBaseCommandArchive& from);
  void MergeFrom(const StyleBaseCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSK.CommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSK::CommandArchive& super() const;
  inline ::TSK::CommandArchive* mutable_super();
  inline ::TSK::CommandArchive* release_super();
  inline void set_allocated_super(::TSK::CommandArchive* super);

  // optional .TSP.Reference theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::TSP::Reference& theme() const;
  inline ::TSP::Reference* mutable_theme();
  inline ::TSP::Reference* release_theme();
  inline void set_allocated_theme(::TSP::Reference* theme);

  // optional .TSP.Reference style = 3;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 3;
  inline const ::TSP::Reference& style() const;
  inline ::TSP::Reference* mutable_style();
  inline ::TSP::Reference* release_style();
  inline void set_allocated_style(::TSP::Reference* style);

  // @@protoc_insertion_point(class_scope:TSWP.StyleBaseCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_style();
  inline void clear_has_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSK::CommandArchive* super_;
  ::TSP::Reference* theme_;
  ::TSP::Reference* style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleBaseCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleCreateCommandArchive : public ::google::protobuf::Message {
 public:
  StyleCreateCommandArchive();
  virtual ~StyleCreateCommandArchive();

  StyleCreateCommandArchive(const StyleCreateCommandArchive& from);

  inline StyleCreateCommandArchive& operator=(const StyleCreateCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleCreateCommandArchive& default_instance();

  void Swap(StyleCreateCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleCreateCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleCreateCommandArchive& from);
  void MergeFrom(const StyleCreateCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::StyleBaseCommandArchive& super() const;
  inline ::TSWP::StyleBaseCommandArchive* mutable_super();
  inline ::TSWP::StyleBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);

  // optional uint32 preset_index = 2;
  inline bool has_preset_index() const;
  inline void clear_preset_index();
  static const int kPresetIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 preset_index() const;
  inline void set_preset_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.StyleCreateCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_preset_index();
  inline void clear_has_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::StyleBaseCommandArchive* super_;
  ::google::protobuf::uint32 preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleCreateCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleRenameCommandArchive : public ::google::protobuf::Message {
 public:
  StyleRenameCommandArchive();
  virtual ~StyleRenameCommandArchive();

  StyleRenameCommandArchive(const StyleRenameCommandArchive& from);

  inline StyleRenameCommandArchive& operator=(const StyleRenameCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleRenameCommandArchive& default_instance();

  void Swap(StyleRenameCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleRenameCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleRenameCommandArchive& from);
  void MergeFrom(const StyleRenameCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::StyleBaseCommandArchive& super() const;
  inline ::TSWP::StyleBaseCommandArchive* mutable_super();
  inline ::TSWP::StyleBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);

  // optional string updated_name = 2;
  inline bool has_updated_name() const;
  inline void clear_updated_name();
  static const int kUpdatedNameFieldNumber = 2;
  inline const ::std::string& updated_name() const;
  inline void set_updated_name(const ::std::string& value);
  inline void set_updated_name(const char* value);
  inline void set_updated_name(const char* value, size_t size);
  inline ::std::string* mutable_updated_name();
  inline ::std::string* release_updated_name();
  inline void set_allocated_updated_name(::std::string* updated_name);

  // optional string old_name = 3;
  inline bool has_old_name() const;
  inline void clear_old_name();
  static const int kOldNameFieldNumber = 3;
  inline const ::std::string& old_name() const;
  inline void set_old_name(const ::std::string& value);
  inline void set_old_name(const char* value);
  inline void set_old_name(const char* value, size_t size);
  inline ::std::string* mutable_old_name();
  inline ::std::string* release_old_name();
  inline void set_allocated_old_name(::std::string* old_name);

  // @@protoc_insertion_point(class_scope:TSWP.StyleRenameCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_updated_name();
  inline void clear_has_updated_name();
  inline void set_has_old_name();
  inline void clear_has_old_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::StyleBaseCommandArchive* super_;
  ::std::string* updated_name_;
  ::std::string* old_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleRenameCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleUpdateCommandArchive : public ::google::protobuf::Message {
 public:
  StyleUpdateCommandArchive();
  virtual ~StyleUpdateCommandArchive();

  StyleUpdateCommandArchive(const StyleUpdateCommandArchive& from);

  inline StyleUpdateCommandArchive& operator=(const StyleUpdateCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleUpdateCommandArchive& default_instance();

  void Swap(StyleUpdateCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleUpdateCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleUpdateCommandArchive& from);
  void MergeFrom(const StyleUpdateCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::StyleBaseCommandArchive& super() const;
  inline ::TSWP::StyleBaseCommandArchive* mutable_super();
  inline ::TSWP::StyleBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);

  // optional .TSP.Reference original_style = 2;
  inline bool has_original_style() const;
  inline void clear_original_style();
  static const int kOriginalStyleFieldNumber = 2;
  inline const ::TSP::Reference& original_style() const;
  inline ::TSP::Reference* mutable_original_style();
  inline ::TSP::Reference* release_original_style();
  inline void set_allocated_original_style(::TSP::Reference* original_style);

  // optional .TSP.Reference updated_style = 3;
  inline bool has_updated_style() const;
  inline void clear_updated_style();
  static const int kUpdatedStyleFieldNumber = 3;
  inline const ::TSP::Reference& updated_style() const;
  inline ::TSP::Reference* mutable_updated_style();
  inline ::TSP::Reference* release_updated_style();
  inline void set_allocated_updated_style(::TSP::Reference* updated_style);

  // @@protoc_insertion_point(class_scope:TSWP.StyleUpdateCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_original_style();
  inline void clear_has_original_style();
  inline void set_has_updated_style();
  inline void clear_has_updated_style();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::StyleBaseCommandArchive* super_;
  ::TSP::Reference* original_style_;
  ::TSP::Reference* updated_style_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleUpdateCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleDeleteCommandArchive : public ::google::protobuf::Message {
 public:
  StyleDeleteCommandArchive();
  virtual ~StyleDeleteCommandArchive();

  StyleDeleteCommandArchive(const StyleDeleteCommandArchive& from);

  inline StyleDeleteCommandArchive& operator=(const StyleDeleteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleDeleteCommandArchive& default_instance();

  void Swap(StyleDeleteCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleDeleteCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleDeleteCommandArchive& from);
  void MergeFrom(const StyleDeleteCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::StyleBaseCommandArchive& super() const;
  inline ::TSWP::StyleBaseCommandArchive* mutable_super();
  inline ::TSWP::StyleBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);

  // optional uint32 old_preset_index = 2;
  inline bool has_old_preset_index() const;
  inline void clear_old_preset_index();
  static const int kOldPresetIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 old_preset_index() const;
  inline void set_old_preset_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.StyleDeleteCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_preset_index();
  inline void clear_has_old_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::StyleBaseCommandArchive* super_;
  ::google::protobuf::uint32 old_preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleDeleteCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleReorderCommandArchive : public ::google::protobuf::Message {
 public:
  StyleReorderCommandArchive();
  virtual ~StyleReorderCommandArchive();

  StyleReorderCommandArchive(const StyleReorderCommandArchive& from);

  inline StyleReorderCommandArchive& operator=(const StyleReorderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleReorderCommandArchive& default_instance();

  void Swap(StyleReorderCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleReorderCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleReorderCommandArchive& from);
  void MergeFrom(const StyleReorderCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TSWP.StyleBaseCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSWP::StyleBaseCommandArchive& super() const;
  inline ::TSWP::StyleBaseCommandArchive* mutable_super();
  inline ::TSWP::StyleBaseCommandArchive* release_super();
  inline void set_allocated_super(::TSWP::StyleBaseCommandArchive* super);

  // optional uint32 old_preset_index = 2;
  inline bool has_old_preset_index() const;
  inline void clear_old_preset_index();
  static const int kOldPresetIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 old_preset_index() const;
  inline void set_old_preset_index(::google::protobuf::uint32 value);

  // optional uint32 new_preset_index = 3;
  inline bool has_new_preset_index() const;
  inline void clear_new_preset_index();
  static const int kNewPresetIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 new_preset_index() const;
  inline void set_new_preset_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TSWP.StyleReorderCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();
  inline void set_has_old_preset_index();
  inline void clear_has_old_preset_index();
  inline void set_has_new_preset_index();
  inline void clear_has_new_preset_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSWP::StyleBaseCommandArchive* super_;
  ::google::protobuf::uint32 old_preset_index_;
  ::google::protobuf::uint32 new_preset_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleReorderCommandArchive* default_instance_;
};
// -------------------------------------------------------------------

class StyleUpdatePropertyMapCommandArchive : public ::google::protobuf::Message {
 public:
  StyleUpdatePropertyMapCommandArchive();
  virtual ~StyleUpdatePropertyMapCommandArchive();

  StyleUpdatePropertyMapCommandArchive(const StyleUpdatePropertyMapCommandArchive& from);

  inline StyleUpdatePropertyMapCommandArchive& operator=(const StyleUpdatePropertyMapCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StyleUpdatePropertyMapCommandArchive& default_instance();

  void Swap(StyleUpdatePropertyMapCommandArchive* other);

  // implements Message ----------------------------------------------

  StyleUpdatePropertyMapCommandArchive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StyleUpdatePropertyMapCommandArchive& from);
  void MergeFrom(const StyleUpdatePropertyMapCommandArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 1;
  inline const ::TSS::StyleUpdatePropertyMapCommandArchive& super() const;
  inline ::TSS::StyleUpdatePropertyMapCommandArchive* mutable_super();
  inline ::TSS::StyleUpdatePropertyMapCommandArchive* release_super();
  inline void set_allocated_super(::TSS::StyleUpdatePropertyMapCommandArchive* super);

  // @@protoc_insertion_point(class_scope:TSWP.StyleUpdatePropertyMapCommandArchive)
 private:
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TSS::StyleUpdatePropertyMapCommandArchive* super_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_AssignDesc_TSWPCommandArchives_2eproto();
  friend void protobuf_ShutdownFile_TSWPCommandArchives_2eproto();

  void InitAsDefaultInstance();
  static StyleUpdatePropertyMapCommandArchive* default_instance_;
};
// ===================================================================


// ===================================================================

// DummyCommandArchive

// required uint32 foo = 1;
inline bool DummyCommandArchive::has_foo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DummyCommandArchive::set_has_foo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DummyCommandArchive::clear_has_foo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DummyCommandArchive::clear_foo() {
  foo_ = 0u;
  clear_has_foo();
}
inline ::google::protobuf::uint32 DummyCommandArchive::foo() const {
  return foo_;
}
inline void DummyCommandArchive::set_foo(::google::protobuf::uint32 value) {
  set_has_foo();
  foo_ = value;
}

// -------------------------------------------------------------------

// TextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool TextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& TextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* TextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* TextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool TextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& TextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* TextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* TextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void TextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool TextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& TextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void TextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional uint32 restore_range_location = 4;
inline bool TextCommandArchive::has_restore_range_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextCommandArchive::set_has_restore_range_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextCommandArchive::clear_has_restore_range_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextCommandArchive::clear_restore_range_location() {
  restore_range_location_ = 0u;
  clear_has_restore_range_location();
}
inline ::google::protobuf::uint32 TextCommandArchive::restore_range_location() const {
  return restore_range_location_;
}
inline void TextCommandArchive::set_restore_range_location(::google::protobuf::uint32 value) {
  set_has_restore_range_location();
  restore_range_location_ = value;
}

// optional uint32 restore_range_length = 5;
inline bool TextCommandArchive::has_restore_range_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextCommandArchive::set_has_restore_range_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextCommandArchive::clear_has_restore_range_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextCommandArchive::clear_restore_range_length() {
  restore_range_length_ = 0u;
  clear_has_restore_range_length();
}
inline ::google::protobuf::uint32 TextCommandArchive::restore_range_length() const {
  return restore_range_length_;
}
inline void TextCommandArchive::set_restore_range_length(::google::protobuf::uint32 value) {
  set_has_restore_range_length();
  restore_range_length_ = value;
}

// optional uint32 redo_restore_range_location = 6;
inline bool TextCommandArchive::has_redo_restore_range_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextCommandArchive::set_has_redo_restore_range_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextCommandArchive::clear_has_redo_restore_range_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextCommandArchive::clear_redo_restore_range_location() {
  redo_restore_range_location_ = 0u;
  clear_has_redo_restore_range_location();
}
inline ::google::protobuf::uint32 TextCommandArchive::redo_restore_range_location() const {
  return redo_restore_range_location_;
}
inline void TextCommandArchive::set_redo_restore_range_location(::google::protobuf::uint32 value) {
  set_has_redo_restore_range_location();
  redo_restore_range_location_ = value;
}

// optional uint32 redo_restore_range_length = 7;
inline bool TextCommandArchive::has_redo_restore_range_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextCommandArchive::set_has_redo_restore_range_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextCommandArchive::clear_has_redo_restore_range_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextCommandArchive::clear_redo_restore_range_length() {
  redo_restore_range_length_ = 0u;
  clear_has_redo_restore_range_length();
}
inline ::google::protobuf::uint32 TextCommandArchive::redo_restore_range_length() const {
  return redo_restore_range_length_;
}
inline void TextCommandArchive::set_redo_restore_range_length(::google::protobuf::uint32 value) {
  set_has_redo_restore_range_length();
  redo_restore_range_length_ = value;
}

// optional uint32 text_command_flags = 9;
inline bool TextCommandArchive::has_text_command_flags() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextCommandArchive::set_has_text_command_flags() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextCommandArchive::clear_has_text_command_flags() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextCommandArchive::clear_text_command_flags() {
  text_command_flags_ = 0u;
  clear_has_text_command_flags();
}
inline ::google::protobuf::uint32 TextCommandArchive::text_command_flags() const {
  return text_command_flags_;
}
inline void TextCommandArchive::set_text_command_flags(::google::protobuf::uint32 value) {
  set_has_text_command_flags();
  text_command_flags_ = value;
}

// optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
inline bool TextCommandArchive::has_kind() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextCommandArchive::set_has_kind() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextCommandArchive::clear_has_kind() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextCommandArchive::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::TSWP::TextCommandArchive_Kind TextCommandArchive::kind() const {
  return static_cast< ::TSWP::TextCommandArchive_Kind >(kind_);
}
inline void TextCommandArchive::set_kind(::TSWP::TextCommandArchive_Kind value) {
  assert(::TSWP::TextCommandArchive_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
}

// -------------------------------------------------------------------

// ReplaceAllTextCommandArchive

// optional .TSK.ReplaceAllChildCommandArchive super = 1;
inline bool ReplaceAllTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceAllTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceAllTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceAllTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::ReplaceAllChildCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::ReplaceAllChildCommandArchive& ReplaceAllTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::ReplaceAllChildCommandArchive;
  return super_;
}
inline ::TSK::ReplaceAllChildCommandArchive* ReplaceAllTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::ReplaceAllChildCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReplaceAllTextCommandArchive::set_allocated_super(::TSK::ReplaceAllChildCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool ReplaceAllTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplaceAllTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplaceAllTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplaceAllTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& ReplaceAllTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* ReplaceAllTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void ReplaceAllTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ReplaceAllTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplaceAllTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplaceAllTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplaceAllTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ReplaceAllTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ReplaceAllTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// FormatTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool FormatTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormatTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormatTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormatTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& FormatTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* FormatTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void FormatTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool FormatTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FormatTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FormatTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FormatTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& FormatTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* FormatTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* FormatTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void FormatTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool FormatTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FormatTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FormatTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FormatTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& FormatTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* FormatTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void FormatTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional uint32 selection_range_location = 8;
inline bool FormatTextCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FormatTextCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FormatTextCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FormatTextCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 FormatTextCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void FormatTextCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 9;
inline bool FormatTextCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FormatTextCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FormatTextCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FormatTextCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 FormatTextCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void FormatTextCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional uint32 text_command_flags = 11;
inline bool FormatTextCommandArchive::has_text_command_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FormatTextCommandArchive::set_has_text_command_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FormatTextCommandArchive::clear_has_text_command_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FormatTextCommandArchive::clear_text_command_flags() {
  text_command_flags_ = 0u;
  clear_has_text_command_flags();
}
inline ::google::protobuf::uint32 FormatTextCommandArchive::text_command_flags() const {
  return text_command_flags_;
}
inline void FormatTextCommandArchive::set_text_command_flags(::google::protobuf::uint32 value) {
  set_has_text_command_flags();
  text_command_flags_ = value;
}

// -------------------------------------------------------------------

// SetColumnStyleCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool SetColumnStyleCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetColumnStyleCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetColumnStyleCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetColumnStyleCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& SetColumnStyleCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* SetColumnStyleCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void SetColumnStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool SetColumnStyleCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetColumnStyleCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetColumnStyleCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetColumnStyleCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& SetColumnStyleCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* SetColumnStyleCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void SetColumnStyleCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool SetColumnStyleCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetColumnStyleCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetColumnStyleCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetColumnStyleCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& SetColumnStyleCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* SetColumnStyleCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void SetColumnStyleCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ReplaceAllUsesOfStyleCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ReplaceAllUsesOfStyleCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ReplaceAllUsesOfStyleCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ReplaceAllUsesOfStyleCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool ReplaceAllUsesOfStyleCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& ReplaceAllUsesOfStyleCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* ReplaceAllUsesOfStyleCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ReplaceAllUsesOfStyleCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplaceAllUsesOfStyleCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ReplaceAllUsesOfStyleCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ReplaceAllUsesOfStyleCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ReplaceAllUsesOfStyleCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// InsertAttachmentCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertAttachmentCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertAttachmentCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertAttachmentCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InsertAttachmentCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InsertAttachmentCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertAttachmentCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool InsertAttachmentCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertAttachmentCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertAttachmentCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void InsertAttachmentCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool InsertAttachmentCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertAttachmentCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertAttachmentCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 InsertAttachmentCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void InsertAttachmentCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool InsertAttachmentCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsertAttachmentCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsertAttachmentCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 InsertAttachmentCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void InsertAttachmentCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional .TSP.Reference attachment = 5;
inline bool InsertAttachmentCommandArchive::has_attachment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_attachment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertAttachmentCommandArchive::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertAttachmentCommandArchive::clear_attachment() {
  if (attachment_ != NULL) attachment_->::TSP::Reference::Clear();
  clear_has_attachment();
}
inline const ::TSP::Reference& InsertAttachmentCommandArchive::attachment() const {
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::TSP::Reference;
  return attachment_;
}
inline ::TSP::Reference* InsertAttachmentCommandArchive::release_attachment() {
  clear_has_attachment();
  ::TSP::Reference* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void InsertAttachmentCommandArchive::set_allocated_attachment(::TSP::Reference* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool InsertAttachmentCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InsertAttachmentCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InsertAttachmentCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertAttachmentCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertAttachmentCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void InsertAttachmentCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional uint32 text_command_flags = 7;
inline bool InsertAttachmentCommandArchive::has_text_command_flags() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_text_command_flags() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InsertAttachmentCommandArchive::clear_has_text_command_flags() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InsertAttachmentCommandArchive::clear_text_command_flags() {
  text_command_flags_ = 0u;
  clear_has_text_command_flags();
}
inline ::google::protobuf::uint32 InsertAttachmentCommandArchive::text_command_flags() const {
  return text_command_flags_;
}
inline void InsertAttachmentCommandArchive::set_text_command_flags(::google::protobuf::uint32 value) {
  set_has_text_command_flags();
  text_command_flags_ = value;
}

// optional uint32 redo_restore_range_location = 8;
inline bool InsertAttachmentCommandArchive::has_redo_restore_range_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_redo_restore_range_location() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InsertAttachmentCommandArchive::clear_has_redo_restore_range_location() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InsertAttachmentCommandArchive::clear_redo_restore_range_location() {
  redo_restore_range_location_ = 0u;
  clear_has_redo_restore_range_location();
}
inline ::google::protobuf::uint32 InsertAttachmentCommandArchive::redo_restore_range_location() const {
  return redo_restore_range_location_;
}
inline void InsertAttachmentCommandArchive::set_redo_restore_range_location(::google::protobuf::uint32 value) {
  set_has_redo_restore_range_location();
  redo_restore_range_location_ = value;
}

// optional uint32 redo_restore_range_length = 9;
inline bool InsertAttachmentCommandArchive::has_redo_restore_range_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InsertAttachmentCommandArchive::set_has_redo_restore_range_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InsertAttachmentCommandArchive::clear_has_redo_restore_range_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InsertAttachmentCommandArchive::clear_redo_restore_range_length() {
  redo_restore_range_length_ = 0u;
  clear_has_redo_restore_range_length();
}
inline ::google::protobuf::uint32 InsertAttachmentCommandArchive::redo_restore_range_length() const {
  return redo_restore_range_length_;
}
inline void InsertAttachmentCommandArchive::set_redo_restore_range_length(::google::protobuf::uint32 value) {
  set_has_redo_restore_range_length();
  redo_restore_range_length_ = value;
}

// -------------------------------------------------------------------

// InsertColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertColumnsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertColumnsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertColumnsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertColumnsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InsertColumnsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InsertColumnsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool InsertColumnsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertColumnsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertColumnsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertColumnsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& InsertColumnsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* InsertColumnsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* InsertColumnsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void InsertColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 column_index = 3;
inline bool InsertColumnsCommandArchive::has_column_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertColumnsCommandArchive::set_has_column_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertColumnsCommandArchive::clear_has_column_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertColumnsCommandArchive::clear_column_index() {
  column_index_ = 0u;
  clear_has_column_index();
}
inline ::google::protobuf::uint32 InsertColumnsCommandArchive::column_index() const {
  return column_index_;
}
inline void InsertColumnsCommandArchive::set_column_index(::google::protobuf::uint32 value) {
  set_has_column_index();
  column_index_ = value;
}

// optional uint32 column_count = 4;
inline bool InsertColumnsCommandArchive::has_column_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsertColumnsCommandArchive::set_has_column_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsertColumnsCommandArchive::clear_has_column_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsertColumnsCommandArchive::clear_column_count() {
  column_count_ = 0u;
  clear_has_column_count();
}
inline ::google::protobuf::uint32 InsertColumnsCommandArchive::column_count() const {
  return column_count_;
}
inline void InsertColumnsCommandArchive::set_column_count(::google::protobuf::uint32 value) {
  set_has_column_count();
  column_count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool InsertColumnsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertColumnsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertColumnsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertColumnsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertColumnsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertColumnsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void InsertColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// InsertRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool InsertRowsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertRowsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertRowsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertRowsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& InsertRowsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* InsertRowsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void InsertRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool InsertRowsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertRowsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertRowsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertRowsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& InsertRowsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* InsertRowsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* InsertRowsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void InsertRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 row_index = 3;
inline bool InsertRowsCommandArchive::has_row_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertRowsCommandArchive::set_has_row_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertRowsCommandArchive::clear_has_row_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertRowsCommandArchive::clear_row_index() {
  row_index_ = 0u;
  clear_has_row_index();
}
inline ::google::protobuf::uint32 InsertRowsCommandArchive::row_index() const {
  return row_index_;
}
inline void InsertRowsCommandArchive::set_row_index(::google::protobuf::uint32 value) {
  set_has_row_index();
  row_index_ = value;
}

// optional uint32 row_count = 4;
inline bool InsertRowsCommandArchive::has_row_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsertRowsCommandArchive::set_has_row_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsertRowsCommandArchive::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsertRowsCommandArchive::clear_row_count() {
  row_count_ = 0u;
  clear_has_row_count();
}
inline ::google::protobuf::uint32 InsertRowsCommandArchive::row_count() const {
  return row_count_;
}
inline void InsertRowsCommandArchive::set_row_count(::google::protobuf::uint32 value) {
  set_has_row_count();
  row_count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool InsertRowsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertRowsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertRowsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertRowsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& InsertRowsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* InsertRowsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void InsertRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// RemoveColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveColumnsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveColumnsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveColumnsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveColumnsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveColumnsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveColumnsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool RemoveColumnsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveColumnsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveColumnsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveColumnsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& RemoveColumnsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* RemoveColumnsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void RemoveColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 column_index = 3;
inline bool RemoveColumnsCommandArchive::has_column_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveColumnsCommandArchive::set_has_column_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveColumnsCommandArchive::clear_has_column_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveColumnsCommandArchive::clear_column_index() {
  column_index_ = 0u;
  clear_has_column_index();
}
inline ::google::protobuf::uint32 RemoveColumnsCommandArchive::column_index() const {
  return column_index_;
}
inline void RemoveColumnsCommandArchive::set_column_index(::google::protobuf::uint32 value) {
  set_has_column_index();
  column_index_ = value;
}

// optional uint32 column_count = 4;
inline bool RemoveColumnsCommandArchive::has_column_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveColumnsCommandArchive::set_has_column_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveColumnsCommandArchive::clear_has_column_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveColumnsCommandArchive::clear_column_count() {
  column_count_ = 0u;
  clear_has_column_count();
}
inline ::google::protobuf::uint32 RemoveColumnsCommandArchive::column_count() const {
  return column_count_;
}
inline void RemoveColumnsCommandArchive::set_column_count(::google::protobuf::uint32 value) {
  set_has_column_count();
  column_count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveColumnsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveColumnsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveColumnsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveColumnsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveColumnsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveColumnsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void RemoveColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// RemoveRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveRowsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveRowsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveRowsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveRowsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveRowsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveRowsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool RemoveRowsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveRowsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveRowsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveRowsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& RemoveRowsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* RemoveRowsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* RemoveRowsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void RemoveRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 row_index = 3;
inline bool RemoveRowsCommandArchive::has_row_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveRowsCommandArchive::set_has_row_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveRowsCommandArchive::clear_has_row_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveRowsCommandArchive::clear_row_index() {
  row_index_ = 0u;
  clear_has_row_index();
}
inline ::google::protobuf::uint32 RemoveRowsCommandArchive::row_index() const {
  return row_index_;
}
inline void RemoveRowsCommandArchive::set_row_index(::google::protobuf::uint32 value) {
  set_has_row_index();
  row_index_ = value;
}

// optional uint32 row_count = 4;
inline bool RemoveRowsCommandArchive::has_row_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveRowsCommandArchive::set_has_row_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveRowsCommandArchive::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveRowsCommandArchive::clear_row_count() {
  row_count_ = 0u;
  clear_has_row_count();
}
inline ::google::protobuf::uint32 RemoveRowsCommandArchive::row_count() const {
  return row_count_;
}
inline void RemoveRowsCommandArchive::set_row_count(::google::protobuf::uint32 value) {
  set_has_row_count();
  row_count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveRowsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveRowsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveRowsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveRowsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveRowsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRowsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void RemoveRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// MergeCellsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MergeCellsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MergeCellsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MergeCellsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MergeCellsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MergeCellsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MergeCellsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MergeCellsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool MergeCellsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MergeCellsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MergeCellsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MergeCellsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& MergeCellsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* MergeCellsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* MergeCellsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void MergeCellsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 row = 3;
inline bool MergeCellsCommandArchive::has_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MergeCellsCommandArchive::set_has_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MergeCellsCommandArchive::clear_has_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MergeCellsCommandArchive::clear_row() {
  row_ = 0u;
  clear_has_row();
}
inline ::google::protobuf::uint32 MergeCellsCommandArchive::row() const {
  return row_;
}
inline void MergeCellsCommandArchive::set_row(::google::protobuf::uint32 value) {
  set_has_row();
  row_ = value;
}

// optional uint32 column = 4;
inline bool MergeCellsCommandArchive::has_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MergeCellsCommandArchive::set_has_column() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MergeCellsCommandArchive::clear_has_column() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MergeCellsCommandArchive::clear_column() {
  column_ = 0u;
  clear_has_column();
}
inline ::google::protobuf::uint32 MergeCellsCommandArchive::column() const {
  return column_;
}
inline void MergeCellsCommandArchive::set_column(::google::protobuf::uint32 value) {
  set_has_column();
  column_ = value;
}

// optional uint32 row_count = 5;
inline bool MergeCellsCommandArchive::has_row_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MergeCellsCommandArchive::set_has_row_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MergeCellsCommandArchive::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MergeCellsCommandArchive::clear_row_count() {
  row_count_ = 0u;
  clear_has_row_count();
}
inline ::google::protobuf::uint32 MergeCellsCommandArchive::row_count() const {
  return row_count_;
}
inline void MergeCellsCommandArchive::set_row_count(::google::protobuf::uint32 value) {
  set_has_row_count();
  row_count_ = value;
}

// optional uint32 column_count = 6;
inline bool MergeCellsCommandArchive::has_column_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MergeCellsCommandArchive::set_has_column_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MergeCellsCommandArchive::clear_has_column_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MergeCellsCommandArchive::clear_column_count() {
  column_count_ = 0u;
  clear_has_column_count();
}
inline ::google::protobuf::uint32 MergeCellsCommandArchive::column_count() const {
  return column_count_;
}
inline void MergeCellsCommandArchive::set_column_count(::google::protobuf::uint32 value) {
  set_has_column_count();
  column_count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 7;
inline bool MergeCellsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MergeCellsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MergeCellsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MergeCellsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MergeCellsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* MergeCellsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void MergeCellsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ApplyPlaceholderTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyPlaceholderTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyPlaceholderTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ApplyPlaceholderTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ApplyPlaceholderTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool ApplyPlaceholderTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyPlaceholderTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& ApplyPlaceholderTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* ApplyPlaceholderTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool ApplyPlaceholderTextCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyPlaceholderTextCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 ApplyPlaceholderTextCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void ApplyPlaceholderTextCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool ApplyPlaceholderTextCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyPlaceholderTextCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 ApplyPlaceholderTextCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void ApplyPlaceholderTextCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ApplyPlaceholderTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyPlaceholderTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyPlaceholderTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyPlaceholderTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyPlaceholderTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ApplyPlaceholderTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ApplyHighlightTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyHighlightTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyHighlightTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ApplyHighlightTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ApplyHighlightTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool ApplyHighlightTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyHighlightTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& ApplyHighlightTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* ApplyHighlightTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool ApplyHighlightTextCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyHighlightTextCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 ApplyHighlightTextCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void ApplyHighlightTextCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool ApplyHighlightTextCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyHighlightTextCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 ApplyHighlightTextCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void ApplyHighlightTextCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ApplyHighlightTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyHighlightTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyHighlightTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyHighlightTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ApplyHighlightTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional bool remove = 6;
inline bool ApplyHighlightTextCommandArchive::has_remove() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplyHighlightTextCommandArchive::set_has_remove() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplyHighlightTextCommandArchive::clear_has_remove() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplyHighlightTextCommandArchive::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
inline bool ApplyHighlightTextCommandArchive::remove() const {
  return remove_;
}
inline void ApplyHighlightTextCommandArchive::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
}

// -------------------------------------------------------------------

// CreateHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool CreateHyperlinkCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateHyperlinkCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateHyperlinkCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& CreateHyperlinkCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* CreateHyperlinkCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void CreateHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool CreateHyperlinkCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateHyperlinkCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateHyperlinkCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& CreateHyperlinkCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* CreateHyperlinkCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void CreateHyperlinkCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool CreateHyperlinkCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateHyperlinkCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateHyperlinkCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 CreateHyperlinkCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void CreateHyperlinkCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool CreateHyperlinkCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateHyperlinkCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateHyperlinkCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 CreateHyperlinkCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void CreateHyperlinkCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional string url_ref = 5;
inline bool CreateHyperlinkCommandArchive::has_url_ref() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_url_ref() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateHyperlinkCommandArchive::clear_has_url_ref() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateHyperlinkCommandArchive::clear_url_ref() {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    url_ref_->clear();
  }
  clear_has_url_ref();
}
inline const ::std::string& CreateHyperlinkCommandArchive::url_ref() const {
  return *url_ref_;
}
inline void CreateHyperlinkCommandArchive::set_url_ref(const ::std::string& value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void CreateHyperlinkCommandArchive::set_url_ref(const char* value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void CreateHyperlinkCommandArchive::set_url_ref(const char* value, size_t size) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateHyperlinkCommandArchive::mutable_url_ref() {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  return url_ref_;
}
inline ::std::string* CreateHyperlinkCommandArchive::release_url_ref() {
  clear_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_ref_;
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateHyperlinkCommandArchive::set_allocated_url_ref(::std::string* url_ref) {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete url_ref_;
  }
  if (url_ref) {
    set_has_url_ref();
    url_ref_ = url_ref;
  } else {
    clear_has_url_ref();
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool CreateHyperlinkCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateHyperlinkCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateHyperlinkCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateHyperlinkCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& CreateHyperlinkCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* CreateHyperlinkCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void CreateHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// RemoveHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveHyperlinkCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveHyperlinkCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveHyperlinkCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveHyperlinkCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool RemoveHyperlinkCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveHyperlinkCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& RemoveHyperlinkCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* RemoveHyperlinkCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool RemoveHyperlinkCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveHyperlinkCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 RemoveHyperlinkCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void RemoveHyperlinkCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool RemoveHyperlinkCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveHyperlinkCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 RemoveHyperlinkCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void RemoveHyperlinkCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveHyperlinkCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveHyperlinkCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveHyperlinkCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveHyperlinkCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void RemoveHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional bool is_remove_character_style = 6 [default = true];
inline bool RemoveHyperlinkCommandArchive::has_is_remove_character_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RemoveHyperlinkCommandArchive::set_has_is_remove_character_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RemoveHyperlinkCommandArchive::clear_has_is_remove_character_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RemoveHyperlinkCommandArchive::clear_is_remove_character_style() {
  is_remove_character_style_ = true;
  clear_has_is_remove_character_style();
}
inline bool RemoveHyperlinkCommandArchive::is_remove_character_style() const {
  return is_remove_character_style_;
}
inline void RemoveHyperlinkCommandArchive::set_is_remove_character_style(bool value) {
  set_has_is_remove_character_style();
  is_remove_character_style_ = value;
}

// -------------------------------------------------------------------

// ModifyHyperlinkCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyHyperlinkCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyHyperlinkCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyHyperlinkCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyHyperlinkCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ModifyHyperlinkCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ModifyHyperlinkCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference hyperlink = 2;
inline bool ModifyHyperlinkCommandArchive::has_hyperlink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyHyperlinkCommandArchive::set_has_hyperlink() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyHyperlinkCommandArchive::clear_has_hyperlink() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyHyperlinkCommandArchive::clear_hyperlink() {
  if (hyperlink_ != NULL) hyperlink_->::TSP::Reference::Clear();
  clear_has_hyperlink();
}
inline const ::TSP::Reference& ModifyHyperlinkCommandArchive::hyperlink() const {
  return hyperlink_ != NULL ? *hyperlink_ : *default_instance_->hyperlink_;
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::mutable_hyperlink() {
  set_has_hyperlink();
  if (hyperlink_ == NULL) hyperlink_ = new ::TSP::Reference;
  return hyperlink_;
}
inline ::TSP::Reference* ModifyHyperlinkCommandArchive::release_hyperlink() {
  clear_has_hyperlink();
  ::TSP::Reference* temp = hyperlink_;
  hyperlink_ = NULL;
  return temp;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_hyperlink(::TSP::Reference* hyperlink) {
  delete hyperlink_;
  hyperlink_ = hyperlink;
  if (hyperlink) {
    set_has_hyperlink();
  } else {
    clear_has_hyperlink();
  }
}

// optional string display_text = 3;
inline bool ModifyHyperlinkCommandArchive::has_display_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyHyperlinkCommandArchive::set_has_display_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyHyperlinkCommandArchive::clear_has_display_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyHyperlinkCommandArchive::clear_display_text() {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    display_text_->clear();
  }
  clear_has_display_text();
}
inline const ::std::string& ModifyHyperlinkCommandArchive::display_text() const {
  return *display_text_;
}
inline void ModifyHyperlinkCommandArchive::set_display_text(const ::std::string& value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void ModifyHyperlinkCommandArchive::set_display_text(const char* value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void ModifyHyperlinkCommandArchive::set_display_text(const char* value, size_t size) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyHyperlinkCommandArchive::mutable_display_text() {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  return display_text_;
}
inline ::std::string* ModifyHyperlinkCommandArchive::release_display_text() {
  clear_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_text_;
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyHyperlinkCommandArchive::set_allocated_display_text(::std::string* display_text) {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    delete display_text_;
  }
  if (display_text) {
    set_has_display_text();
    display_text_ = display_text;
  } else {
    clear_has_display_text();
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url_ref = 4;
inline bool ModifyHyperlinkCommandArchive::has_url_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyHyperlinkCommandArchive::set_has_url_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyHyperlinkCommandArchive::clear_has_url_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyHyperlinkCommandArchive::clear_url_ref() {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    url_ref_->clear();
  }
  clear_has_url_ref();
}
inline const ::std::string& ModifyHyperlinkCommandArchive::url_ref() const {
  return *url_ref_;
}
inline void ModifyHyperlinkCommandArchive::set_url_ref(const ::std::string& value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void ModifyHyperlinkCommandArchive::set_url_ref(const char* value) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(value);
}
inline void ModifyHyperlinkCommandArchive::set_url_ref(const char* value, size_t size) {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  url_ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyHyperlinkCommandArchive::mutable_url_ref() {
  set_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    url_ref_ = new ::std::string;
  }
  return url_ref_;
}
inline ::std::string* ModifyHyperlinkCommandArchive::release_url_ref() {
  clear_has_url_ref();
  if (url_ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_ref_;
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyHyperlinkCommandArchive::set_allocated_url_ref(::std::string* url_ref) {
  if (url_ref_ != &::google::protobuf::internal::kEmptyString) {
    delete url_ref_;
  }
  if (url_ref) {
    set_has_url_ref();
    url_ref_ = url_ref;
  } else {
    clear_has_url_ref();
    url_ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ModifyHyperlinkCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyHyperlinkCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyHyperlinkCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyHyperlinkCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ModifyHyperlinkCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyHyperlinkCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ModifyHyperlinkCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// UpdateDateTimeFieldCommandArchive

// optional .TSWP.TextCommandArchive super = 1;
inline bool UpdateDateTimeFieldCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateDateTimeFieldCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::TextCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::TextCommandArchive& UpdateDateTimeFieldCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::TextCommandArchive;
  return super_;
}
inline ::TSWP::TextCommandArchive* UpdateDateTimeFieldCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::TextCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference date_time_field = 2;
inline bool UpdateDateTimeFieldCommandArchive::has_date_time_field() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateDateTimeFieldCommandArchive::set_has_date_time_field() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_has_date_time_field() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_date_time_field() {
  if (date_time_field_ != NULL) date_time_field_->::TSP::Reference::Clear();
  clear_has_date_time_field();
}
inline const ::TSP::Reference& UpdateDateTimeFieldCommandArchive::date_time_field() const {
  return date_time_field_ != NULL ? *date_time_field_ : *default_instance_->date_time_field_;
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::mutable_date_time_field() {
  set_has_date_time_field();
  if (date_time_field_ == NULL) date_time_field_ = new ::TSP::Reference;
  return date_time_field_;
}
inline ::TSP::Reference* UpdateDateTimeFieldCommandArchive::release_date_time_field() {
  clear_has_date_time_field();
  ::TSP::Reference* temp = date_time_field_;
  date_time_field_ = NULL;
  return temp;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_date_time_field(::TSP::Reference* date_time_field) {
  delete date_time_field_;
  date_time_field_ = date_time_field;
  if (date_time_field) {
    set_has_date_time_field();
  } else {
    clear_has_date_time_field();
  }
}

// optional .TSP.Date date = 3;
inline bool UpdateDateTimeFieldCommandArchive::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateDateTimeFieldCommandArchive::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_date() {
  if (date_ != NULL) date_->::TSP::Date::Clear();
  clear_has_date();
}
inline const ::TSP::Date& UpdateDateTimeFieldCommandArchive::date() const {
  return date_ != NULL ? *date_ : *default_instance_->date_;
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::mutable_date() {
  set_has_date();
  if (date_ == NULL) date_ = new ::TSP::Date;
  return date_;
}
inline ::TSP::Date* UpdateDateTimeFieldCommandArchive::release_date() {
  clear_has_date();
  ::TSP::Date* temp = date_;
  date_ = NULL;
  return temp;
}
inline void UpdateDateTimeFieldCommandArchive::set_allocated_date(::TSP::Date* date) {
  delete date_;
  date_ = date;
  if (date) {
    set_has_date();
  } else {
    clear_has_date();
  }
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
inline bool UpdateDateTimeFieldCommandArchive::has_date_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateDateTimeFieldCommandArchive::set_has_date_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_has_date_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_date_style() {
  date_style_ = 0;
  clear_has_date_style();
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::date_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(date_style_);
}
inline void UpdateDateTimeFieldCommandArchive::set_date_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  set_has_date_style();
  date_style_ = value;
}

// optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
inline bool UpdateDateTimeFieldCommandArchive::has_time_style() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateDateTimeFieldCommandArchive::set_has_time_style() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_has_time_style() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateDateTimeFieldCommandArchive::clear_time_style() {
  time_style_ = 0;
  clear_has_time_style();
}
inline ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle UpdateDateTimeFieldCommandArchive::time_style() const {
  return static_cast< ::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle >(time_style_);
}
inline void UpdateDateTimeFieldCommandArchive::set_time_style(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle value) {
  assert(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(value));
  set_has_time_style();
  time_style_ = value;
}

// -------------------------------------------------------------------

// ApplyRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ApplyRubyTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyRubyTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyRubyTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ApplyRubyTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ApplyRubyTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ApplyRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool ApplyRubyTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyRubyTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyRubyTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& ApplyRubyTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* ApplyRubyTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void ApplyRubyTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool ApplyRubyTextCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyRubyTextCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyRubyTextCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 ApplyRubyTextCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void ApplyRubyTextCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool ApplyRubyTextCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyRubyTextCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyRubyTextCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 ApplyRubyTextCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void ApplyRubyTextCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional string ruby_text = 5;
inline bool ApplyRubyTextCommandArchive::has_ruby_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_ruby_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyRubyTextCommandArchive::clear_has_ruby_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyRubyTextCommandArchive::clear_ruby_text() {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    ruby_text_->clear();
  }
  clear_has_ruby_text();
}
inline const ::std::string& ApplyRubyTextCommandArchive::ruby_text() const {
  return *ruby_text_;
}
inline void ApplyRubyTextCommandArchive::set_ruby_text(const ::std::string& value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void ApplyRubyTextCommandArchive::set_ruby_text(const char* value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void ApplyRubyTextCommandArchive::set_ruby_text(const char* value, size_t size) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplyRubyTextCommandArchive::mutable_ruby_text() {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  return ruby_text_;
}
inline ::std::string* ApplyRubyTextCommandArchive::release_ruby_text() {
  clear_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ruby_text_;
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplyRubyTextCommandArchive::set_allocated_ruby_text(::std::string* ruby_text) {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    delete ruby_text_;
  }
  if (ruby_text) {
    set_has_ruby_text();
    ruby_text_ = ruby_text;
  } else {
    clear_has_ruby_text();
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool ApplyRubyTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplyRubyTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplyRubyTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplyRubyTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ApplyRubyTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ApplyRubyTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ApplyRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// RemoveRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool RemoveRubyTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveRubyTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveRubyTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveRubyTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& RemoveRubyTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* RemoveRubyTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void RemoveRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool RemoveRubyTextCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveRubyTextCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveRubyTextCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveRubyTextCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& RemoveRubyTextCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* RemoveRubyTextCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void RemoveRubyTextCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 selection_range_location = 3;
inline bool RemoveRubyTextCommandArchive::has_selection_range_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveRubyTextCommandArchive::set_has_selection_range_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveRubyTextCommandArchive::clear_has_selection_range_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveRubyTextCommandArchive::clear_selection_range_location() {
  selection_range_location_ = 0u;
  clear_has_selection_range_location();
}
inline ::google::protobuf::uint32 RemoveRubyTextCommandArchive::selection_range_location() const {
  return selection_range_location_;
}
inline void RemoveRubyTextCommandArchive::set_selection_range_location(::google::protobuf::uint32 value) {
  set_has_selection_range_location();
  selection_range_location_ = value;
}

// optional uint32 selection_range_length = 4;
inline bool RemoveRubyTextCommandArchive::has_selection_range_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoveRubyTextCommandArchive::set_has_selection_range_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoveRubyTextCommandArchive::clear_has_selection_range_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoveRubyTextCommandArchive::clear_selection_range_length() {
  selection_range_length_ = 0u;
  clear_has_selection_range_length();
}
inline ::google::protobuf::uint32 RemoveRubyTextCommandArchive::selection_range_length() const {
  return selection_range_length_;
}
inline void RemoveRubyTextCommandArchive::set_selection_range_length(::google::protobuf::uint32 value) {
  set_has_selection_range_length();
  selection_range_length_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool RemoveRubyTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoveRubyTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoveRubyTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoveRubyTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& RemoveRubyTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* RemoveRubyTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void RemoveRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ModifyRubyTextCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyRubyTextCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyRubyTextCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyRubyTextCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyRubyTextCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ModifyRubyTextCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ModifyRubyTextCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ModifyRubyTextCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference ruby_field = 2;
inline bool ModifyRubyTextCommandArchive::has_ruby_field() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyRubyTextCommandArchive::set_has_ruby_field() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyRubyTextCommandArchive::clear_has_ruby_field() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyRubyTextCommandArchive::clear_ruby_field() {
  if (ruby_field_ != NULL) ruby_field_->::TSP::Reference::Clear();
  clear_has_ruby_field();
}
inline const ::TSP::Reference& ModifyRubyTextCommandArchive::ruby_field() const {
  return ruby_field_ != NULL ? *ruby_field_ : *default_instance_->ruby_field_;
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::mutable_ruby_field() {
  set_has_ruby_field();
  if (ruby_field_ == NULL) ruby_field_ = new ::TSP::Reference;
  return ruby_field_;
}
inline ::TSP::Reference* ModifyRubyTextCommandArchive::release_ruby_field() {
  clear_has_ruby_field();
  ::TSP::Reference* temp = ruby_field_;
  ruby_field_ = NULL;
  return temp;
}
inline void ModifyRubyTextCommandArchive::set_allocated_ruby_field(::TSP::Reference* ruby_field) {
  delete ruby_field_;
  ruby_field_ = ruby_field;
  if (ruby_field) {
    set_has_ruby_field();
  } else {
    clear_has_ruby_field();
  }
}

// optional string ruby_text = 3;
inline bool ModifyRubyTextCommandArchive::has_ruby_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyRubyTextCommandArchive::set_has_ruby_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyRubyTextCommandArchive::clear_has_ruby_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyRubyTextCommandArchive::clear_ruby_text() {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    ruby_text_->clear();
  }
  clear_has_ruby_text();
}
inline const ::std::string& ModifyRubyTextCommandArchive::ruby_text() const {
  return *ruby_text_;
}
inline void ModifyRubyTextCommandArchive::set_ruby_text(const ::std::string& value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void ModifyRubyTextCommandArchive::set_ruby_text(const char* value) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(value);
}
inline void ModifyRubyTextCommandArchive::set_ruby_text(const char* value, size_t size) {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  ruby_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRubyTextCommandArchive::mutable_ruby_text() {
  set_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    ruby_text_ = new ::std::string;
  }
  return ruby_text_;
}
inline ::std::string* ModifyRubyTextCommandArchive::release_ruby_text() {
  clear_has_ruby_text();
  if (ruby_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ruby_text_;
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyRubyTextCommandArchive::set_allocated_ruby_text(::std::string* ruby_text) {
  if (ruby_text_ != &::google::protobuf::internal::kEmptyString) {
    delete ruby_text_;
  }
  if (ruby_text) {
    set_has_ruby_text();
    ruby_text_ = ruby_text;
  } else {
    clear_has_ruby_text();
    ruby_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string base_text = 4;
inline bool ModifyRubyTextCommandArchive::has_base_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyRubyTextCommandArchive::set_has_base_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyRubyTextCommandArchive::clear_has_base_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyRubyTextCommandArchive::clear_base_text() {
  if (base_text_ != &::google::protobuf::internal::kEmptyString) {
    base_text_->clear();
  }
  clear_has_base_text();
}
inline const ::std::string& ModifyRubyTextCommandArchive::base_text() const {
  return *base_text_;
}
inline void ModifyRubyTextCommandArchive::set_base_text(const ::std::string& value) {
  set_has_base_text();
  if (base_text_ == &::google::protobuf::internal::kEmptyString) {
    base_text_ = new ::std::string;
  }
  base_text_->assign(value);
}
inline void ModifyRubyTextCommandArchive::set_base_text(const char* value) {
  set_has_base_text();
  if (base_text_ == &::google::protobuf::internal::kEmptyString) {
    base_text_ = new ::std::string;
  }
  base_text_->assign(value);
}
inline void ModifyRubyTextCommandArchive::set_base_text(const char* value, size_t size) {
  set_has_base_text();
  if (base_text_ == &::google::protobuf::internal::kEmptyString) {
    base_text_ = new ::std::string;
  }
  base_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRubyTextCommandArchive::mutable_base_text() {
  set_has_base_text();
  if (base_text_ == &::google::protobuf::internal::kEmptyString) {
    base_text_ = new ::std::string;
  }
  return base_text_;
}
inline ::std::string* ModifyRubyTextCommandArchive::release_base_text() {
  clear_has_base_text();
  if (base_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = base_text_;
    base_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyRubyTextCommandArchive::set_allocated_base_text(::std::string* base_text) {
  if (base_text_ != &::google::protobuf::internal::kEmptyString) {
    delete base_text_;
  }
  if (base_text) {
    set_has_base_text();
    base_text_ = base_text;
  } else {
    clear_has_base_text();
    base_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 5;
inline bool ModifyRubyTextCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyRubyTextCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyRubyTextCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyRubyTextCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ModifyRubyTextCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* ModifyRubyTextCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void ModifyRubyTextCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ModifyTOCSettingsBaseCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool ModifyTOCSettingsBaseCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& ModifyTOCSettingsBaseCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* ModifyTOCSettingsBaseCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference old_toc_settings = 2;
inline bool ModifyTOCSettingsBaseCommandArchive::has_old_toc_settings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_has_old_toc_settings() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_has_old_toc_settings() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_old_toc_settings() {
  if (old_toc_settings_ != NULL) old_toc_settings_->::TSP::Reference::Clear();
  clear_has_old_toc_settings();
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::old_toc_settings() const {
  return old_toc_settings_ != NULL ? *old_toc_settings_ : *default_instance_->old_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::mutable_old_toc_settings() {
  set_has_old_toc_settings();
  if (old_toc_settings_ == NULL) old_toc_settings_ = new ::TSP::Reference;
  return old_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::release_old_toc_settings() {
  clear_has_old_toc_settings();
  ::TSP::Reference* temp = old_toc_settings_;
  old_toc_settings_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_old_toc_settings(::TSP::Reference* old_toc_settings) {
  delete old_toc_settings_;
  old_toc_settings_ = old_toc_settings;
  if (old_toc_settings) {
    set_has_old_toc_settings();
  } else {
    clear_has_old_toc_settings();
  }
}

// optional .TSP.Reference new_toc_settings = 3;
inline bool ModifyTOCSettingsBaseCommandArchive::has_new_toc_settings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_has_new_toc_settings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_has_new_toc_settings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyTOCSettingsBaseCommandArchive::clear_new_toc_settings() {
  if (new_toc_settings_ != NULL) new_toc_settings_->::TSP::Reference::Clear();
  clear_has_new_toc_settings();
}
inline const ::TSP::Reference& ModifyTOCSettingsBaseCommandArchive::new_toc_settings() const {
  return new_toc_settings_ != NULL ? *new_toc_settings_ : *default_instance_->new_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::mutable_new_toc_settings() {
  set_has_new_toc_settings();
  if (new_toc_settings_ == NULL) new_toc_settings_ = new ::TSP::Reference;
  return new_toc_settings_;
}
inline ::TSP::Reference* ModifyTOCSettingsBaseCommandArchive::release_new_toc_settings() {
  clear_has_new_toc_settings();
  ::TSP::Reference* temp = new_toc_settings_;
  new_toc_settings_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsBaseCommandArchive::set_allocated_new_toc_settings(::TSP::Reference* new_toc_settings) {
  delete new_toc_settings_;
  new_toc_settings_ = new_toc_settings;
  if (new_toc_settings) {
    set_has_new_toc_settings();
  } else {
    clear_has_new_toc_settings();
  }
}

// -------------------------------------------------------------------

// ModifyTOCSettingsForTOCInfoCommandArchive

// optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ModifyTOCSettingsBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsForTOCInfoCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive;
  return super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsForTOCInfoCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference toc_info = 2;
inline bool ModifyTOCSettingsForTOCInfoCommandArchive::has_toc_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_has_toc_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::clear_has_toc_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::clear_toc_info() {
  if (toc_info_ != NULL) toc_info_->::TSP::Reference::Clear();
  clear_has_toc_info();
}
inline const ::TSP::Reference& ModifyTOCSettingsForTOCInfoCommandArchive::toc_info() const {
  return toc_info_ != NULL ? *toc_info_ : *default_instance_->toc_info_;
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::mutable_toc_info() {
  set_has_toc_info();
  if (toc_info_ == NULL) toc_info_ = new ::TSP::Reference;
  return toc_info_;
}
inline ::TSP::Reference* ModifyTOCSettingsForTOCInfoCommandArchive::release_toc_info() {
  clear_has_toc_info();
  ::TSP::Reference* temp = toc_info_;
  toc_info_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsForTOCInfoCommandArchive::set_allocated_toc_info(::TSP::Reference* toc_info) {
  delete toc_info_;
  toc_info_ = toc_info;
  if (toc_info) {
    set_has_toc_info();
  } else {
    clear_has_toc_info();
  }
}

// -------------------------------------------------------------------

// ModifyTOCSettingsPresetForThemeCommandArchive

// optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::ModifyTOCSettingsBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::ModifyTOCSettingsBaseCommandArchive& ModifyTOCSettingsPresetForThemeCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive;
  return super_;
}
inline ::TSWP::ModifyTOCSettingsBaseCommandArchive* ModifyTOCSettingsPresetForThemeCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::ModifyTOCSettingsBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_allocated_super(::TSWP::ModifyTOCSettingsBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference theme = 2;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& ModifyTOCSettingsPresetForThemeCommandArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* ModifyTOCSettingsPresetForThemeCommandArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// optional uint32 preset_index = 3;
inline bool ModifyTOCSettingsPresetForThemeCommandArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::clear_preset_index() {
  preset_index_ = 0u;
  clear_has_preset_index();
}
inline ::google::protobuf::uint32 ModifyTOCSettingsPresetForThemeCommandArchive::preset_index() const {
  return preset_index_;
}
inline void ModifyTOCSettingsPresetForThemeCommandArchive::set_preset_index(::google::protobuf::uint32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// -------------------------------------------------------------------

// AnchorAttachmentCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool AnchorAttachmentCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnchorAttachmentCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnchorAttachmentCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& AnchorAttachmentCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* AnchorAttachmentCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void AnchorAttachmentCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool AnchorAttachmentCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnchorAttachmentCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnchorAttachmentCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void AnchorAttachmentCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSP.Reference attachment = 3;
inline bool AnchorAttachmentCommandArchive::has_attachment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_attachment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnchorAttachmentCommandArchive::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnchorAttachmentCommandArchive::clear_attachment() {
  if (attachment_ != NULL) attachment_->::TSP::Reference::Clear();
  clear_has_attachment();
}
inline const ::TSP::Reference& AnchorAttachmentCommandArchive::attachment() const {
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::TSP::Reference;
  return attachment_;
}
inline ::TSP::Reference* AnchorAttachmentCommandArchive::release_attachment() {
  clear_has_attachment();
  ::TSP::Reference* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void AnchorAttachmentCommandArchive::set_allocated_attachment(::TSP::Reference* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
}

// optional uint32 h_offset_type = 4;
inline bool AnchorAttachmentCommandArchive::has_h_offset_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_h_offset_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnchorAttachmentCommandArchive::clear_has_h_offset_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnchorAttachmentCommandArchive::clear_h_offset_type() {
  h_offset_type_ = 0u;
  clear_has_h_offset_type();
}
inline ::google::protobuf::uint32 AnchorAttachmentCommandArchive::h_offset_type() const {
  return h_offset_type_;
}
inline void AnchorAttachmentCommandArchive::set_h_offset_type(::google::protobuf::uint32 value) {
  set_has_h_offset_type();
  h_offset_type_ = value;
}

// optional float h_offset = 5;
inline bool AnchorAttachmentCommandArchive::has_h_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_h_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnchorAttachmentCommandArchive::clear_has_h_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnchorAttachmentCommandArchive::clear_h_offset() {
  h_offset_ = 0;
  clear_has_h_offset();
}
inline float AnchorAttachmentCommandArchive::h_offset() const {
  return h_offset_;
}
inline void AnchorAttachmentCommandArchive::set_h_offset(float value) {
  set_has_h_offset();
  h_offset_ = value;
}

// optional uint32 v_offset_type = 6;
inline bool AnchorAttachmentCommandArchive::has_v_offset_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_v_offset_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnchorAttachmentCommandArchive::clear_has_v_offset_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnchorAttachmentCommandArchive::clear_v_offset_type() {
  v_offset_type_ = 0u;
  clear_has_v_offset_type();
}
inline ::google::protobuf::uint32 AnchorAttachmentCommandArchive::v_offset_type() const {
  return v_offset_type_;
}
inline void AnchorAttachmentCommandArchive::set_v_offset_type(::google::protobuf::uint32 value) {
  set_has_v_offset_type();
  v_offset_type_ = value;
}

// optional float v_offset = 7;
inline bool AnchorAttachmentCommandArchive::has_v_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_v_offset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnchorAttachmentCommandArchive::clear_has_v_offset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnchorAttachmentCommandArchive::clear_v_offset() {
  v_offset_ = 0;
  clear_has_v_offset();
}
inline float AnchorAttachmentCommandArchive::v_offset() const {
  return v_offset_;
}
inline void AnchorAttachmentCommandArchive::set_v_offset(float value) {
  set_has_v_offset();
  v_offset_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 8;
inline bool AnchorAttachmentCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AnchorAttachmentCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AnchorAttachmentCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& AnchorAttachmentCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* AnchorAttachmentCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void AnchorAttachmentCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// optional bool is_html_wrap = 9;
inline bool AnchorAttachmentCommandArchive::has_is_html_wrap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AnchorAttachmentCommandArchive::set_has_is_html_wrap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AnchorAttachmentCommandArchive::clear_has_is_html_wrap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AnchorAttachmentCommandArchive::clear_is_html_wrap() {
  is_html_wrap_ = false;
  clear_has_is_html_wrap();
}
inline bool AnchorAttachmentCommandArchive::is_html_wrap() const {
  return is_html_wrap_;
}
inline void AnchorAttachmentCommandArchive::set_is_html_wrap(bool value) {
  set_has_is_html_wrap();
  is_html_wrap_ = value;
}

// -------------------------------------------------------------------

// TextApplyThemeCommandArchive

// optional .TSS.ApplyThemeChildCommandArchive super = 1;
inline bool TextApplyThemeCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextApplyThemeCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextApplyThemeCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextApplyThemeCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::ApplyThemeChildCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSS::ApplyThemeChildCommandArchive& TextApplyThemeCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::ApplyThemeChildCommandArchive;
  return super_;
}
inline ::TSS::ApplyThemeChildCommandArchive* TextApplyThemeCommandArchive::release_super() {
  clear_has_super();
  ::TSS::ApplyThemeChildCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void TextApplyThemeCommandArchive::set_allocated_super(::TSS::ApplyThemeChildCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool TextApplyThemeCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextApplyThemeCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextApplyThemeCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextApplyThemeCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& TextApplyThemeCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* TextApplyThemeCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void TextApplyThemeCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool TextApplyThemeCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextApplyThemeCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextApplyThemeCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextApplyThemeCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& TextApplyThemeCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* TextApplyThemeCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void TextApplyThemeCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// MoveColumnsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MoveColumnsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveColumnsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveColumnsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveColumnsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveColumnsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveColumnsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool MoveColumnsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveColumnsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveColumnsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& MoveColumnsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* MoveColumnsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* MoveColumnsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void MoveColumnsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 src_index = 3;
inline bool MoveColumnsCommandArchive::has_src_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_src_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveColumnsCommandArchive::clear_has_src_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveColumnsCommandArchive::clear_src_index() {
  src_index_ = 0u;
  clear_has_src_index();
}
inline ::google::protobuf::uint32 MoveColumnsCommandArchive::src_index() const {
  return src_index_;
}
inline void MoveColumnsCommandArchive::set_src_index(::google::protobuf::uint32 value) {
  set_has_src_index();
  src_index_ = value;
}

// optional uint32 dst_index = 4;
inline bool MoveColumnsCommandArchive::has_dst_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_dst_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveColumnsCommandArchive::clear_has_dst_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveColumnsCommandArchive::clear_dst_index() {
  dst_index_ = 0u;
  clear_has_dst_index();
}
inline ::google::protobuf::uint32 MoveColumnsCommandArchive::dst_index() const {
  return dst_index_;
}
inline void MoveColumnsCommandArchive::set_dst_index(::google::protobuf::uint32 value) {
  set_has_dst_index();
  dst_index_ = value;
}

// optional uint32 count = 5;
inline bool MoveColumnsCommandArchive::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveColumnsCommandArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveColumnsCommandArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 MoveColumnsCommandArchive::count() const {
  return count_;
}
inline void MoveColumnsCommandArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool MoveColumnsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveColumnsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveColumnsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveColumnsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveColumnsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveColumnsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void MoveColumnsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// MoveRowsCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool MoveRowsCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveRowsCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveRowsCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveRowsCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& MoveRowsCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* MoveRowsCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void MoveRowsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference storage = 2;
inline bool MoveRowsCommandArchive::has_storage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveRowsCommandArchive::set_has_storage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveRowsCommandArchive::clear_has_storage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveRowsCommandArchive::clear_storage() {
  if (storage_ != NULL) storage_->::TSP::Reference::Clear();
  clear_has_storage();
}
inline const ::TSP::Reference& MoveRowsCommandArchive::storage() const {
  return storage_ != NULL ? *storage_ : *default_instance_->storage_;
}
inline ::TSP::Reference* MoveRowsCommandArchive::mutable_storage() {
  set_has_storage();
  if (storage_ == NULL) storage_ = new ::TSP::Reference;
  return storage_;
}
inline ::TSP::Reference* MoveRowsCommandArchive::release_storage() {
  clear_has_storage();
  ::TSP::Reference* temp = storage_;
  storage_ = NULL;
  return temp;
}
inline void MoveRowsCommandArchive::set_allocated_storage(::TSP::Reference* storage) {
  delete storage_;
  storage_ = storage;
  if (storage) {
    set_has_storage();
  } else {
    clear_has_storage();
  }
}

// optional uint32 src_index = 3;
inline bool MoveRowsCommandArchive::has_src_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveRowsCommandArchive::set_has_src_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveRowsCommandArchive::clear_has_src_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveRowsCommandArchive::clear_src_index() {
  src_index_ = 0u;
  clear_has_src_index();
}
inline ::google::protobuf::uint32 MoveRowsCommandArchive::src_index() const {
  return src_index_;
}
inline void MoveRowsCommandArchive::set_src_index(::google::protobuf::uint32 value) {
  set_has_src_index();
  src_index_ = value;
}

// optional uint32 dst_index = 4;
inline bool MoveRowsCommandArchive::has_dst_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveRowsCommandArchive::set_has_dst_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveRowsCommandArchive::clear_has_dst_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveRowsCommandArchive::clear_dst_index() {
  dst_index_ = 0u;
  clear_has_dst_index();
}
inline ::google::protobuf::uint32 MoveRowsCommandArchive::dst_index() const {
  return dst_index_;
}
inline void MoveRowsCommandArchive::set_dst_index(::google::protobuf::uint32 value) {
  set_has_dst_index();
  dst_index_ = value;
}

// optional uint32 count = 5;
inline bool MoveRowsCommandArchive::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveRowsCommandArchive::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveRowsCommandArchive::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveRowsCommandArchive::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 MoveRowsCommandArchive::count() const {
  return count_;
}
inline void MoveRowsCommandArchive::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional .TSWP.UndoTransaction undo_transaction = 6;
inline bool MoveRowsCommandArchive::has_undo_transaction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveRowsCommandArchive::set_has_undo_transaction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveRowsCommandArchive::clear_has_undo_transaction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveRowsCommandArchive::clear_undo_transaction() {
  if (undo_transaction_ != NULL) undo_transaction_->::TSWP::UndoTransaction::Clear();
  clear_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveRowsCommandArchive::undo_transaction() const {
  return undo_transaction_ != NULL ? *undo_transaction_ : *default_instance_->undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::mutable_undo_transaction() {
  set_has_undo_transaction();
  if (undo_transaction_ == NULL) undo_transaction_ = new ::TSWP::UndoTransaction;
  return undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveRowsCommandArchive::release_undo_transaction() {
  clear_has_undo_transaction();
  ::TSWP::UndoTransaction* temp = undo_transaction_;
  undo_transaction_ = NULL;
  return temp;
}
inline void MoveRowsCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  delete undo_transaction_;
  undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    set_has_undo_transaction();
  } else {
    clear_has_undo_transaction();
  }
}

// -------------------------------------------------------------------

// ShapeApplyPresetCommandArchive

// required .TSD.ShapeApplyPresetCommandArchive super = 1;
inline bool ShapeApplyPresetCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeApplyPresetCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeApplyPresetCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeApplyPresetCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::ShapeApplyPresetCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::ShapeApplyPresetCommandArchive& ShapeApplyPresetCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::ShapeApplyPresetCommandArchive;
  return super_;
}
inline ::TSD::ShapeApplyPresetCommandArchive* ShapeApplyPresetCommandArchive::release_super() {
  clear_has_super();
  ::TSD::ShapeApplyPresetCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapeApplyPresetCommandArchive::set_allocated_super(::TSD::ShapeApplyPresetCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// -------------------------------------------------------------------

// ShapePasteStyleCommandArchive

// required .TSD.PasteStyleCommandArchive super = 1;
inline bool ShapePasteStyleCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapePasteStyleCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapePasteStyleCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapePasteStyleCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSD::PasteStyleCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSD::PasteStyleCommandArchive& ShapePasteStyleCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSD::PasteStyleCommandArchive;
  return super_;
}
inline ::TSD::PasteStyleCommandArchive* ShapePasteStyleCommandArchive::release_super() {
  clear_has_super();
  ::TSD::PasteStyleCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void ShapePasteStyleCommandArchive::set_allocated_super(::TSD::PasteStyleCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference paragraph_style = 2;
inline bool ShapePasteStyleCommandArchive::has_paragraph_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapePasteStyleCommandArchive::set_has_paragraph_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapePasteStyleCommandArchive::clear_has_paragraph_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapePasteStyleCommandArchive::clear_paragraph_style() {
  if (paragraph_style_ != NULL) paragraph_style_->::TSP::Reference::Clear();
  clear_has_paragraph_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::paragraph_style() const {
  return paragraph_style_ != NULL ? *paragraph_style_ : *default_instance_->paragraph_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_paragraph_style() {
  set_has_paragraph_style();
  if (paragraph_style_ == NULL) paragraph_style_ = new ::TSP::Reference;
  return paragraph_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_paragraph_style() {
  clear_has_paragraph_style();
  ::TSP::Reference* temp = paragraph_style_;
  paragraph_style_ = NULL;
  return temp;
}
inline void ShapePasteStyleCommandArchive::set_allocated_paragraph_style(::TSP::Reference* paragraph_style) {
  delete paragraph_style_;
  paragraph_style_ = paragraph_style;
  if (paragraph_style) {
    set_has_paragraph_style();
  } else {
    clear_has_paragraph_style();
  }
}

// optional .TSP.Reference list_style = 3;
inline bool ShapePasteStyleCommandArchive::has_list_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShapePasteStyleCommandArchive::set_has_list_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShapePasteStyleCommandArchive::clear_has_list_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShapePasteStyleCommandArchive::clear_list_style() {
  if (list_style_ != NULL) list_style_->::TSP::Reference::Clear();
  clear_has_list_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::list_style() const {
  return list_style_ != NULL ? *list_style_ : *default_instance_->list_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_list_style() {
  set_has_list_style();
  if (list_style_ == NULL) list_style_ = new ::TSP::Reference;
  return list_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_list_style() {
  clear_has_list_style();
  ::TSP::Reference* temp = list_style_;
  list_style_ = NULL;
  return temp;
}
inline void ShapePasteStyleCommandArchive::set_allocated_list_style(::TSP::Reference* list_style) {
  delete list_style_;
  list_style_ = list_style;
  if (list_style) {
    set_has_list_style();
  } else {
    clear_has_list_style();
  }
}

// optional .TSP.Reference character_style = 4;
inline bool ShapePasteStyleCommandArchive::has_character_style() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShapePasteStyleCommandArchive::set_has_character_style() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShapePasteStyleCommandArchive::clear_has_character_style() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShapePasteStyleCommandArchive::clear_character_style() {
  if (character_style_ != NULL) character_style_->::TSP::Reference::Clear();
  clear_has_character_style();
}
inline const ::TSP::Reference& ShapePasteStyleCommandArchive::character_style() const {
  return character_style_ != NULL ? *character_style_ : *default_instance_->character_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::mutable_character_style() {
  set_has_character_style();
  if (character_style_ == NULL) character_style_ = new ::TSP::Reference;
  return character_style_;
}
inline ::TSP::Reference* ShapePasteStyleCommandArchive::release_character_style() {
  clear_has_character_style();
  ::TSP::Reference* temp = character_style_;
  character_style_ = NULL;
  return temp;
}
inline void ShapePasteStyleCommandArchive::set_allocated_character_style(::TSP::Reference* character_style) {
  delete character_style_;
  character_style_ = character_style;
  if (character_style) {
    set_has_character_style();
  } else {
    clear_has_character_style();
  }
}

// -------------------------------------------------------------------

// StyleBaseCommandArchive

// optional .TSK.CommandArchive super = 1;
inline bool StyleBaseCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleBaseCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleBaseCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleBaseCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSK::CommandArchive::Clear();
  clear_has_super();
}
inline const ::TSK::CommandArchive& StyleBaseCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSK::CommandArchive;
  return super_;
}
inline ::TSK::CommandArchive* StyleBaseCommandArchive::release_super() {
  clear_has_super();
  ::TSK::CommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleBaseCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference theme = 2;
inline bool StyleBaseCommandArchive::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleBaseCommandArchive::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleBaseCommandArchive::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleBaseCommandArchive::clear_theme() {
  if (theme_ != NULL) theme_->::TSP::Reference::Clear();
  clear_has_theme();
}
inline const ::TSP::Reference& StyleBaseCommandArchive::theme() const {
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::TSP::Reference;
  return theme_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::release_theme() {
  clear_has_theme();
  ::TSP::Reference* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void StyleBaseCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// optional .TSP.Reference style = 3;
inline bool StyleBaseCommandArchive::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyleBaseCommandArchive::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyleBaseCommandArchive::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyleBaseCommandArchive::clear_style() {
  if (style_ != NULL) style_->::TSP::Reference::Clear();
  clear_has_style();
}
inline const ::TSP::Reference& StyleBaseCommandArchive::style() const {
  return style_ != NULL ? *style_ : *default_instance_->style_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::mutable_style() {
  set_has_style();
  if (style_ == NULL) style_ = new ::TSP::Reference;
  return style_;
}
inline ::TSP::Reference* StyleBaseCommandArchive::release_style() {
  clear_has_style();
  ::TSP::Reference* temp = style_;
  style_ = NULL;
  return temp;
}
inline void StyleBaseCommandArchive::set_allocated_style(::TSP::Reference* style) {
  delete style_;
  style_ = style;
  if (style) {
    set_has_style();
  } else {
    clear_has_style();
  }
}

// -------------------------------------------------------------------

// StyleCreateCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleCreateCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleCreateCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleCreateCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleCreateCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::StyleBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::StyleBaseCommandArchive& StyleCreateCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::StyleBaseCommandArchive;
  return super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleCreateCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::StyleBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleCreateCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 preset_index = 2;
inline bool StyleCreateCommandArchive::has_preset_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleCreateCommandArchive::set_has_preset_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleCreateCommandArchive::clear_has_preset_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleCreateCommandArchive::clear_preset_index() {
  preset_index_ = 0u;
  clear_has_preset_index();
}
inline ::google::protobuf::uint32 StyleCreateCommandArchive::preset_index() const {
  return preset_index_;
}
inline void StyleCreateCommandArchive::set_preset_index(::google::protobuf::uint32 value) {
  set_has_preset_index();
  preset_index_ = value;
}

// -------------------------------------------------------------------

// StyleRenameCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleRenameCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleRenameCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleRenameCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleRenameCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::StyleBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::StyleBaseCommandArchive& StyleRenameCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::StyleBaseCommandArchive;
  return super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleRenameCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::StyleBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleRenameCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional string updated_name = 2;
inline bool StyleRenameCommandArchive::has_updated_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleRenameCommandArchive::set_has_updated_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleRenameCommandArchive::clear_has_updated_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleRenameCommandArchive::clear_updated_name() {
  if (updated_name_ != &::google::protobuf::internal::kEmptyString) {
    updated_name_->clear();
  }
  clear_has_updated_name();
}
inline const ::std::string& StyleRenameCommandArchive::updated_name() const {
  return *updated_name_;
}
inline void StyleRenameCommandArchive::set_updated_name(const ::std::string& value) {
  set_has_updated_name();
  if (updated_name_ == &::google::protobuf::internal::kEmptyString) {
    updated_name_ = new ::std::string;
  }
  updated_name_->assign(value);
}
inline void StyleRenameCommandArchive::set_updated_name(const char* value) {
  set_has_updated_name();
  if (updated_name_ == &::google::protobuf::internal::kEmptyString) {
    updated_name_ = new ::std::string;
  }
  updated_name_->assign(value);
}
inline void StyleRenameCommandArchive::set_updated_name(const char* value, size_t size) {
  set_has_updated_name();
  if (updated_name_ == &::google::protobuf::internal::kEmptyString) {
    updated_name_ = new ::std::string;
  }
  updated_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StyleRenameCommandArchive::mutable_updated_name() {
  set_has_updated_name();
  if (updated_name_ == &::google::protobuf::internal::kEmptyString) {
    updated_name_ = new ::std::string;
  }
  return updated_name_;
}
inline ::std::string* StyleRenameCommandArchive::release_updated_name() {
  clear_has_updated_name();
  if (updated_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_name_;
    updated_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StyleRenameCommandArchive::set_allocated_updated_name(::std::string* updated_name) {
  if (updated_name_ != &::google::protobuf::internal::kEmptyString) {
    delete updated_name_;
  }
  if (updated_name) {
    set_has_updated_name();
    updated_name_ = updated_name;
  } else {
    clear_has_updated_name();
    updated_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string old_name = 3;
inline bool StyleRenameCommandArchive::has_old_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyleRenameCommandArchive::set_has_old_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyleRenameCommandArchive::clear_has_old_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyleRenameCommandArchive::clear_old_name() {
  if (old_name_ != &::google::protobuf::internal::kEmptyString) {
    old_name_->clear();
  }
  clear_has_old_name();
}
inline const ::std::string& StyleRenameCommandArchive::old_name() const {
  return *old_name_;
}
inline void StyleRenameCommandArchive::set_old_name(const ::std::string& value) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(value);
}
inline void StyleRenameCommandArchive::set_old_name(const char* value) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(value);
}
inline void StyleRenameCommandArchive::set_old_name(const char* value, size_t size) {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  old_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StyleRenameCommandArchive::mutable_old_name() {
  set_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    old_name_ = new ::std::string;
  }
  return old_name_;
}
inline ::std::string* StyleRenameCommandArchive::release_old_name() {
  clear_has_old_name();
  if (old_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_name_;
    old_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StyleRenameCommandArchive::set_allocated_old_name(::std::string* old_name) {
  if (old_name_ != &::google::protobuf::internal::kEmptyString) {
    delete old_name_;
  }
  if (old_name) {
    set_has_old_name();
    old_name_ = old_name;
  } else {
    clear_has_old_name();
    old_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StyleUpdateCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleUpdateCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleUpdateCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleUpdateCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleUpdateCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::StyleBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::StyleBaseCommandArchive& StyleUpdateCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::StyleBaseCommandArchive;
  return super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleUpdateCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::StyleBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleUpdateCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional .TSP.Reference original_style = 2;
inline bool StyleUpdateCommandArchive::has_original_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleUpdateCommandArchive::set_has_original_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleUpdateCommandArchive::clear_has_original_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleUpdateCommandArchive::clear_original_style() {
  if (original_style_ != NULL) original_style_->::TSP::Reference::Clear();
  clear_has_original_style();
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::original_style() const {
  return original_style_ != NULL ? *original_style_ : *default_instance_->original_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::mutable_original_style() {
  set_has_original_style();
  if (original_style_ == NULL) original_style_ = new ::TSP::Reference;
  return original_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::release_original_style() {
  clear_has_original_style();
  ::TSP::Reference* temp = original_style_;
  original_style_ = NULL;
  return temp;
}
inline void StyleUpdateCommandArchive::set_allocated_original_style(::TSP::Reference* original_style) {
  delete original_style_;
  original_style_ = original_style;
  if (original_style) {
    set_has_original_style();
  } else {
    clear_has_original_style();
  }
}

// optional .TSP.Reference updated_style = 3;
inline bool StyleUpdateCommandArchive::has_updated_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyleUpdateCommandArchive::set_has_updated_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyleUpdateCommandArchive::clear_has_updated_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyleUpdateCommandArchive::clear_updated_style() {
  if (updated_style_ != NULL) updated_style_->::TSP::Reference::Clear();
  clear_has_updated_style();
}
inline const ::TSP::Reference& StyleUpdateCommandArchive::updated_style() const {
  return updated_style_ != NULL ? *updated_style_ : *default_instance_->updated_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::mutable_updated_style() {
  set_has_updated_style();
  if (updated_style_ == NULL) updated_style_ = new ::TSP::Reference;
  return updated_style_;
}
inline ::TSP::Reference* StyleUpdateCommandArchive::release_updated_style() {
  clear_has_updated_style();
  ::TSP::Reference* temp = updated_style_;
  updated_style_ = NULL;
  return temp;
}
inline void StyleUpdateCommandArchive::set_allocated_updated_style(::TSP::Reference* updated_style) {
  delete updated_style_;
  updated_style_ = updated_style;
  if (updated_style) {
    set_has_updated_style();
  } else {
    clear_has_updated_style();
  }
}

// -------------------------------------------------------------------

// StyleDeleteCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleDeleteCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleDeleteCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleDeleteCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleDeleteCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::StyleBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::StyleBaseCommandArchive& StyleDeleteCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::StyleBaseCommandArchive;
  return super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleDeleteCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::StyleBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleDeleteCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 old_preset_index = 2;
inline bool StyleDeleteCommandArchive::has_old_preset_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleDeleteCommandArchive::set_has_old_preset_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleDeleteCommandArchive::clear_has_old_preset_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleDeleteCommandArchive::clear_old_preset_index() {
  old_preset_index_ = 0u;
  clear_has_old_preset_index();
}
inline ::google::protobuf::uint32 StyleDeleteCommandArchive::old_preset_index() const {
  return old_preset_index_;
}
inline void StyleDeleteCommandArchive::set_old_preset_index(::google::protobuf::uint32 value) {
  set_has_old_preset_index();
  old_preset_index_ = value;
}

// -------------------------------------------------------------------

// StyleReorderCommandArchive

// optional .TSWP.StyleBaseCommandArchive super = 1;
inline bool StyleReorderCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleReorderCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleReorderCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleReorderCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSWP::StyleBaseCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSWP::StyleBaseCommandArchive& StyleReorderCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSWP::StyleBaseCommandArchive;
  return super_;
}
inline ::TSWP::StyleBaseCommandArchive* StyleReorderCommandArchive::release_super() {
  clear_has_super();
  ::TSWP::StyleBaseCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleReorderCommandArchive::set_allocated_super(::TSWP::StyleBaseCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}

// optional uint32 old_preset_index = 2;
inline bool StyleReorderCommandArchive::has_old_preset_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StyleReorderCommandArchive::set_has_old_preset_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StyleReorderCommandArchive::clear_has_old_preset_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StyleReorderCommandArchive::clear_old_preset_index() {
  old_preset_index_ = 0u;
  clear_has_old_preset_index();
}
inline ::google::protobuf::uint32 StyleReorderCommandArchive::old_preset_index() const {
  return old_preset_index_;
}
inline void StyleReorderCommandArchive::set_old_preset_index(::google::protobuf::uint32 value) {
  set_has_old_preset_index();
  old_preset_index_ = value;
}

// optional uint32 new_preset_index = 3;
inline bool StyleReorderCommandArchive::has_new_preset_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StyleReorderCommandArchive::set_has_new_preset_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StyleReorderCommandArchive::clear_has_new_preset_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StyleReorderCommandArchive::clear_new_preset_index() {
  new_preset_index_ = 0u;
  clear_has_new_preset_index();
}
inline ::google::protobuf::uint32 StyleReorderCommandArchive::new_preset_index() const {
  return new_preset_index_;
}
inline void StyleReorderCommandArchive::set_new_preset_index(::google::protobuf::uint32 value) {
  set_has_new_preset_index();
  new_preset_index_ = value;
}

// -------------------------------------------------------------------

// StyleUpdatePropertyMapCommandArchive

// required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
inline bool StyleUpdatePropertyMapCommandArchive::has_super() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StyleUpdatePropertyMapCommandArchive::set_has_super() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StyleUpdatePropertyMapCommandArchive::clear_has_super() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StyleUpdatePropertyMapCommandArchive::clear_super() {
  if (super_ != NULL) super_->::TSS::StyleUpdatePropertyMapCommandArchive::Clear();
  clear_has_super();
}
inline const ::TSS::StyleUpdatePropertyMapCommandArchive& StyleUpdatePropertyMapCommandArchive::super() const {
  return super_ != NULL ? *super_ : *default_instance_->super_;
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::mutable_super() {
  set_has_super();
  if (super_ == NULL) super_ = new ::TSS::StyleUpdatePropertyMapCommandArchive;
  return super_;
}
inline ::TSS::StyleUpdatePropertyMapCommandArchive* StyleUpdatePropertyMapCommandArchive::release_super() {
  clear_has_super();
  ::TSS::StyleUpdatePropertyMapCommandArchive* temp = super_;
  super_ = NULL;
  return temp;
}
inline void StyleUpdatePropertyMapCommandArchive::set_allocated_super(::TSS::StyleUpdatePropertyMapCommandArchive* super) {
  delete super_;
  super_ = super;
  if (super) {
    set_has_super();
  } else {
    clear_has_super();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSWP

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSWP::TextCommandArchive_Kind>() {
  return ::TSWP::TextCommandArchive_Kind_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TSWPCommandArchives_2eproto__INCLUDED
